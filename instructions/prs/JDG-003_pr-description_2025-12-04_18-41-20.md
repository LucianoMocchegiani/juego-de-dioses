# perf(frontend): Optimización de rendimiento con instanced rendering y mejoras de UX

## Resumen

Implementa instanced rendering en Three.js para reducir drásticamente los draw calls (de 100k a ~5), permitiendo renderizar terrenos grandes (40m x 40m) sin problemas de rendimiento. Ajusta la grilla para que se alinee dinámicamente con el terreno, limpia constantes no utilizadas y mejora la selección de dimensión demo.

## Motivación

El frontend tenía problemas críticos de rendimiento al renderizar terrenos grandes. Con el método anterior de renderizado individual, el navegador se congelaba o tenía FPS muy bajos (5-10 FPS) al intentar renderizar más de 30x30 celdas. Además, la grilla no estaba alineada con el terreno y había constantes no utilizadas en el código.

## Criterios de Aceptación

- [x] El frontend usa instanced rendering para agrupar partículas del mismo tipo/material
- [x] El rendimiento mejora significativamente: de 5-10 FPS a 50-60 FPS con 100k partículas
- [x] El viewport puede cargar hasta 160x160 celdas (40m x 40m) sin problemas
- [x] La grilla se ajusta dinámicamente al tamaño del terreno y se centra correctamente
- [x] Los ejes se posicionan en el centro del terreno
- [x] Se eliminan todas las constantes no utilizadas
- [x] El frontend selecciona la dimensión demo correcta por nombre exacto
- [x] El backend valida viewports de hasta 500,000 celdas
- [x] El cálculo del viewport considera rangos inclusivos correctamente

## Cambios Técnicos

### Backend
- Aumentado límite de validación de viewport de 100,000 a 500,000 celdas en `backend/src/models/schemas.py`
- Mejorado mensaje de error para indicar el límite actual

### Frontend
- Implementado instanced rendering en `frontend/src/scene.js`:
  - Agrupación de partículas por tipo/material para maximizar instancing
  - Uso de `THREE.InstancedMesh` en lugar de meshes individuales
  - Reducción de draw calls de 100,000 a ~5 (mejora de 20,000x)
  - Compartir geometrías y materiales para reducir uso de memoria
- Aumentados límites de viewport en `frontend/src/constants.js`:
  - `VIEWPORT_MAX_CELLS_X`: de 30 a 160 celdas
  - `VIEWPORT_MAX_CELLS_Y`: de 30 a 160 celdas
- Mejorado cálculo de viewport en `frontend/src/main.js`:
  - Cálculo correcto de rangos inclusivos (x_max - x_min + 1)
  - Cálculo dinámico de niveles Z basado en área X×Y
  - Validación para no exceder límite del backend
- Implementada grilla dinámica en `frontend/src/scene.js`:
  - Método `updateHelpers()` que ajusta grilla y ejes al tamaño del terreno
  - Grilla 20% más grande que el terreno para contexto
  - Ejes proporcionales al tamaño del terreno
  - Centrado automático en el terreno
- Mejorada selección de dimensión demo en `frontend/src/main.js`:
  - Agregada constante `DEMO_DIMENSION_NAME` en `constants.js`
  - Búsqueda por nombre exacto en lugar de búsqueda parcial
  - Error más informativo con dimensiones disponibles
- Limpieza de constantes no utilizadas:
  - Eliminadas `GRID_SIZE`, `GRID_DIVISIONS`, `AXES_SIZE` (ahora se calculan dinámicamente)
  - Eliminadas `VIEWPORT_DEFAULT_Z_MIN`, `VIEWPORT_DEFAULT_Z_MAX` (no se usan)
  - Eliminadas importaciones correspondientes en `scene.js`

## Testing

- Probado localmente con Docker Compose
- Verificado que terreno de 40m x 40m se carga y renderiza correctamente
- Verificado que el FPS se mantiene por encima de 50 FPS con 100k+ partículas
- Verificado que la grilla está centrada y alineada con el terreno
- Verificado que se selecciona la dimensión demo correcta cuando hay múltiples dimensiones
- Verificado que viewports grandes (>500k celdas) son rechazados correctamente por el backend

## Referencias

- Ticket: JDG-003
- PRs relacionados: JDG-001 (terrenos grandes)
- Documentación relacionada: Three.js InstancedMesh

## Deployment

### Cambios Requeridos
- [x] Rebuild Docker images
- [ ] Ejecutar migraciones de base de datos (no aplica)
- [ ] Actualizar variables de entorno (no aplica)
- [x] Reiniciar servicios Docker

### Verificación Post-Deployment
- [x] Verificar frontend en navegador
- [x] Verificar que el terreno se carga correctamente
- [x] Verificar que la grilla está alineada
- [x] Verificar logs de Docker

## Riesgos y Plan de Rollback

**Riesgos:**
- Bajo: Los cambios son principalmente optimizaciones que no afectan la funcionalidad
- El instanced rendering es transparente para el usuario (mismo resultado visual)
- Si hay problemas, se puede revertir fácilmente al método anterior

**Plan de Rollback:**
1. Revertir commits relacionados con instanced rendering
2. Restaurar límites de viewport anteriores
3. Restaurar constantes eliminadas si es necesario
4. Rebuild y restart de contenedores Docker

## Notas Adicionales

- El instanced rendering es completamente transparente para el usuario (mismo resultado visual)
- La optimización permite expandir el tamaño máximo de terrenos en el futuro
- La grilla dinámica mejora la experiencia visual y la orientación del usuario
- La limpieza de constantes mejora la mantenibilidad del código
- El rendimiento mejorado permite considerar terrenos aún más grandes en el futuro

