# refactor(combat): Sistema de Combate Centralizado con COMBAT_ACTIONS y Fix de Loops Infinitos

## Resumen

Refactoriza el sistema de combate para usar configuración centralizada (`combat-actions-config.js`), implementa dodge estilo Dark Souls con cooldown y movimiento, agrega estado persistente durante animaciones, y corrige loops infinitos en animaciones de parry y dodge. También migra attack al nuevo sistema unificado.

## Motivación

El sistema de combate tenía valores hardcodeados, no había cooldowns, y el estado se reseteaba cada frame causando problemas de sincronización. Además, las animaciones de parry y dodge quedaban en loop infinito debido a race conditions entre sistemas. El attack estaba duplicado fuera del loop principal de acciones.

## Criterios de Aceptación

- [x] Existe archivo `combat-actions-config.js` con configuración centralizada de acciones de combate
- [x] `CombatComponent` tiene propiedades para trackear acción activa y cooldowns
- [x] El dodge tiene cooldown de 0.5 segundos y no se puede spamear
- [x] El estado de acciones persiste durante toda la animación (no se resetea cada frame)
- [x] El sistema detecta cuando las animaciones terminan y resetea el estado correctamente
- [x] Las animaciones no se pueden interrumpir durante la ejecución (protección contra interrupciones)
- [x] Parry se mantiene activo mientras la tecla está presionada
- [x] Dodge solo se activa una vez por press de tecla
- [x] Attack está completamente migrado al sistema unificado
- [x] No hay loops infinitos en animaciones de combate

## Cambios Técnicos

### Frontend

**Configuración:**
- Creado `frontend/src/config/combat-actions-config.js`: Configuración centralizada de acciones de combate (dodge, parry, specialAttack, heavyAttack, chargedAttack, lightAttack) con cooldown, movimiento, i-frames
- Actualizado `frontend/src/config/README.md`: Documentación del nuevo archivo de configuración

**Componentes:**
- `frontend/src/ecs/components/combat.js`: 
  - Agregadas propiedades `activeAction`, `actionStartTime`, `actionCooldowns`, `hasIFrames`
  - Agregados métodos `startAction()`, `endAction()`, `isOnCooldown()`, `updateCooldowns()`
  - Modificado `reset()` para no limpiar `defenseType` si hay `activeAction` activa

**Sistemas:**
- `frontend/src/ecs/systems/combat-system.js`:
  - Refactorizado para usar `COMBAT_ACTIONS` en lugar de lógica hardcodeada
  - Agregada verificación de cooldowns antes de ejecutar acciones
  - Movido attack dentro del loop principal de `COMBAT_ACTIONS` (unificación)
  - Agregada lógica especial para parry (mantener presionado) y dodge (single press)
  - Bloqueo de procesamiento de nuevas acciones mientras hay una activa

- `frontend/src/ecs/systems/physics-system.js`:
  - Refactorizado movimiento de dodge para usar `COMBAT_ACTIONS` en lugar de valores hardcodeados
  - Soporte para movimiento direccional basado en input o cámara
  - Flag `movementApplied` para aplicar impulso solo una vez por acción

- `frontend/src/ecs/systems/animation-mixer-system.js`:
  - Agregada detección de fin de animaciones de combate usando `combatAction`
  - Limpieza temprana de `defenseType` al 95% de progreso para prevenir race conditions
  - Lógica especial para parry (reactivación si tecla presionada) y dodge (limpieza completa)
  - Eliminado código legacy de `attackAction` (ahora todo usa `combatAction`)
  - Simplificada detección de acciones de combate
  - Corrección de `playAnimation()` para usar ID de estado en lugar de nombre de animación

- `frontend/src/ecs/systems/animation-state-system.js`:
  - Verificación estricta de `activeAction` antes de activar estados de combate

- `frontend/src/ecs/animation/states/state-registry.js`:
  - Agregada verificación de `activeAction` antes de evaluar condiciones de estados de combate
  - Previene reactivación de estados cuando la animación está terminando

## Testing

- [x] Probado localmente con Docker Compose
- [x] Dodge funciona con cooldown de 0.5 segundos
- [x] Parry se mantiene activo mientras la tecla Q está presionada
- [x] Dodge solo se activa una vez por press de tecla E
- [x] Attack funciona correctamente dentro del nuevo sistema
- [x] No hay loops infinitos en ninguna animación de combate
- [x] Las animaciones terminan correctamente y resetean el estado
- [x] Otras acciones (heavy, charged, special) funcionan correctamente

## Referencias

- Ticket: JDG-027
- Análisis de Arquitectura: `instructions/analysis/JDG-027-2-architecture-analysis_2025-12-13_13-55-39.md`
- Análisis de Integración: `instructions/analysis/JDG-027-3-architecture-integration-analysis_2025-12-13_14-10-30.md`
- Plan de Acción: `instructions/tasks/JDG-027-action-plan_2025-12-13_10-51-04.md`
- Documentación de Flujo: `instructions/FLUJO-ANIMACION-COMBATE.md`

## Deployment

### Cambios Requeridos

- [ ] Rebuild Docker images (si hay cambios en frontend)
- [ ] Reiniciar servicios Docker

### Verificación Post-Deployment

- [x] Verificar frontend en navegador
- [x] Verificar que todas las animaciones de combate funcionan correctamente
- [x] Verificar que no hay loops infinitos

## Riesgos y Plan de Rollback

**Riesgos:**
- Bajo riesgo: Cambios son principalmente refactorización y correcciones de bugs
- Si hay problemas, el sistema anterior podría restaurarse revirtiendo el commit

**Plan de Rollback:**
1. Revertir commit del PR si hay problemas críticos
2. Rebuild de imágenes Docker si es necesario

## Notas Adicionales

- El sistema ahora está preparado para futuras mejoras como i-frames y diferentes tipos de movimiento
- Agregar nuevas acciones de combate solo requiere agregar entrada en `COMBAT_ACTIONS` y `ANIMATION_STATES`
- El orden de acciones en `COMBAT_ACTIONS` determina la prioridad de procesamiento

## Anexo: Cambios Fuera del Plan

### Corrección de Bug: Loop Infinito en Animaciones de Combate

**Problema:** Las animaciones de parry y dodge quedaban en loop infinito debido a un race condition entre `AnimationStateSystem` (priority 2) y `AnimationMixerSystem` (priority 2.5).

**Archivos afectados:**
- `frontend/src/ecs/animation/states/state-registry.js`: Agregada verificación de `activeAction` antes de evaluar condiciones de estados de combate
- `frontend/src/ecs/systems/animation-mixer-system.js`: Implementada limpieza temprana de `defenseType` al 95% de progreso para prevenir race conditions

**Solución:**
- `StateRegistry` ahora verifica que exista `activeAction` antes de activar estados de combate
- `AnimationMixerSystem` limpia `defenseType` temprano (95% progreso) antes de que termine la animación
- Esto previene que `AnimationStateSystem` vea valores residuales y reactive el estado

**Impacto:** Crítico - Sin esto, las animaciones de parry y dodge no funcionan correctamente.

### Migración de Attack al Sistema Unificado

**Problema:** Attack estaba duplicado fuera del loop principal de `COMBAT_ACTIONS`, creando inconsistencias y código redundante.

**Archivos afectados:**
- `frontend/src/ecs/systems/combat-system.js`: Movido código de attack dentro del loop principal
- `frontend/src/ecs/systems/animation-mixer-system.js`: Eliminado código legacy de `attackAction` (redundante)

**Solución:**
- Attack ahora se procesa dentro del loop de `COMBAT_ACTIONS` junto con las demás acciones
- Eliminado código legacy que manejaba `attackAction` separado
- Todas las acciones de combate usan el mismo flujo unificado

**Impacto:** Mejora de mantenibilidad - Código más limpio y consistente.

### Corrección de Bug: playAnimation usando nombre de animación en lugar de ID de estado

**Problema:** `playAnimation()` recibía el nombre de la animación (`'sword_parry_backward'`) en lugar del ID del estado (`'parry'`), causando que no encontrara la configuración correcta y no detectara `isOneShot=true`.

**Archivos afectados:**
- `frontend/src/ecs/systems/animation-mixer-system.js`: Modificado `playAnimation()` para aceptar ID de estado y resolver el nombre de animación internamente

**Solución:**
- `playAnimation()` ahora acepta ID de estado y resuelve el nombre de animación correctamente
- El código que llama a `playAnimation()` ahora pasa el estado en lugar del nombre de animación

**Impacto:** Crítico - Sin esto, las animaciones no se configuran como `LoopOnce` y no terminan correctamente.

