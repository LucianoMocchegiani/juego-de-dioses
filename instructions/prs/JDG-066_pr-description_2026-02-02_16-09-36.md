# refactor(backend): Migración a Arquitectura Hexagonal + DDD en dominios

## Resumen

Migración del backend a Hexagonal + DDD: todos los dominios (bloques, particles, characters, celestial, agrupaciones) tienen puertos de repositorio, adaptadores Postgres, casos de uso y routes como adaptadores de entrada. Ningún `routes.py` usa `get_connection()` ni SQL; la persistencia queda en `infrastructure/`. Se añaden puerto de creación de personajes (ICharacterCreationPort), desacoplo de celestial de particles.service (IParticleRepository extendido) y puerto de temperatura (ITemperatureCalculator) para WorldBloque. Documentación en código (comentarios por método) en todos los dominios.

## Motivación

Centralizar acceso a BD en puertos/adaptadores, eliminar `get_connection()` y SQL de routes y application, y permitir tests con mocks y futuros cambios de persistencia sin tocar lógica de negocio. Cumplir criterios del plan JDG-066 (parcial: Paso 6 world_creation_engine diferido).

## Criterios de Aceptación

- [x] Dominios bloques, particles, characters, celestial, agrupaciones tienen puerto, adaptador Postgres y casos de uso; routes sin SQL
- [ ] world_creation_engine usa repositorios inyectados (diferido; create_character usa ICharacterCreationPort con EntityCreationAdapter que internamente usa EntityCreator)
- [x] Cada router inyecta repositorios vía Depends; no hay get_connection en routes ni en application
- [x] READMEs de backend y dominios actualizados (estructura Hexagonal+DDD)
- [ ] Tests unitarios de al menos un caso de uso por dominio (no aplica por ahora)
- [x] API (URLs y contratos JSON) idéntica a la actual

## Cambios Técnicos

### Backend

- **bloques:** IBloqueRepository, PostgresBloqueRepository, casos de uso get_bloques, get_bloque_by_id, get_world_size; routes con Depends(get_bloque_repository)
- **particles:** IParticleRepository extendido con get_particles_near, get_particle_type_by_name, get_distinct_bloque_ids_for_temperature_update, get_particles_with_thermal_inertia, update_particle_temperature; PostgresParticleRepository implementa todos; casos de uso y routes con Depends
- **characters:** ICharacterRepository, ICharacterCreationPort; PostgresCharacterRepository, EntityCreationAdapter (usa EntityCreator internamente); casos de uso list_characters, get_character, get_character_model, create_character vía puerto; routes sin get_connection
- **celestial:** Casos de uso get_celestial_state, calculate_temperature_use_case; calculate_cell_temperature recibe IParticleRepository inyectado; tarea en background de temperatura usa PostgresParticleRepository (sin particles.service ni get_connection en la tarea)
- **agrupaciones:** IAgrupacionRepository, PostgresAgrupacionRepository, casos de uso get_agrupaciones, get_agrupacion_with_particles; routes con Depends
- **shared:** ITemperatureCalculator en shared/ports; CelestialTemperatureCalculatorAdapter en celestial; WorldBloque y WorldBloqueManager aceptan temperature_calculator opcional
- **Documentación en código:** Comentarios/docstrings por método en routes, application, ports e infrastructure de todos los dominios (flujo hexagonal, responsabilidad de cada capa)

### Base de Datos

- Sin cambios de schema; mismas tablas y consultas, movidas a adaptadores Postgres

### Docker/Infraestructura

- Sin cambios

## Testing

- Verificación manual de que la API expuesta no cambió (mismos endpoints y contratos)
- Probado que routes delegan en casos de uso y que los adaptadores ejecutan las queries en infrastructure
- No se añadieron tests unitarios con mocks en este PR (plan indica no aplica por ahora)

## Referencias

- Ticket: JDG-066
- Plan de acción: instructions/tasks/JDG-066-action-plan_2026-02-02_14-05-28.md
- Documentación: backend/src/domains/README.md, docs/flujo-endpoints-hexagonal-ddd.md (si existe)

## Deployment

### Cambios Requeridos

- [ ] Rebuild Docker images del backend
- [ ] No migraciones de base de datos
- [ ] No nuevas variables de entorno
- [ ] Reiniciar servicios backend

### Verificación Post-Deployment

- [ ] GET /api/v1/bloques, /bloques/{id}, /bloques/world/size
- [ ] GET /api/v1/bloques/{id}/particles, particle-types, particles/{particle_id}
- [ ] GET /api/v1/bloques/{id}/characters, characters/{character_id}, characters/{id}/model; POST create_character
- [ ] GET /api/v1/celestial/state; POST /celestial/temperature
- [ ] GET /api/v1/bloques/{id}/agrupaciones, agrupaciones/{agrupacion_id}
- [ ] Logs sin errores de importación o inyección

## Riesgos y Plan de Rollback

- **Riesgo:** Cambio amplio en capas de backend; un error de inyección podría devolver 500 en algún endpoint.
- **Mitigación:** Misma API y contratos; revisión de Depends en cada route.
- **Rollback:** Revertir commit/PR y desplegar versión anterior; no hay migraciones que revertir.

## Notas Adicionales

- Paso 6 (world_creation_engine con repos inyectados en EntityCreator/builders) quedó diferido; create_character usa ICharacterCreationPort y EntityCreationAdapter, que encapsula EntityCreator(conn) dentro del adaptador, por lo que routes ya no usan get_connection.
- Código deprecado en particles.service y celestial.service fue documentado o eliminado según el plan (get_particulas_con_inercia, update_particle_temperature en service eliminados tras migrar a IParticleRepository).
