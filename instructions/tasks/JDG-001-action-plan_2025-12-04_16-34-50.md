# JDG-001 - Reglas de construcción de terrenos y límites de dimensión

## Descripción de la Tarea

Implementar reglas de construcción de terrenos estableciendo partículas límite indestructibles y transparentes que definan los límites del mundo. Además, crear archivos de documentación con ejemplos detallados de construcción de diferentes tipos de terrenos, biomas, zonas subterráneas y características geológicas para que los dioses puedan crear mundos de forma efectiva.

**Comportamiento actual:**
- No existen reglas claras para la construcción de terrenos
- No hay ejemplos documentados de cómo crear diferentes tipos de biomas o zonas
- Los dioses no tienen referencias de cómo estructurar terrenos complejos
- No hay documentación sobre cómo crear acuíferos, napas subterráneas o zonas subterráneas
- No hay validación de límites al crear partículas

**Comportamiento esperado:**
- Al crear una dimensión, se genera automáticamente una capa de partículas `límite` en `z = profundidad_maxima`
- Las partículas `límite` son indestructibles (no pueden ser extraídas o modificadas)
- Las partículas `límite` son transparentes (opacity < 1.0 o completamente transparentes)
- Las partículas `límite` cubren todo el área horizontal de la dimensión
- El sistema valida que los dioses no puedan crear partículas fuera de los límites definidos
- El frontend renderiza las partículas `límite` como transparentes (o no las renderiza si son invisibles)
- Existen archivos de documentación detallados con ejemplos de construcción de diferentes biomas, zonas subterráneas y acuíferos
- Cada ejemplo incluye estructura de capas, distribución espacial, propiedades de partículas y reglas de generación paso a paso

## Criterios de Aceptación

### Feature: Reglas de construcción de terrenos (PRIORITARIO)
1. ❌ Existe un tipo de partícula `límite` (o nombre acordado) en la base de datos
2. ❌ Las partículas `límite` tienen la propiedad de ser indestructibles (no pueden ser extraídas)
3. ❌ Las partículas `límite` son transparentes (opacity < 1.0 o completamente transparentes)
4. ❌ Al crear una dimensión, se genera automáticamente una capa de partículas `límite` en `z = profundidad_maxima`
5. ❌ La capa de partículas `límite` cubre todo el área horizontal de la dimensión (x_min a x_max, y_min a y_max)
6. ❌ El sistema valida que los dioses no puedan crear partículas fuera de los límites definidos
7. ❌ El frontend renderiza las partículas `límite` como transparentes (o no las renderiza si son invisibles)
8. ❌ Se documenta cómo usar partículas `límite` para cielo y laterales (opcional para esta fase)

### Feature: Ejemplos de creación de terrenos
1. ❌ Existe carpeta `instructions/examples/terrenos/` con archivos de ejemplos
2. ❌ Existe al menos un ejemplo de bioma (bosque, desierto, tundra, etc.)
3. ❌ Existe al menos un ejemplo de zona subterránea (cueva, túnel, sistema de cavernas)
4. ❌ Existe al menos un ejemplo de acuífero o napa subterránea
5. ❌ Cada ejemplo incluye estructura de capas (qué partículas en qué niveles z)
6. ❌ Cada ejemplo incluye distribución espacial (cómo se distribuyen las partículas en x, y)
7. ❌ Cada ejemplo incluye propiedades de las partículas (densidad, temperatura, etc.)
8. ❌ Cada ejemplo incluye reglas de generación paso a paso
9. ❌ Los ejemplos están escritos con suficiente nivel de detalle para que los dioses puedan replicarlos
10. ❌ Los ejemplos cubren casos comunes de construcción de terrenos

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Frontend: HTML5, JavaScript ES6+, Three.js
- Base de datos: PostgreSQL 16 (JSONB para estilos)
- Validación: Pydantic (validación de límites)
- Queries: asyncpg con validación de límites

## Pasos de Implementación

### Paso 1: Crear tipo de partícula `límite` en base de datos

**Descripción:**
Agregar el tipo de partícula `límite` a la tabla `tipos_particulas` con propiedades especiales: categoría "sistema", estilos transparentes, y marcado como tipo especial que no puede ser extraído.

**Archivos a modificar/crear:**
- `database/init/02-seed-data.sql` - Agregar tipo `límite` en INSERT de tipos_particulas
- `database/init/01-init-schema.sql` - Verificar que la tabla `tipos_particulas` tenga los campos necesarios

**Detalles de implementación:**
```sql
-- En 02-seed-data.sql, agregar después de los tipos existentes:
INSERT INTO juego_dioses.tipos_particulas (nombre, categoria, densidad, color_base, estilos) VALUES
('límite', 'sistema', 999999.0, 'transparent', 
 '{"color_hex": "#000000", "material": {"metalness": 0.0, "roughness": 1.0}, "visual": {"opacity": 0.0}}'::jsonb)
ON CONFLICT (nombre) DO NOTHING;
```

**Notas:**
- El nombre `límite` puede cambiarse si se encuentra uno más apropiado
- La densidad alta (999999.0) indica que es indestructible conceptualmente
- El color puede ser cualquier color ya que será transparente (opacity: 0.0)
- La categoría "sistema" diferencia estas partículas de las creadas por dioses

**Recursos útiles:**
- Ver estructura de `tipos_particulas` en `database/init/01-init-schema.sql`
- Ver formato de estilos JSONB en `JDG-002` (estilos en base de datos)

---

### Paso 2: Agregar campo `indestructible` a tabla `particulas` (opcional) o implementar validación por tipo

**Descripción:**
Decidir si agregar un campo `indestructible` a la tabla `particulas` o validar por tipo de partícula en la lógica de negocio. Para esta implementación inicial, se recomienda validar por tipo (más simple y no requiere migración).

**Archivos a modificar/crear:**
- `database/init/01-init-schema.sql` - Agregar campo `indestructible` si se decide usar campo (opcional)
- `backend/src/api/routes/particles.py` - Agregar validación por tipo en endpoints de extracción

**Detalles de implementación:**

**Opción A: Validación por tipo (RECOMENDADO para esta fase)**
```python
# En particles.py, en endpoint de extracción:
INDESTRUCTIBLE_TYPES = ['límite']  # Lista de tipos que no pueden ser extraídos

async def extract_particle(particle_id: UUID, ...):
    # Obtener partícula y su tipo
    particle = await get_particle(particle_id)
    tipo_nombre = particle.tipo_nombre
    
    # Validar que no sea indestructible
    if tipo_nombre in INDESTRUCTIBLE_TYPES:
        raise HTTPException(
            status_code=403,
            detail=f"No se puede extraer partícula de tipo '{tipo_nombre}' (indestructible)"
        )
    
    # Continuar con extracción normal...
```

**Opción B: Campo en tabla (para futuras fases)**
```sql
-- En 01-init-schema.sql:
ALTER TABLE juego_dioses.particulas 
ADD COLUMN IF NOT EXISTS indestructible BOOLEAN DEFAULT false;

-- Crear índice para búsquedas rápidas:
CREATE INDEX IF NOT EXISTS idx_particulas_indestructible 
ON juego_dioses.particulas(indestructible) 
WHERE indestructible = true;
```

**Notas:**
- Para esta fase, se recomienda Opción A (validación por tipo) por simplicidad
- La Opción B permite más flexibilidad pero requiere migración de datos existentes
- Se puede migrar a Opción B en el futuro si se necesita más granularidad

**Recursos útiles:**
- Ver endpoints de extracción en `backend/src/api/routes/particles.py`

---

### Paso 3: Implementar creación automática de partículas límite al crear dimensión

**Descripción:**
Modificar la lógica de creación de dimensiones para que automáticamente genere una capa completa de partículas `límite` en `z = profundidad_maxima` que cubra todo el área horizontal de la dimensión.

**Archivos a modificar/crear:**
- `backend/src/database/seed_demo.py` - Agregar función para crear partículas límite
- O crear: `backend/src/database/terrain_builder.py` - Módulo para construcción de terrenos

**Detalles de implementación:**
```python
# En seed_demo.py o nuevo módulo terrain_builder.py:

async def create_boundary_layer(conn, dimension_id: UUID, dimension_data: dict):
    """
    Crear capa de partículas límite en el límite inferior de la dimensión.
    
    Args:
        conn: Conexión asyncpg
        dimension_id: UUID de la dimensión
        dimension_data: Dict con ancho_metros, alto_metros, profundidad_maxima, tamano_celda
    """
    # Obtener tipo límite
    tipo_limite_id = await conn.fetchval(
        "SELECT id FROM juego_dioses.tipos_particulas WHERE nombre = 'límite'"
    )
    
    if not tipo_limite_id:
        raise ValueError("Tipo de partícula 'límite' no existe en la base de datos")
    
    # Obtener estado sólido (para partículas límite)
    estado_solido_id = await conn.fetchval(
        "SELECT id FROM juego_dioses.estados_materia WHERE nombre = 'solido'"
    )
    
    # Calcular celdas
    celdas_x = int(dimension_data['ancho_metros'] / dimension_data['tamano_celda'])
    celdas_y = int(dimension_data['alto_metros'] / dimension_data['tamano_celda'])
    z_limite = dimension_data['profundidad_maxima']
    
    # Crear partículas límite para toda el área horizontal
    particulas = []
    for x in range(celdas_x):
        for y in range(celdas_y):
            particulas.append({
                'dimension_id': dimension_id,
                'celda_x': x,
                'celda_y': y,
                'celda_z': z_limite,
                'tipo_particula_id': tipo_limite_id,
                'estado_materia_id': estado_solido_id,
                'cantidad': 1.0,
                'temperatura': 0.0,
                'energia': 0.0,
                'extraida': False,
                'es_nucleo': False,
                'propiedades': {}
            })
    
    # Insertar en batch para mejor rendimiento
    await conn.executemany("""
        INSERT INTO juego_dioses.particulas 
        (dimension_id, celda_x, celda_y, celda_z, tipo_particula_id, estado_materia_id,
         cantidad, temperatura, energia, extraida, es_nucleo, propiedades)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12::jsonb)
    """, [(p['dimension_id'], p['celda_x'], p['celda_y'], p['celda_z'],
           p['tipo_particula_id'], p['estado_materia_id'], p['cantidad'],
           p['temperatura'], p['energia'], p['extraida'], p['es_nucleo'],
           json.dumps(p['propiedades'])) for p in particulas])
    
    return len(particulas)

# Llamar esta función después de crear una dimensión:
# await create_boundary_layer(conn, dimension_id, dimension_data)
```

**Notas:**
- Usar `executemany` para mejor rendimiento al insertar muchas partículas
- Considerar optimización: si la dimensión es muy grande, insertar en batches
- Las partículas límite deben crearse ANTES de que los dioses creen contenido
- Se puede llamar automáticamente en el endpoint de creación de dimensiones

**Recursos útiles:**
- Ver `backend/src/database/seed_demo.py` para ejemplos de creación de partículas
- Ver estructura de tabla `particulas` en `database/init/01-init-schema.sql`

---

### Paso 4: Implementar validación de límites en endpoints de creación de partículas

**Descripción:**
Agregar validación en los endpoints de creación de partículas para que los dioses no puedan crear partículas fuera de los límites definidos por las partículas `límite`.

**Archivos a modificar/crear:**
- `backend/src/api/routes/particles.py` - Agregar validación de límites
- `backend/src/models/schemas.py` - Agregar validación en schemas si es necesario

**Detalles de implementación:**
```python
# En particles.py:

async def validate_particle_position(conn, dimension_id: UUID, x: int, y: int, z: int) -> bool:
    """
    Validar que la posición de la partícula esté dentro de los límites de la dimensión.
    
    Retorna True si la posición es válida, False si está fuera de límites.
    """
    # Obtener límites de la dimensión
    dim = await conn.fetchrow("""
        SELECT ancho_metros, alto_metros, profundidad_maxima, altura_maxima, tamano_celda
        FROM juego_dioses.dimensiones
        WHERE id = $1
    """, dimension_id)
    
    if not dim:
        return False
    
    # Calcular límites en celdas
    max_x = int(dim['ancho_metros'] / dim['tamano_celda'])
    max_y = int(dim['alto_metros'] / dim['tamano_celda'])
    min_z = dim['profundidad_maxima']
    max_z = dim['altura_maxima']
    
    # Validar límites
    if x < 0 or x >= max_x:
        return False
    if y < 0 or y >= max_y:
        return False
    if z < min_z or z > max_z:
        return False
    
    return True

# En endpoint de creación de partícula:
@router.post("/{dimension_id}/particles")
async def create_particle(dimension_id: UUID, particle_data: ParticleCreate):
    async with get_connection() as conn:
        # Validar posición
        is_valid = await validate_particle_position(
            conn, dimension_id, 
            particle_data.celda_x, 
            particle_data.celda_y, 
            particle_data.celda_z
        )
        
        if not is_valid:
            raise HTTPException(
                status_code=400,
                detail="La posición de la partícula está fuera de los límites de la dimensión"
            )
        
        # Continuar con creación normal...
```

**Notas:**
- La validación debe verificar límites horizontales (x, y) y verticales (z)
- Retornar error descriptivo si la posición está fuera de límites
- Considerar validar también que no se cree partícula en la misma posición que una partícula `límite` (opcional)

**Recursos útiles:**
- Ver endpoints de creación en `backend/src/api/routes/particles.py`
- Ver estructura de `ParticleCreate` en `backend/src/models/schemas.py`

---

### Paso 5: Implementar renderizado transparente de partículas límite en frontend

**Descripción:**
Modificar el frontend para que las partículas `límite` se rendericen como transparentes o no se rendericen si son completamente invisibles (opacity: 0.0).

**Archivos a modificar/crear:**
- `frontend/src/scene.js` - Modificar lógica de renderizado para partículas límite
- `frontend/src/constants.js` - Agregar constantes si es necesario

**Detalles de implementación:**
```javascript
// En scene.js, modificar createParticleMesh o renderParticles:

createParticleMesh(particle, cellSize) {
    const estilo = this.getStyle(particle.tipo);
    
    // Si es partícula límite, verificar opacidad
    if (particle.tipo === 'límite') {
        // Si opacity es 0.0, no renderizar
        if (estilo.opacity === 0.0 || estilo.opacity === undefined) {
            return null; // No crear mesh
        }
        // Si tiene opacidad baja, renderizar como transparente
        estilo.transparent = true;
        estilo.opacity = estilo.opacity || 0.0;
    }
    
    const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
    const material = this.createMaterial({ ...estilo });
    const cube = new THREE.Mesh(geometry, material);
    
    // ... resto del código ...
}

// En renderParticles, filtrar partículas límite invisibles:
renderParticles(particles, cellSize = DEFAULT_CELL_SIZE) {
    this.clearParticles();

    particles.forEach((particle) => {
        // Saltar partículas límite invisibles
        if (particle.tipo === 'límite') {
            const estilo = this.getStyle(particle.tipo);
            if (estilo.opacity === 0.0 || estilo.opacity === undefined) {
                return; // No renderizar
            }
        }
        
        const cube = this.createParticleMesh(particle, cellSize);
        if (cube) { // Verificar que no sea null
            const key = `${particle.celda_x}_${particle.celda_y}_${particle.celda_z}`;
            this.particleMeshes.set(key, cube);
            this.scene.add(cube);
        }
    });
}
```

**Notas:**
- Si opacity es 0.0, no crear el mesh para optimizar rendimiento
- Si opacity es > 0.0 pero < 1.0, renderizar como transparente
- Considerar agregar flag `isError` o `isBoundary` al estilo para identificar partículas límite

**Recursos útiles:**
- Ver `frontend/src/scene.js` para lógica de renderizado actual
- Ver `frontend/src/constants.js` para constantes

---

### Paso 6: Crear estructura de carpetas y plantilla para ejemplos de terrenos

**Descripción:**
Crear la carpeta `instructions/examples/terrenos/` y una plantilla base para los archivos de ejemplos de construcción de terrenos.

**Archivos a modificar/crear:**
- `instructions/examples/terrenos/README.md` - Documentación de la carpeta y plantilla
- `instructions/examples/terrenos/_template.md` - Plantilla para nuevos ejemplos

**Detalles de implementación:**
```markdown
# instructions/examples/terrenos/README.md

# Ejemplos de Construcción de Terrenos

Esta carpeta contiene ejemplos detallados de cómo construir diferentes tipos de terrenos, biomas, zonas subterráneas y características geológicas para el Juego de Dioses.

## Estructura de un Ejemplo

Cada ejemplo debe incluir:
- **Descripción**: Qué tipo de terreno es y sus características principales
- **Estructura de Capas**: Qué partículas en qué niveles z
- **Distribución Espacial**: Cómo se distribuyen las partículas en x, y
- **Propiedades de Partículas**: Densidad, temperatura, energía, etc.
- **Reglas de Generación**: Pasos detallados para crear el terreno

## Cómo Usar los Ejemplos

1. Leer el ejemplo completo antes de comenzar
2. Preparar la dimensión con los límites apropiados
3. Seguir los pasos de generación en orden
4. Ajustar según necesidades específicas

## Lista de Ejemplos

- `bioma-bosque.md` - Construcción de bosque
- `bioma-desierto.md` - Construcción de desierto
- `zona-subterranea-cueva.md` - Construcción de cueva
- `acuifero-napa-subterranea.md` - Construcción de acuífero/napa subterránea
- `estructura-geologica-capas.md` - Estructura geológica con capas
```

```markdown
# instructions/examples/terrenos/_template.md

# [Nombre del Terreno]

## Descripción

[Descripción breve del tipo de terreno, sus características principales y cuándo usarlo]

## Estructura de Capas

### Nivel Z = [nivel]
- **Tipo de partícula**: [tipo]
- **Distribución**: [cómo se distribuye]
- **Propiedades**: [densidad, temperatura, etc.]

### Nivel Z = [nivel]
...

## Distribución Espacial

### Área X: [rango], Y: [rango]
- **Partículas**: [tipos y cantidades]
- **Patrón**: [regular, aleatorio, etc.]

## Propiedades de Partículas

| Tipo | Densidad | Temperatura | Energía | Estado |
|------|----------|-------------|---------|--------|
| [tipo] | [valor] | [valor] | [valor] | [estado] |

## Reglas de Generación

### Paso 1: [Descripción]
1. [Instrucción detallada]
2. [Instrucción detallada]

### Paso 2: [Descripción]
...

## Variaciones

- **Variación 1**: [Descripción de variación]
- **Variación 2**: [Descripción de variación]

## Notas Adicionales

[Notas sobre consideraciones especiales, optimizaciones, etc.]
```

**Notas:**
- La plantilla debe ser clara y fácil de seguir
- Incluir ejemplos de valores reales en la plantilla
- El README debe explicar cómo usar los ejemplos

**Recursos útiles:**
- Ver estructura de otros documentos en `instructions/`

---

### Paso 7: Escribir ejemplo de bioma (bosque)

**Descripción:**
Crear un archivo detallado con ejemplo de construcción de un bioma de bosque, incluyendo estructura de capas, distribución espacial, propiedades y reglas de generación paso a paso.

**Archivos a modificar/crear:**
- `instructions/examples/terrenos/bioma-bosque.md` - Ejemplo completo de bosque

**Detalles de implementación:**
El archivo debe seguir la plantilla creada en el Paso 7 e incluir:
- Descripción del bioma bosque
- Estructura de capas: suelo (hierba en z=0), subsuelo (tierra en z=-1 a z=-3), roca base (piedra en z=-4)
- Distribución espacial: árboles distribuidos aleatoriamente, hierba cubriendo toda el área
- Propiedades: temperatura moderada, humedad alta
- Reglas de generación paso a paso para crear el bosque
- Variaciones: bosque denso vs bosque claro

**Notas:**
- Usar valores reales de partículas existentes (hierba, tierra, piedra, madera, hojas)
- Incluir suficientes detalles para que sea replicable
- Considerar diferentes tamaños de bosque

---

### Paso 8: Escribir ejemplo de zona subterránea (cueva)

**Descripción:**
Crear un archivo detallado con ejemplo de construcción de una cueva subterránea, incluyendo entrada, pasadizos, cámaras, y distribución de partículas.

**Archivos a modificar/crear:**
- `instructions/examples/terrenos/zona-subterranea-cueva.md` - Ejemplo completo de cueva

**Detalles de implementación:**
El archivo debe incluir:
- Descripción de la cueva y sus características
- Estructura: entrada (z=-1 a z=-2), pasadizos (z=-3 a z=-5), cámaras (z=-6)
- Distribución: roca alrededor, aire en el interior, posiblemente minerales
- Propiedades: temperatura estable, oscuridad
- Reglas de generación paso a paso
- Variaciones: cueva pequeña vs sistema de cavernas complejo

**Notas:**
- Considerar cómo la cueva interactúa con el terreno superior
- Incluir ejemplos de diferentes tamaños y complejidades
- Considerar agregar minerales o recursos en las cuevas

---

### Paso 9: Escribir ejemplo de acuífero/napa subterránea

**Descripción:**
Crear un archivo detallado con ejemplo de construcción de un acuífero o napa subterránea, incluyendo nivel freático, capas impermeables, y distribución de agua.

**Archivos a modificar/crear:**
- `instructions/examples/terrenos/acuifero-napa-subterranea.md` - Ejemplo completo de acuífero

**Detalles de implementación:**
El archivo debe incluir:
- Descripción del acuífero y cómo funciona
- Estructura: capa impermeable (roca en z=-10), nivel freático (agua en z=-7 a z=-9), suelo poroso (tierra en z=-6)
- Distribución: agua que se filtra, capas de roca impermeables
- Propiedades: temperatura del agua, flujo, presión
- Reglas de generación paso a paso
- Variaciones: acuífero superficial vs profundo, con manantiales vs sin manantiales

**Notas:**
- Considerar la física del agua subterránea (flujo, presión)
- Incluir ejemplos de cómo el agua puede emerger como manantiales
- Considerar interacción con terreno superior

---

### Paso 10: Agregar más ejemplos según necesidad (opcional)

**Descripción:**
Agregar ejemplos adicionales de otros biomas o características geológicas según necesidad y tiempo disponible.

**Archivos a modificar/crear:**
- `instructions/examples/terrenos/bioma-desierto.md` - Ejemplo de desierto (opcional)
- `instructions/examples/terrenos/estructura-geologica-capas.md` - Ejemplo de capas geológicas (opcional)
- Otros ejemplos según necesidad

**Notas:**
- Estos ejemplos son opcionales pero recomendados
- Se pueden agregar más ejemplos en el futuro
- Priorizar ejemplos más comunes o útiles

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-001_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- **Creación de partículas límite**: Crear muchas partículas límite puede afectar rendimiento. Usar `executemany` o insertar en batches para dimensiones grandes
- **Validación de límites**: Cachear límites de dimensión para evitar queries repetidas
- **Renderizado transparente**: No renderizar partículas límite con opacity 0.0 para optimizar rendimiento en frontend
- **Índices de base de datos**: Considerar índices en campos usados para validación de límites

### Seguridad
- **Validación de límites**: Validar siempre en el backend, nunca confiar en validación del frontend
- **Indestructibilidad**: Validar en múltiples capas (tipo de partícula y lógica de negocio)
- **Sanitización**: Usar queries parametrizadas para prevenir SQL injection

### Casos Edge
- **Dimensiones muy grandes**: Si una dimensión es muy grande, crear partículas límite en batches para evitar timeouts
- **Partículas límite faltantes**: Si no existen partículas límite, el sistema debe funcionar pero sin validación de límites
- **Múltiples dimensiones**: Cada dimensión debe tener sus propias partículas límite
- **Modificación de límites**: Si se modifica profundidad_maxima de una dimensión existente, considerar migración de partículas límite

### Compatibilidad
- **Dimensiones existentes**: Las dimensiones ya creadas no tendrán partículas límite automáticamente. Considerar script de migración opcional
- **Frontend antiguo**: El frontend debe manejar gracefully si recibe partículas límite sin estilos definidos
- **API versioning**: Los cambios en validación de límites deben ser compatibles con versiones anteriores de la API

## Patrones de Código a Usar

- **Backend (FastAPI)**: 
  - Validación con Pydantic models
  - Queries parametrizadas con asyncpg
  - Manejo de errores con HTTPException
  - Funciones helper reutilizables para validación

- **Base de Datos**: 
  - INSERT en batch con `executemany` para mejor rendimiento
  - Índices en campos usados para validación
  - JSONB para estilos de partículas (ya implementado en JDG-002)

- **Frontend (Three.js)**: 
  - Filtrar partículas invisibles antes de crear meshes
  - Usar transparencia apropiada para partículas límite
  - No renderizar partículas con opacity 0.0

- **Documentación**: 
  - Ejemplos claros y detallados
  - Pasos numerados y verificables
  - Incluir valores reales y casos de uso

## Dependencias

### Nuevas Dependencias (si aplica)
No se requieren nuevas dependencias. Se usa lo existente:
- asyncpg (ya en uso)
- Pydantic (ya incluido en FastAPI)
- Three.js (ya en uso)

### Variables de Entorno (si aplica)
No se requieren nuevas variables de entorno.

## Archivos Principales Involucrados

1. `database/init/02-seed-data.sql` - Agregar tipo `límite`
2. `backend/src/database/seed_demo.py` o `terrain_builder.py` - Crear función para partículas límite
3. `backend/src/api/routes/particles.py` - Validación de límites e indestructibilidad
4. `frontend/src/scene.js` - Renderizado transparente de partículas límite
5. `instructions/examples/terrenos/` - Carpeta con ejemplos de terrenos
6. `instructions/examples/terrenos/README.md` - Documentación de ejemplos
7. `instructions/examples/terrenos/_template.md` - Plantilla para ejemplos
8. `instructions/examples/terrenos/bioma-bosque.md` - Ejemplo de bosque
9. `instructions/examples/terrenos/zona-subterranea-cueva.md` - Ejemplo de cueva
10. `instructions/examples/terrenos/acuifero-napa-subterranea.md` - Ejemplo de acuífero

## Verificación Manual

### Escenarios de Verificación

1. **Creación automática de partículas límite**
   - Crear nueva dimensión
   - Verificar que se crean partículas límite en z = profundidad_maxima
   - Verificar que cubren todo el área horizontal
   - Verificar cantidad correcta de partículas

2. **Indestructibilidad**
   - Intentar extraer partícula límite
   - Verificar que se retorna error 403
   - Verificar que la partícula no se modifica

3. **Validación de límites**
   - Intentar crear partícula dentro de límites (debe funcionar)
   - Intentar crear partícula fuera de límites en x (debe fallar)
   - Intentar crear partícula fuera de límites en y (debe fallar)
   - Intentar crear partícula fuera de límites en z (debe fallar)

4. **Renderizado transparente**
   - Visualizar dimensión en frontend
   - Verificar que partículas límite no se renderizan (opacity 0.0)
   - Verificar que no interfieren visualmente

5. **Uso de ejemplos**
   - Leer ejemplo de bosque
   - Seguir pasos de generación
   - Verificar que se crea el terreno correctamente

## Deployment

### Orden de Deployment
1. Base de datos: Ejecutar script de seed para agregar tipo `límite` (se ejecuta automáticamente al inicializar)
2. Backend: Deploy con cambios en validación y creación de límites
3. Frontend: Deploy con cambios en renderizado transparente
4. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar que tipo `límite` existe en base de datos
- [ ] Crear nueva dimensión y verificar que se crean partículas límite automáticamente
- [ ] Verificar que partículas límite no pueden ser extraídas
- [ ] Verificar validación de límites en endpoints de creación
- [ ] Verificar renderizado transparente en frontend
- [ ] Verificar que ejemplos de terrenos están disponibles
- [ ] Verificar logs de Docker no muestran errores

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. La FASE 1 (reglas de construcción) es prioritaria y debe completarse antes de la FASE 2 (ejemplos).

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

