# JDG-002 - Mover estilos de part√≠culas a Base de Datos

## Descripci√≥n de la Tarea

Migrar los estilos visuales (colores, materiales, propiedades visuales) de las part√≠culas desde c√≥digo hardcoded en el frontend hacia la base de datos, permitiendo que la IA pueda crear y modificar estilos din√°micamente.

**Comportamiento actual:**
- Los colores est√°n hardcodeados en `frontend/src/scene.js` en un objeto `colorMap`
- Las propiedades de material (metalness, roughness) est√°n fijas en el c√≥digo
- El campo `color_base` en `tipos_particulas` existe pero no se utiliza
- La IA no puede modificar estilos sin cambios en c√≥digo frontend

**Comportamiento esperado:**
- Los estilos est√°n almacenados en la base de datos en un campo JSONB `estilos` en `tipos_particulas`
- Los estilos se obtienen en una query separada (`/particle-types`) para evitar duplicaci√≥n
- Las part√≠culas se obtienen sin estilos (solo IDs y nombres de tipos)
- El frontend carga tipos y part√≠culas en paralelo con `Promise.all()`
- El frontend cachea estilos antes de renderizar part√≠culas
- La IA puede crear/modificar estilos din√°micamente
- El rendimiento es mejor que el sistema hardcoded (50% menos datos transferidos)

## Criterios de Aceptaci√≥n

1. ‚ùå El campo `estilos` JSONB existe en la tabla `tipos_particulas` con estructura v√°lida
2. ‚ùå Los colores hardcoded actuales est√°n migrados a la base de datos
3. ‚ùå Existe endpoint `/dimensions/{id}/particle-types` que retorna tipos √∫nicos con estilos
4. ‚ùå Las queries de part√≠culas NO incluyen estilos (solo IDs y nombres de tipos)
5. ‚ùå El backend valida estilos con Pydantic antes de guardarlos
6. ‚ùå El frontend carga tipos y part√≠culas en paralelo con `Promise.all()`
7. ‚ùå El frontend cachea estilos antes de renderizar part√≠culas
8. ‚ùå El frontend tiene fallback a valores por defecto si falta estilo en BD
9. ‚ùå El rendimiento es mejor que el sistema hardcoded (50% menos datos transferidos)
10. ‚ùå La IA puede crear nuevos tipos de part√≠culas con estilos personalizados
11. ‚ùå La IA puede modificar estilos existentes sin cambios en c√≥digo frontend
12. ‚ùå Se documenta la estructura JSONB de estilos y c√≥mo agregar nuevos campos

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnolog√≠as Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Frontend: HTML5, JavaScript ES6+, Three.js
- Base de datos: PostgreSQL 16 (JSONB para estilos flexibles)
- Validaci√≥n: Pydantic (validaci√≥n de estilos)
- Queries: asyncpg con JOIN para optimizaci√≥n

## Pasos de Implementaci√≥n

### Paso 1: Agregar campo `estilos` JSONB a la tabla `tipos_particulas`

**Descripci√≥n:**
Agregar el campo `estilos` de tipo JSONB a la tabla `tipos_particulas` con valor por defecto vac√≠o. Tambi√©n crear un √≠ndice GIN para b√∫squedas eficientes en el campo JSONB.

**Archivos a modificar/crear:**
- `database/init/01-init-schema.sql` - Agregar campo y √≠ndice
- Crear script de migraci√≥n: `database/migrations/001-add-estilos-field.sql` (si existe carpeta migrations)

**Detalles de implementaci√≥n:**
```sql
-- Agregar campo estilos JSONB a tipos_particulas
ALTER TABLE juego_dioses.tipos_particulas 
ADD COLUMN IF NOT EXISTS estilos JSONB DEFAULT '{}'::jsonb;

-- Crear √≠ndice GIN para b√∫squedas r√°pidas en estilos
CREATE INDEX IF NOT EXISTS idx_tipos_particulas_estilos 
ON juego_dioses.tipos_particulas USING GIN (estilos);

-- Comentario para documentar el campo
COMMENT ON COLUMN juego_dioses.tipos_particulas.estilos IS 
'Estilos visuales de la part√≠cula en formato JSONB. Estructura: {color_hex, color_rgb, material: {metalness, roughness, emissive}, visual: {modelo, escala}}';
```

**Notas:**
- El campo debe ser nullable o tener default '{}' para compatibilidad con datos existentes
- El √≠ndice GIN permite b√∫squedas eficientes en campos JSONB
- No afecta datos existentes si se usa DEFAULT '{}'

**Recursos √∫tiles:**
- [PostgreSQL JSONB Documentation](https://www.postgresql.org/docs/current/datatype-json.html)
- [GIN Indexes for JSONB](https://www.postgresql.org/docs/current/gin-builtin-opclasses.html)

---

### Paso 2: Crear modelo Pydantic para validaci√≥n de estilos y funci√≥n helper

**Descripci√≥n:**
Crear modelos Pydantic para validar la estructura de estilos antes de guardarlos en la base de datos. Tambi√©n crear una funci√≥n helper reutilizable para parsear campos JSONB de asyncpg. Esto previene valores inv√°lidos y asegura consistencia.

**Archivos a modificar/crear:**
- `backend/src/models/schemas.py` - Agregar modelos de estilos y funci√≥n helper

**Detalles de implementaci√≥n:**
```python
from pydantic import BaseModel, Field, validator
from typing import Optional, List
import json

# Funci√≥n helper para parsear campos JSONB de asyncpg (reutilizable)
def parse_jsonb_field(value):
    """
    Helper para parsear campos JSONB de asyncpg.
    
    asyncpg puede devolver JSONB como dict o como string seg√∫n la versi√≥n/configuraci√≥n.
    Esta funci√≥n maneja ambos casos de forma segura.
    """
    if isinstance(value, str):
        try:
            return json.loads(value) if value else {}
        except json.JSONDecodeError:
            return {}
    elif isinstance(value, dict):
        return value
    elif value is None:
        return {}
    return {}

class MaterialProperties(BaseModel):
    """Propiedades de material para Three.js"""
    metalness: float = Field(default=0.1, ge=0.0, le=1.0, description="Metalness del material (0-1)")
    roughness: float = Field(default=0.8, ge=0.0, le=1.0, description="Roughness del material (0-1)")
    emissive: bool = Field(default=False, description="Si el material es emisivo")

class VisualProperties(BaseModel):
    """Propiedades visuales de la part√≠cula"""
    modelo: str = Field(default="cube", description="Tipo de modelo 3D (cube, sphere, custom)")
    escala: float = Field(default=1.0, ge=0.1, le=10.0, description="Escala del modelo")

class EstilosParticula(BaseModel):
    """Modelo completo de estilos para una part√≠cula"""
    color_hex: Optional[int] = Field(None, ge=0, le=0xFFFFFF, description="Color en hexadecimal (0-0xFFFFFF)")
    color_rgb: Optional[List[int]] = Field(None, min_items=3, max_items=3, description="Color en RGB [R, G, B]")
    material: Optional[MaterialProperties] = Field(default_factory=MaterialProperties)
    visual: Optional[VisualProperties] = Field(default_factory=VisualProperties)
    
    @validator('color_rgb')
    def validate_rgb_values(cls, v):
        """Validar que valores RGB est√©n en rango 0-255"""
        if v:
            for val in v:
                if not (0 <= val <= 255):
                    raise ValueError("Valores RGB deben estar entre 0 y 255")
        return v
    
    class Config:
        schema_extra = {
            "example": {
                "color_hex": 9474192,
                "color_rgb": [148, 116, 85],
                "material": {
                    "metalness": 0.1,
                    "roughness": 0.8,
                    "emissive": False
                },
                "visual": {
                    "modelo": "cube",
                    "escala": 1.0
                }
            }
        }
```

**Notas:**
- La funci√≥n `parse_jsonb_field` es reutilizable y se usar√° en m√∫ltiples lugares
- Los valores por defecto permiten que estilos parciales sean v√°lidos
- Validadores aseguran que valores est√©n en rangos correctos
- El modelo es extensible para agregar m√°s propiedades en el futuro
- Los ejemplos aparecer√°n autom√°ticamente en Swagger/OpenAPI (`/docs`)

---

### Paso 3: Migrar colores hardcoded a base de datos

**Descripci√≥n:**
Crear un script SQL que migre los colores hardcoded del frontend a la base de datos, convirtiendo los valores hexadecimales a la estructura JSONB de estilos.

**Archivos a modificar/crear:**
- `database/init/02-seed-data.sql` - Agregar migraci√≥n de estilos a tipos existentes
- O crear: `database/migrations/002-migrate-hardcoded-colors.sql`

**Detalles de implementaci√≥n:**
```sql
-- Funci√≥n helper para convertir hex a RGB
CREATE OR REPLACE FUNCTION hex_to_rgb(hex_value INTEGER) 
RETURNS INTEGER[] AS $$
BEGIN
    RETURN ARRAY[
        (hex_value >> 16) & 255,
        (hex_value >> 8) & 255,
        hex_value & 255
    ];
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Migrar colores hardcoded a estilos JSONB
UPDATE juego_dioses.tipos_particulas 
SET estilos = jsonb_build_object(
    'color_hex', CASE nombre
        WHEN 'hierba' THEN 9474192  -- 0x90EE90
        WHEN 'madera' THEN 9145235  -- 0x8B4513
        WHEN 'hojas' THEN 2263842   -- 0x228B22
        WHEN 'tierra' THEN 9147221  -- 0x8B7355
        WHEN 'piedra' THEN 8421504  -- 0x808080
        WHEN 'agua' THEN 4279617    -- 0x4169E1
        WHEN 'aire' THEN 16777215   -- 0xFFFFFF
        ELSE NULL
    END,
    'color_rgb', CASE nombre
        WHEN 'hierba' THEN hex_to_rgb(9474192)
        WHEN 'madera' THEN hex_to_rgb(9145235)
        WHEN 'hojas' THEN hex_to_rgb(2263842)
        WHEN 'tierra' THEN hex_to_rgb(9147221)
        WHEN 'piedra' THEN hex_to_rgb(8421504)
        WHEN 'agua' THEN hex_to_rgb(4279617)
        WHEN 'aire' THEN hex_to_rgb(16777215)
        ELSE NULL
    END,
    'material', jsonb_build_object(
        'metalness', 0.1,
        'roughness', 0.8,
        'emissive', false
    ),
    'visual', jsonb_build_object(
        'modelo', 'cube',
        'escala', 1.0
    )
)
WHERE nombre IN ('hierba', 'madera', 'hojas', 'tierra', 'piedra', 'agua', 'aire')
  AND (estilos IS NULL OR estilos = '{}'::jsonb);

-- Limpiar funci√≥n helper si no se necesita despu√©s
-- DROP FUNCTION IF EXISTS hex_to_rgb(INTEGER);
```

**Notas:**
- Solo actualiza tipos que existen y que no tienen estilos ya definidos
- Mantiene compatibilidad con tipos que ya tienen estilos
- Los valores de material y visual son los mismos para todos (pueden personalizarse despu√©s)

---

### Paso 4: Crear endpoint separado para tipos de part√≠culas y mantener query de part√≠culas sin estilos

**Descripci√≥n:**
Crear un nuevo endpoint para obtener tipos de part√≠culas √∫nicos en un viewport con sus estilos. Mantener la query de part√≠culas SIN incluir estilos (solo IDs y nombres). Esto reduce datos transferidos en ~50% y permite cache eficiente de tipos.

**Archivos a modificar/crear:**
- `backend/src/api/routes/particles.py` - Crear nuevo endpoint `get_particle_types_in_viewport`
- `backend/src/api/routes/particles.py` - Mantener query de part√≠culas SIN estilos (solo nombre)
- `backend/src/api/routes/agrupaciones.py` - Mantener query sin estilos

**Detalles de implementaci√≥n:**

**1. Nuevo endpoint para tipos:**
```python
import logging
from src.models.schemas import parse_jsonb_field

logger = logging.getLogger(__name__)

@router.get("/{dimension_id}/particle-types")
async def get_particle_types_in_viewport(
    dimension_id: UUID,
    x_min: int = Query(..., ge=0, description="Coordenada X m√≠nima"),
    x_max: int = Query(..., ge=0, description="Coordenada X m√°xima"),
    y_min: int = Query(..., ge=0, description="Coordenada Y m√≠nima"),
    y_max: int = Query(..., ge=0, description="Coordenada Y m√°xima"),
    z_min: int = Query(-10, description="Coordenada Z m√≠nima"),
    z_max: int = Query(10, description="Coordenada Z m√°xima")
):
    """
    Obtener tipos de part√≠culas √∫nicos en un viewport con sus estilos.
    
    Esta query se puede cachear en backend por 5-10 minutos ya que los tipos
    cambian menos frecuentemente que las part√≠culas.
    
    Ventajas:
    - Solo retorna tipos √∫nicos (sin duplicaci√≥n)
    - 50% menos datos transferidos vs incluir estilos en cada part√≠cula
    - Cache eficiente en backend
    """
    # Validar viewport
    viewport = ParticleViewportQuery(
        x_min=x_min, x_max=x_max,
        y_min=y_min, y_max=y_max,
        z_min=z_min, z_max=z_max
    )
    viewport.validate_ranges()
    
    async with get_connection() as conn:
        # Verificar que la dimensi√≥n existe
        dim_exists = await conn.fetchval(
            "SELECT EXISTS(SELECT 1 FROM juego_dioses.dimensiones WHERE id = $1)",
            dimension_id
        )
        if not dim_exists:
            raise HTTPException(status_code=404, detail="Dimensi√≥n no encontrada")
        
        # Obtener IDs de tipos √∫nicos en viewport
        tipo_ids_rows = await conn.fetch("""
            SELECT DISTINCT p.tipo_particula_id
            FROM juego_dioses.particulas p
            WHERE p.dimension_id = $1
              AND p.celda_x BETWEEN $2 AND $3
              AND p.celda_y BETWEEN $4 AND $5
              AND p.celda_z BETWEEN $6 AND $7
              AND p.extraida = false
        """, dimension_id, x_min, x_max, y_min, y_max, z_min, z_max)
        
        tipo_ids_list = [row['tipo_particula_id'] for row in tipo_ids_rows]
        
        if not tipo_ids_list:
            logger.debug(f"No particle types found in viewport for dimension {dimension_id}")
            return {"types": []}
        
        # Obtener tipos con estilos
        tipos = await conn.fetch("""
            SELECT 
                id,
                nombre,
                estilos
            FROM juego_dioses.tipos_particulas
            WHERE id = ANY($1::uuid[])
        """, tipo_ids_list)
        
        # Parsear estilos usando helper
        result = []
        for row in tipos:
            estilos = parse_jsonb_field(row['estilos'])
            result.append({
                "id": str(row['id']),
                "nombre": row['nombre'],
                "estilos": estilos if estilos else None
            })
        
        logger.debug(f"Found {len(result)} unique particle types in viewport")
        return {"types": result}
```

**2. Query de part√≠culas SIN estilos (m√°s eficiente):**
```python
# En particles.py - Query SIN estilos (solo nombre, no estilos)
rows = await conn.fetch("""
    SELECT 
        p.id,
        p.dimension_id,
        p.celda_x,
        p.celda_y,
        p.celda_z,
        p.tipo_particula_id,  -- ‚Üê Solo ID
        p.estado_materia_id,
        p.cantidad,
        p.temperatura,
        p.energia,
        p.extraida,
        p.agrupacion_id,
        p.es_nucleo,
        p.propiedades,
        p.creado_por,
        p.creado_en,
        p.modificado_en,
        tp.nombre as tipo_nombre,  -- ‚Üê Solo nombre, NO estilos
        em.nombre as estado_nombre
    FROM juego_dioses.particulas p
    JOIN juego_dioses.tipos_particulas tp ON p.tipo_particula_id = tp.id
    JOIN juego_dioses.estados_materia em ON p.estado_materia_id = em.id
    WHERE p.dimension_id = $1
      AND p.celda_x BETWEEN $2 AND $3
      AND p.celda_y BETWEEN $4 AND $5
      AND p.celda_z BETWEEN $6 AND $7
      AND p.extraida = false
    ORDER BY p.celda_z, p.celda_y, p.celda_x
""", dimension_id, x_min, x_max, y_min, y_max, z_min, z_max)

# Logging para debugging
if not rows:
    logger.warning(f"No particles found for dimension {dimension_id} in viewport")
else:
    logger.debug(f"Found {len(rows)} particles in viewport")
```

**Notas:**
- ‚úÖ **50% menos datos transferidos** (sin duplicar estilos en cada part√≠cula)
- ‚úÖ **Query de tipos cacheable** en backend (5-10 minutos)
- ‚úÖ **Menos procesamiento JSONB** (solo tipos √∫nicos vs todas las part√≠culas)
- ‚úÖ **Mejor escalabilidad** para MMO con muchos tipos repetidos
- ‚úÖ La query de part√≠culas es m√°s r√°pida (menos datos)
- Aplicar mismo cambio en queries de agrupaciones (sin estilos)

---

### Paso 5: Crear schema para tipos de part√≠culas y mantener ParticleResponse sin estilos

**Descripci√≥n:**
Crear un nuevo schema `ParticleTypeResponse` para el endpoint de tipos. Mantener `ParticleResponse` SIN campo `tipo_estilos` (ya que los estilos vienen en query separada). Crear m√©todo est√°tico `from_row` para `ParticleResponse` sin procesar estilos.

**Archivos a modificar/crear:**
- `backend/src/models/schemas.py` - Crear `ParticleTypeResponse` y mantener `ParticleResponse` sin estilos

**Detalles de implementaci√≥n:**
```python
# Nuevo schema para respuesta de tipos de part√≠culas
class ParticleTypeResponse(BaseModel):
    """Schema de respuesta para tipo de part√≠cula con estilos"""
    id: str  # UUID como string
    nombre: str
    estilos: Optional[dict] = Field(
        None,
        description="Estilos visuales del tipo (color, material, visual)"
    )

# ParticleResponse SIN campo tipo_estilos (viene en query separada)
class ParticleResponse(ParticleBase):
    """Schema de respuesta para part√≠cula"""
    id: UUID
    dimension_id: UUID
    tipo_particula_id: UUID
    estado_materia_id: UUID
    # NO incluir tipo_estilos aqu√≠ - viene en query separada
    tipo_nombre: str = Field(..., description="Nombre del tipo de part√≠cula (viene del JOIN)")
    estado_nombre: str = Field(..., description="Nombre del estado de materia (viene del JOIN)")
    creado_en: datetime
    modificado_en: datetime
    creado_por: Optional[UUID] = None

    @classmethod
    def from_row(cls, row) -> 'ParticleResponse':
        """
        Crear ParticleResponse desde fila de BD.
        
        Centraliza la l√≥gica de conversi√≥n y parsing de campos JSONB.
        NO incluye estilos (vienen en query separada).
        """
        # Parsear solo propiedades (no estilos)
        propiedades = parse_jsonb_field(row.get('propiedades'))
        
        return cls(
            id=row['id'],
            dimension_id=row['dimension_id'],
            celda_x=row['celda_x'],
            celda_y=row['celda_y'],
            celda_z=row['celda_z'],
            tipo=row['tipo_nombre'],  # Mapeo: tipo_nombre -> tipo
            estado=row['estado_nombre'],  # Mapeo: estado_nombre -> estado
            cantidad=float(row['cantidad']),
            temperatura=float(row['temperatura']),
            energia=float(row['energia']),
            extraida=row['extraida'],
            agrupacion_id=row.get('agrupacion_id'),
            es_nucleo=row['es_nucleo'],
            propiedades=propiedades,
            tipo_particula_id=row['tipo_particula_id'],
            estado_materia_id=row['estado_materia_id'],
            tipo_nombre=row['tipo_nombre'],
            estado_nombre=row['estado_nombre'],
            creado_en=row['creado_en'],
            modificado_en=row['modificado_en'],
            creado_por=row.get('creado_por')
        )

    class Config:
        from_attributes = True
        # NO usar extra = "allow" - ser expl√≠cito con todos los campos
```

**Notas:**
- `ParticleResponse` NO incluye `tipo_estilos` (viene en query separada)
- Nuevo schema `ParticleTypeResponse` para el endpoint de tipos
- El m√©todo `from_row` solo procesa propiedades, no estilos
- Los estilos se obtienen y cachean en frontend desde query separada

---

### Paso 6: Actualizar l√≥gica de conversi√≥n de rows a ParticleResponse usando m√©todo est√°tico

**Descripci√≥n:**
Actualizar las queries existentes para usar el m√©todo est√°tico `ParticleResponse.from_row()` creado en el Paso 5. Esto centraliza la l√≥gica de conversi√≥n y evita duplicaci√≥n entre `particles.py` y `agrupaciones.py`.

**Archivos a modificar/crear:**
- `backend/src/api/routes/particles.py` - Actualizar conversi√≥n usando m√©todo est√°tico
- `backend/src/api/routes/agrupaciones.py` - Actualizar conversi√≥n usando m√©todo est√°tico

**Detalles de implementaci√≥n:**
```python
# En particles.py - Reemplazar l√≥gica de conversi√≥n existente
from src.models.schemas import ParticleResponse

# ANTES (eliminar):
# particles = []
# for row in rows:
#     propiedades = row["propiedades"]
#     if isinstance(propiedades, str):
#         # ... parsing manual ...
#     particles.append(ParticleResponse(...))

# DESPU√âS (usar m√©todo est√°tico):
particles = [ParticleResponse.from_row(row) for row in rows]

# En agrupaciones.py - Aplicar mismo cambio
# ANTES:
# particulas.append(ParticleResponse(...))

# DESPU√âS:
particulas = [ParticleResponse.from_row(row) for row in particulas_rows]
```

**Notas:**
- El m√©todo `from_row` ya maneja todos los casos (None, '{}', dict, string)
- C√≥digo m√°s limpio y mantenible
- Consistencia entre diferentes endpoints
- Si hay errores, se centralizan en un solo lugar

---

### Paso 7: Implementar carga paralela de tipos y part√≠culas, y cache de estilos en frontend

**Descripci√≥n:**
Modificar el frontend para cargar tipos y part√≠culas en paralelo usando `Promise.all()`. Cachear tipos antes de renderizar part√≠culas. Implementar m√©todos para parsear y cachear estilos.

**Archivos a modificar/crear:**
- `frontend/src/api.js` - Agregar m√©todo `getParticleTypes()`
- `frontend/src/main.js` - Modificar `loadDemo()` para cargar tipos y part√≠culas en paralelo
- `frontend/src/scene.js` - Agregar m√©todos `cacheStyle()` y `parseStyle()`, modificar `renderParticles()`

**Detalles de implementaci√≥n:**

**1. Agregar m√©todo en `api.js`:**
```javascript
// En api.js - Agregar m√©todo nuevo
async getParticleTypes(dimensionId, viewport) {
    const { x_min, x_max, y_min, y_max, z_min, z_max } = viewport;
    const url = `${this.baseUrl}/dimensions/${dimensionId}/particle-types?` +
        `x_min=${x_min}&x_max=${x_max}&y_min=${y_min}&y_max=${y_max}&z_min=${z_min}&z_max=${z_max}`;
    
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Error al obtener tipos: ${response.statusText}`);
    }
    return await response.json();
}
```

**2. Modificar `main.js` para cargar en paralelo:**
```javascript
// En main.js - Modificar loadDemo() para cargar tipos y part√≠culas en paralelo
async function loadDemo() {
    try {
        statusEl.textContent = 'Cargando...';
        
        // 1. Obtener dimensiones
        const dimensions = await api.getDimensions();
        const demoDimension = dimensions.find(d => d.nombre === 'Demo - Terreno con Arboles');
        
        if (!demoDimension) {
            throw new Error('No se encontr√≥ la dimensi√≥n demo');
        }
        
        currentDimension = demoDimension;
        dimensionInfoEl.textContent = `Dimensi√≥n: ${demoDimension.nombre}`;
        
        // 2. Definir viewport
        const viewport = {
            x_min: 0, x_max: 20,
            y_min: 0, y_max: 20,
            z_min: -2, z_max: 5
        };
        
        // 3. Cargar part√≠culas Y tipos en paralelo ‚Üê NUEVO
        const [particlesData, typesData] = await Promise.all([
            api.getParticles(demoDimension.id, viewport),
            api.getParticleTypes(demoDimension.id, viewport)  // ‚Üê NUEVO
        ]);
        
        currentParticles = particlesData.particles;
        particlesCountEl.textContent = `Part√≠culas: ${particlesData.total}`;
        
        // 4. Cachear tipos antes de renderizar ‚Üê NUEVO
        typesData.types.forEach(tipo => {
            if (tipo.estilos) {
                scene.cacheStyle(tipo.nombre, tipo.estilos);
            }
        });
        
        // 5. Renderizar part√≠culas (tipos ya cacheados)
        scene.renderParticles(currentParticles, demoDimension.tamano_celda);
        
        // 6. Centrar c√°mara y animar
        const centerX = (viewport.x_max + viewport.x_min) / 2 * demoDimension.tamano_celda;
        const centerY = (viewport.y_max + viewport.y_min) / 2 * demoDimension.tamano_celda;
        const centerZ = (viewport.z_max + viewport.z_min) / 2 * demoDimension.tamano_celda;
        scene.centerCamera(centerX, centerY, centerZ);
        
        loadingEl.style.display = 'none';
        statusEl.textContent = 'Cargado correctamente';
        statusEl.className = 'success';
        
        scene.animate();
        
    } catch (error) {
        console.error('Error cargando demo:', error);
        loadingEl.textContent = `Error: ${error.message}`;
        loadingEl.className = 'error';
        statusEl.textContent = `Error: ${error.message}`;
        statusEl.className = 'error';
    }
}
```

**3. Modificar `scene.js` con m√©todos nuevos:**
```javascript
export class Scene3D {
    constructor(container) {
        this.container = container;
        this.scene = new THREE.Scene();
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.particleMeshes = new Map();
        /**
         * Cache de estilos por tipo de part√≠cula
         * 
         * Se precarga antes de renderizar part√≠culas desde query separada.
         * 
         * TODO: Implementar invalidaci√≥n cuando:
         * - Se recibe mensaje WebSocket de tipo actualizado
         * - Se detecta cambio en tipos de part√≠culas nuevas
         * - Polling peri√≥dico (cada 30s) para verificar cambios
         */
        this.styleCache = new Map();
        this.init();
    }

    /**
     * Cachear estilo de tipo de part√≠cula (llamado antes de renderizar)
     */
    cacheStyle(tipoNombre, tipoEstilos) {
        const estilo = this.parseStyle(tipoNombre, tipoEstilos);
        this.styleCache.set(tipoNombre, estilo);
    }

    /**
     * Parsear estilos desde BD a formato para Three.js
     */
    parseStyle(tipoNombre, tipoEstilos) {
        let estilo = {
            color: 0xFFFFFF,
            metalness: 0.1,
            roughness: 0.8
        };
        
        if (tipoEstilos) {
            if (tipoEstilos.color_hex !== undefined && tipoEstilos.color_hex !== null) {
                estilo.color = tipoEstilos.color_hex;
            } else {
                estilo.color = this.getDefaultColor(tipoNombre);
            }
            
            if (tipoEstilos.material) {
                if (tipoEstilos.material.metalness !== undefined) {
                    estilo.metalness = tipoEstilos.material.metalness;
                }
                if (tipoEstilos.material.roughness !== undefined) {
                    estilo.roughness = tipoEstilos.material.roughness;
                }
            }
        } else {
            estilo.color = this.getDefaultColor(tipoNombre);
        }
        
        return estilo;
    }

    /**
     * Obtener estilo desde cache (ya precargado)
     */
    getStyle(tipoNombre) {
        // Estilo ya est√° en cache (precargado antes de renderizar)
        return this.styleCache.get(tipoNombre) || {
            color: this.getDefaultColor(tipoNombre),
            metalness: 0.1,
            roughness: 0.8
        };
    }
    
    /**
     * Obtener color por defecto (fallback para compatibilidad)
     */
    getDefaultColor(tipoNombre) {
        const colorMap = {
            'hierba': 0x90EE90,
            'madera': 0x8B4513,
            'hojas': 0x228B22,
            'tierra': 0x8B7355,
            'piedra': 0x808080,
            'agua': 0x4169E1,
            'aire': 0xFFFFFF
        };
        return colorMap[tipoNombre] || 0xFFFFFF;
    }

    /**
     * Renderizar part√≠culas (tipos ya cacheados)
     */
    renderParticles(particles, cellSize = 0.25) {
        this.clearParticles();

        particles.forEach(particle => {
            // Obtener estilo desde cache (ya precargado)
            const estilo = this.getStyle(particle.tipo);
            
            // Crear geometr√≠a y material
            const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
            const material = new THREE.MeshStandardMaterial({ 
                color: estilo.color,
                metalness: estilo.metalness,
                roughness: estilo.roughness
            });
            
            const cube = new THREE.Mesh(geometry, material);
            
            // Posicionar cubo
            cube.position.set(
                particle.celda_x * cellSize + cellSize / 2,
                particle.celda_z * cellSize + cellSize / 2,
                particle.celda_y * cellSize + cellSize / 2
            );
            
            // Guardar referencia
            const key = `${particle.celda_x}_${particle.celda_y}_${particle.celda_z}`;
            this.particleMeshes.set(key, cube);
            
            this.scene.add(cube);
        });
    }
}
```

**Notas:**
- ‚úÖ **Carga paralela** de tipos y part√≠culas con `Promise.all()` (m√°s r√°pido)
- ‚úÖ **Tipos se cachean antes** de renderizar (no hay parsing durante renderizado)
- ‚úÖ **Renderizado m√°s r√°pido** (solo lookup en cache, O(1))
- ‚úÖ **50% menos datos** transferidos vs incluir estilos en cada part√≠cula
- ‚úÖ Fallback a colores hardcoded mantiene compatibilidad
- ‚úÖ El cache persiste durante la sesi√≥n del navegador

---

### Paso 8: Limpiar c√≥digo hardcoded del frontend (opcional en esta fase)

**Descripci√≥n:**
Remover el objeto `colorMap` hardcoded del frontend una vez que se confirme que los estilos de BD funcionan correctamente. Mantener el m√©todo `getDefaultColor` como fallback de seguridad.

**Archivos a modificar/crear:**
- `frontend/src/scene.js` - Remover colorMap hardcoded (mantener solo en fallback)

**Detalles de implementaci√≥n:**
```javascript
// ANTES (eliminar):
const colorMap = {
    'hierba': 0x90EE90,
    'madera': 0x8B4513,
    // ... etc
};

// DESPU√âS (solo en m√©todo getDefaultColor como fallback):
getDefaultColor(tipoNombre) {
    const colorMap = {
        'hierba': 0x90EE90,
        'madera': 0x8B4513,
        'hojas': 0x228B22,
        'tierra': 0x8B7355,
        'piedra': 0x808080,
        'agua': 0x4169E1,
        'aire': 0xFFFFFF
    };
    return colorMap[tipoNombre] || 0xFFFFFF;
}
```

**Notas:**
- Hacer esto solo despu√©s de verificar que todo funciona
- Mantener fallback para casos edge o datos corruptos
- Documentar que es solo para emergencias

---

### Paso 9: Verificar y crear endpoints para crear/modificar tipos de part√≠culas

**Descripci√≥n:**
Verificar si existen endpoints para crear/modificar tipos de part√≠culas. Si no existen, crearlos con validaci√≥n Pydantic de estilos. Si existen, agregar validaci√≥n de estilos a los endpoints existentes.

**Archivos a verificar primero:**
```bash
# Buscar endpoints existentes
grep -r "tipos_particulas" backend/src/api/routes/
grep -r "TipoParticula" backend/src/api/routes/
```

**Archivos a modificar/crear:**
- `backend/src/models/schemas.py` - Agregar schema para crear/modificar tipos con estilos
- `backend/src/api/routes/tipos_particulas.py` - Crear nuevo router si no existe, o modificar existente

**Detalles de implementaci√≥n:**

**1. Agregar schemas en `schemas.py`:**
```python
# Agregar schema para crear/modificar tipos de part√≠culas con estilos
class TipoParticulaCreate(BaseModel):
    """Schema para crear tipo de part√≠cula con estilos"""
    nombre: str = Field(..., max_length=100)
    categoria: str = Field(..., max_length=50)
    densidad: float = Field(default=1.0, ge=0.0)
    color_base: Optional[str] = Field(None, max_length=50)
    descripcion: Optional[str] = None
    estilos: Optional[EstilosParticula] = None

class TipoParticulaUpdate(BaseModel):
    """Schema para actualizar tipo de part√≠cula"""
    nombre: Optional[str] = Field(None, max_length=100)
    categoria: Optional[str] = Field(None, max_length=50)
    densidad: Optional[float] = Field(None, ge=0.0)
    color_base: Optional[str] = Field(None, max_length=50)
    descripcion: Optional[str] = None
    estilos: Optional[EstilosParticula] = None
```

**2. Crear o modificar router en `tipos_particulas.py`:**
```python
from fastapi import APIRouter, HTTPException
from uuid import UUID
from src.database.connection import get_connection
from src.models.schemas import TipoParticulaCreate, TipoParticulaUpdate, TipoParticulaResponse
import json

router = APIRouter(prefix="/tipos-particulas", tags=["tipos-particulas"])

@router.post("", response_model=TipoParticulaResponse)
async def create_tipo_particula(tipo: TipoParticulaCreate):
    """Crear nuevo tipo de part√≠cula con validaci√≥n de estilos"""
    async with get_connection() as conn:
        # Validar estilos usando Pydantic (ya validado autom√°ticamente)
        estilos_json = None
        if tipo.estilos:
            estilos_json = json.dumps(tipo.estilos.dict(exclude_none=True))
        
        # Verificar que nombre no existe
        exists = await conn.fetchval(
            "SELECT EXISTS(SELECT 1 FROM juego_dioses.tipos_particulas WHERE nombre = $1)",
            tipo.nombre
        )
        if exists:
            raise HTTPException(status_code=400, detail=f"Tipo de part√≠cula '{tipo.nombre}' ya existe")
        
        # Insertar en BD
        row = await conn.fetchrow("""
            INSERT INTO juego_dioses.tipos_particulas 
            (nombre, categoria, densidad, color_base, descripcion, estilos)
            VALUES ($1, $2, $3, $4, $5, $6::jsonb)
            RETURNING *
        """, tipo.nombre, tipo.categoria, tipo.densidad, tipo.color_base, 
            tipo.descripcion, estilos_json)
        
        return TipoParticulaResponse.from_attributes(row)

@router.put("/{tipo_id}", response_model=TipoParticulaResponse)
async def update_tipo_particula(tipo_id: UUID, tipo: TipoParticulaUpdate):
    """Actualizar tipo de part√≠cula con validaci√≥n de estilos"""
    async with get_connection() as conn:
        # Validar estilos si se proporcionan
        estilos_json = None
        if tipo.estilos:
            estilos_json = json.dumps(tipo.estilos.dict(exclude_none=True))
        
        # Actualizar en BD (solo campos proporcionados)
        # ... implementar UPDATE con campos opcionales ...
```

**Notas:**
- **IMPORTANTE**: Verificar primero si los endpoints ya existen antes de crear nuevos
- Esta validaci√≥n previene datos inv√°lidos desde el inicio
- Los estilos son opcionales para mantener flexibilidad
- Pydantic valida autom√°ticamente la estructura antes de llegar al endpoint
- Si los endpoints ya existen, solo agregar validaci√≥n de estilos a los existentes

---

### Paso 10: Documentar estructura de estilos JSONB

**Descripci√≥n:**
Agregar documentaci√≥n sobre la estructura JSONB de estilos, c√≥mo agregar nuevos campos, y ejemplos de uso.

**Archivos a modificar/crear:**
- `database/init/01-init-schema.sql` - Agregar comentarios SQL
- Crear `docs/estilos-particulas.md` - Documentaci√≥n completa

**Detalles de implementaci√≥n:**
```markdown
# Estilos de Part√≠culas - Documentaci√≥n

## Estructura JSONB

El campo `estilos` en `tipos_particulas` tiene la siguiente estructura:

```json
{
    "color_hex": 9474192,          // Opcional: Color en hexadecimal (0-0xFFFFFF)
    "color_rgb": [148, 116, 85],   // Opcional: Color en RGB [R, G, B]
    "material": {                   // Opcional: Propiedades de material
        "metalness": 0.1,          // 0.0-1.0
        "roughness": 0.8,          // 0.0-1.0
        "emissive": false          // boolean
    },
    "visual": {                     // Opcional: Propiedades visuales
        "modelo": "cube",          // "cube", "sphere", "custom"
        "escala": 1.0              // 0.1-10.0
    }
}
```

## Agregar Nuevos Campos

Para agregar nuevos campos a los estilos, seguir estos pasos:

1. Agregar campo al modelo Pydantic `EstilosParticula`
2. Actualizar documentaci√≥n
3. Frontend puede ignorar campos desconocidos (graceful degradation)
```

**Notas:**
- Documentaci√≥n ayuda a otros desarrolladores y a la IA
- Ejemplos claros facilitan el uso

---

### Paso Final: Generar Descripci√≥n del Pull Request

**Descripci√≥n:**
Una vez completados todos los pasos anteriores y verificada la implementaci√≥n, genera la descripci√≥n completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-002_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendr√° una descripci√≥n completa del PR lista para copiar y pegar en Git
- Incluir√°: t√≠tulo, resumen, motivaci√≥n, cambios t√©cnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPU√âS de completar toda la implementaci√≥n
- La descripci√≥n se genera autom√°ticamente bas√°ndose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones T√©cnicas

### Performance
- **Query separada para tipos** (m√°s eficiente que JOIN con duplicaci√≥n)
- **50% menos datos transferidos** (sin duplicar estilos en cada part√≠cula)
- **Cache en backend** para tipos (5-10 minutos, cambian menos)
- **Cache en frontend** evita procesamiento repetido
- **Carga paralela** de tipos y part√≠culas con `Promise.all()` (m√°s r√°pido)
- **99.75% menos procesamiento JSONB** (solo tipos √∫nicos vs todas las part√≠culas)
- √çndice GIN en JSONB para b√∫squedas eficientes si se necesitan queries por estilos

### Seguridad
- Validaci√≥n Pydantic previene valores inv√°lidos
- Sanitizaci√≥n de valores (rangos, tipos)
- Manejo seguro de JSONB (evitar inyecci√≥n SQL ya que usamos asyncpg parametrizado)

### Casos Edge
- Part√≠culas sin estilos: Usar fallback a colores hardcoded
- Estilos JSONB malformados: Manejar con try-catch y usar fallback
- Tipos de part√≠culas que no existen: LEFT JOIN puede devolver NULL, manejar correctamente
- Cache desactualizado: Implementar invalidaci√≥n en futuro si es necesario

### Compatibilidad
- Mantener compatibilidad con part√≠culas existentes sin estilos
- Fallback a colores hardcoded durante migraci√≥n
- Campo `estilos` es opcional (puede ser NULL o '{}')

## Patrones de C√≥digo a Usar

- **Backend (FastAPI)**: 
  - Validaci√≥n con Pydantic models
  - Queries parametrizadas con asyncpg
  - JOIN en lugar de queries separadas para performance

- **Base de Datos**: 
  - JSONB para flexibilidad
  - √çndices GIN para b√∫squedas eficientes
  - Migraciones incrementales

- **Frontend (Three.js)**: 
  - Cache en memoria (Map)
  - Fallback graceful a valores por defecto
  - No romper renderizado si faltan estilos

## Dependencias

### Nuevas Dependencias (si aplica)
No se requieren nuevas dependencias. Se usa lo existente:
- Pydantic (ya incluido en FastAPI)
- asyncpg (ya en uso)
- Three.js (ya en uso)

### Variables de Entorno (si aplica)
No se requieren nuevas variables de entorno.

## Archivos Principales Involucrados

1. `database/init/01-init-schema.sql` - Agregar campo estilos JSONB
2. `database/init/02-seed-data.sql` - Migrar colores hardcoded
3. `backend/src/models/schemas.py` - Modelos Pydantic para estilos y `ParticleTypeResponse`
4. `backend/src/api/routes/particles.py` - Crear endpoint `get_particle_types_in_viewport` y mantener query sin estilos
5. `backend/src/api/routes/agrupaciones.py` - Mantener query sin estilos
6. `frontend/src/api.js` - Agregar m√©todo `getParticleTypes()`
7. `frontend/src/main.js` - Modificar `loadDemo()` para cargar tipos y part√≠culas en paralelo
8. `frontend/src/scene.js` - Implementar `cacheStyle()`, `parseStyle()` y modificar `renderParticles()`

## Testing

### Tests a Crear/Modificar
- Unit tests: `tests/test_schemas_estilos.py` - Validar modelos de estilos
- Integration tests: `tests/integration/test_particles_estilos.py` - Verificar queries con estilos

### Escenarios de Prueba

**Unit Tests (test_schemas_estilos.py):**
```python
import pytest
from pydantic import ValidationError
from src.models.schemas import EstilosParticula, MaterialProperties, ParticleTypeResponse

def test_estilos_particula_valid():
    """Test que estilos v√°lidos pasan validaci√≥n"""
    estilo = EstilosParticula(
        color_hex=0x90EE90,
        color_rgb=[144, 238, 144],
        material=MaterialProperties(metalness=0.1, roughness=0.8)
    )
    assert estilo.color_hex == 0x90EE90
    assert estilo.color_rgb == [144, 238, 144]

def test_estilos_particula_invalid_rgb():
    """Test que RGB fuera de rango falla"""
    with pytest.raises(ValueError):
        EstilosParticula(color_rgb=[300, 0, 0])  # 300 > 255

def test_estilos_particula_invalid_metalness():
    """Test que metalness fuera de rango falla"""
    with pytest.raises(ValidationError):
        EstilosParticula(material=MaterialProperties(metalness=2.0))  # > 1.0

def test_parse_jsonb_field():
    """Test funci√≥n helper parse_jsonb_field"""
    from src.models.schemas import parse_jsonb_field
    
    assert parse_jsonb_field('{"key": "value"}') == {"key": "value"}
    assert parse_jsonb_field({"key": "value"}) == {"key": "value"}
    assert parse_jsonb_field(None) == {}
    assert parse_jsonb_field('') == {}

def test_particle_type_response():
    """Test schema ParticleTypeResponse"""
    tipo = ParticleTypeResponse(
        id="uuid-123",
        nombre="hierba",
        estilos={"color_hex": 9474192}
    )
    assert tipo.nombre == "hierba"
    assert tipo.estilos["color_hex"] == 9474192
```

**Integration Tests:**
1. Crear tipo de part√≠cula con estilos v√°lidos
2. Crear tipo de part√≠cula con estilos inv√°lidos (debe fallar validaci√≥n)
3. Obtener tipos de part√≠culas en viewport y verificar que incluyen estilos
4. Obtener part√≠culas y verificar que NO incluyen estilos (vienen en query separada)
5. Verificar que `ParticleResponse.from_row()` funciona sin estilos
6. Verificar carga paralela de tipos y part√≠culas en frontend
7. Renderizar part√≠culas con estilos cacheados (test manual en frontend)
8. Verificar fallback cuando no hay estilos
9. Verificar que tipos se cachean correctamente antes de renderizar

## Deployment

### Orden de Deployment
1. Base de datos: Ejecutar migraci√≥n para agregar campo `estilos`
2. Base de datos: Ejecutar script para migrar colores hardcoded
3. Backend: Deploy con cambios en queries y schemas
4. Frontend: Deploy con cambios en cache y renderizado
5. Verificar en ambiente local con Docker Compose

### Verificaci√≥n Post-Deployment
- [ ] Verificar que campo `estilos` existe en BD
- [ ] Verificar que tipos existentes tienen estilos migrados
- [ ] Verificar endpoint `/particle-types` retorna tipos con estilos
- [ ] Verificar endpoint de part√≠culas NO incluye estilos (query separada)
- [ ] Verificar carga paralela de tipos y part√≠culas funciona
- [ ] Verificar tipos se cachean antes de renderizar
- [ ] Verificar frontend renderiza correctamente con estilos cacheados
- [ ] Verificar fallback funciona si faltan estilos
- [ ] Verificar logs de Docker no muestran errores
- [ ] Verificar rendimiento (debe ser mejor que JOIN con duplicaci√≥n)

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. La implementaci√≥n est√° dise√±ada para ser incremental y no romper funcionalidad existente.

**‚ö†Ô∏è IMPORTANTE:** El √∫ltimo paso del plan SIEMPRE debe ser "Generar Descripci√≥n del Pull Request" usando `@pr-description.mdc`. Esto genera autom√°ticamente la descripci√≥n completa del PR lista para Git.

---

## üîÑ Mejoras Aplicadas (Basadas en Revisi√≥n)

Este plan ha sido mejorado con las siguientes optimizaciones:

### ‚úÖ Mejoras Implementadas

1. **Funci√≥n Helper Reutilizable** (Paso 2)
   - ‚úÖ Creada `parse_jsonb_field()` para parsear campos JSONB de forma consistente
   - ‚úÖ Evita duplicaci√≥n de c√≥digo entre diferentes endpoints

2. **M√©todo Est√°tico `from_row()`** (Paso 5)
   - ‚úÖ Centraliza la conversi√≥n de filas BD ‚Üí `ParticleResponse`
   - ‚úÖ Evita duplicaci√≥n entre `particles.py` y `agrupaciones.py`
   - ‚úÖ Facilita mantenimiento futuro

3. **Mejora en `ParticleResponse`** (Paso 5)
   - ‚úÖ Campos expl√≠citos (`tipo_nombre`, `estado_nombre`) en lugar de `extra = "allow"`
   - ‚úÖ Mejor validaci√≥n y detecci√≥n de errores

4. **Logging para Debugging** (Paso 4)
   - ‚úÖ Agregado logging para monitorear migraci√≥n
   - ‚úÖ Facilita identificaci√≥n de problemas

5. **Documentaci√≥n de Cache** (Paso 7)
   - ‚úÖ Agregadas notas sobre invalidaci√≥n futura de cache
   - ‚úÖ Documenta estrategias para mantener cache actualizado

6. **Verificaci√≥n de Endpoints** (Paso 9)
   - ‚úÖ Instrucciones para verificar endpoints existentes antes de crear nuevos
   - ‚úÖ Evita duplicaci√≥n de c√≥digo

7. **Tests Mejorados** (Secci√≥n Testing)
   - ‚úÖ Ejemplos concretos de tests unitarios
   - ‚úÖ Tests para funci√≥n helper `parse_jsonb_field`

### üìä Impacto de las Mejoras

- **Mantenibilidad**: ‚¨ÜÔ∏è C√≥digo m√°s limpio y centralizado
- **Debugging**: ‚¨ÜÔ∏è Logging facilita identificaci√≥n de problemas
- **Consistencia**: ‚¨ÜÔ∏è Funci√≥n helper asegura parsing consistente
- **Calidad**: ‚¨ÜÔ∏è Validaci√≥n expl√≠cita en lugar de `extra = "allow"`
- **Documentaci√≥n**: ‚¨ÜÔ∏è Mejor documentaci√≥n de cache y futuras mejoras

---

**Referencia de Revisi√≥n**: Ver `JDG-002-action-plan-REVISION.md` para detalles completos de la revisi√≥n.

**Cambio Importante**: Este plan usa **query separada** en lugar de JOIN con estilos. Ver `JDG-002-COMPARACION-JOIN-vs-QUERY-SEPARADA.md` para an√°lisis completo. Ventajas:
- ‚úÖ 50% menos datos transferidos
- ‚úÖ 99.75% menos procesamiento JSONB
- ‚úÖ Cache eficiente en backend (tipos cacheables por 5-10 min)
- ‚úÖ Mejor escalabilidad para MMO

---

## üìã ANEXO: Bug Detectado Durante la Implementaci√≥n

### Bug: Interpretaci√≥n Incorrecta de Colores Hexadecimales

**Fecha de Detecci√≥n**: Durante la implementaci√≥n del Paso 7 (Frontend)

**Descripci√≥n del Problema**:
Durante la implementaci√≥n, se detect√≥ que los colores almacenados como n√∫meros decimales en la base de datos (ej: `9145235` para `0x8B4513`) eran mal interpretados por `THREE.Color` cuando se pasaban directamente como n√∫meros. `THREE.Color` interpreta n√∫meros como valores RGB individuales en lugar de valores hexadecimales completos.

**S√≠ntomas**:
- Solo se renderizaban part√≠culas verdes (color por defecto o color de error)
- Los logs mostraban que los estilos se estaban cargando y cacheando correctamente
- Los valores decimales de color estaban presentes en el cache, pero no se aplicaban visualmente

**Causa Ra√≠z**:
1. Los colores se guardaban como n√∫meros decimales en JSONB (ej: `9474192` para `0x90EE90`)
2. El frontend recib√≠a estos n√∫meros decimales
3. `THREE.Color` interpretaba el n√∫mero decimal como RGB en lugar de hexadecimal
   - Ejemplo: `9145235` se interpretaba como RGB(91, 45, 35) en lugar de `0x8B4513`

**Soluci√≥n Implementada**:
Se modific√≥ el sistema para almacenar `color_hex` como **string hexadecimal** en lugar de n√∫mero decimal:

1. **Base de Datos** (`database/init/02-seed-data.sql`):
   - Cambio: `color_hex` ahora se guarda como string (ej: `'0x8B4513'`)
   - Antes: `9474192` (n√∫mero decimal)
   - Despu√©s: `'0x8B4513'` (string hexadecimal)

2. **Backend** (`backend/src/models/schemas.py`):
   - Cambio: `EstilosParticula.color_hex` ahora es `Optional[str]` en lugar de `Optional[int]`
   - Validaci√≥n: Acepta strings en formato `"0xRRGGBB"` o `"#RRGGBB"`

3. **Frontend** (`frontend/src/scene.js`):
   - Cambio: `parseStyle()` ahora guarda el string hexadecimal directamente
   - Cambio: `createMaterial()` ahora pasa el string directamente a `THREE.Color`
   - Eliminado: Conversi√≥n manual de decimal a hexadecimal (ya no es necesaria)

**Ventajas de la Soluci√≥n**:
- ‚úÖ **Compatible con m√∫ltiples frontends**: Strings hexadecimales son est√°ndar universal
  - Web (Three.js, Canvas, CSS): `"0x8B4513"` o `"#8B4513"`
  - Mobile (React Native, Flutter): `"#8B4513"`
  - VR (Unity, Unreal): `"#8B4513"` o conversi√≥n directa
  - Texto: F√°cil de mostrar y parsear
- ‚úÖ **M√°s legible**: Strings hexadecimales son m√°s f√°ciles de leer y debuggear
- ‚úÖ **Sin conversi√≥n**: No requiere conversi√≥n en el frontend
- ‚úÖ **Menos errores**: Elimina ambig√ºedad entre decimal y hexadecimal

**Archivos Modificados para la Soluci√≥n**:
1. `database/init/02-seed-data.sql` - Cambio de n√∫meros a strings hexadecimales
2. `backend/src/models/schemas.py` - Cambio de tipo `int` a `str` para `color_hex`
3. `frontend/src/scene.js` - Eliminaci√≥n de conversi√≥n manual, uso directo de string
4. `frontend/src/types.js` - Actualizaci√≥n de tipos JSDoc

**Lecciones Aprendidas**:
1. **Formato de datos**: Es mejor almacenar datos en el formato m√°s cercano a c√≥mo se usan en el frontend
2. **Testing visual**: Los bugs de renderizado visual requieren testing visual, no solo logs
3. **Compatibilidad multi-frontend**: Strings hexadecimales son m√°s universales que n√∫meros decimales
4. **Documentaci√≥n**: Los tipos JSDoc deben reflejar exactamente el formato de los datos

**Estado**: ‚úÖ **RESUELTO** - Todos los cambios implementados y probados

