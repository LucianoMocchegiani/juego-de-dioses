# JDG-003 - Optimización de rendimiento del frontend y mejoras de UX

## Descripción de la Tarea

Optimizar el rendimiento del frontend implementando instanced rendering para reducir drásticamente los draw calls y permitir renderizar terrenos grandes (40m x 40m). Además, ajustar la grilla para que se alinee con el terreno, limpiar constantes no utilizadas y mejorar la selección de dimensión demo.

**Comportamiento actual:**
- El frontend renderiza cada partícula como un mesh individual
- Con 100,000 partículas = 100,000 draw calls = 5-10 FPS
- Límite de viewport: 30x30 celdas (7.5m x 7.5m)
- La grilla está fija y no se alinea con el terreno
- Constantes no utilizadas en el código
- El frontend puede seleccionar la dimensión demo incorrecta

**Comportamiento esperado:**
- El frontend usa instanced rendering para agrupar partículas
- Con 100,000 partículas en 5 grupos = 5 draw calls = 50-60 FPS
- Límite de viewport: 160x160 celdas (40m x 40m)
- La grilla se ajusta dinámicamente al tamaño del terreno
- Solo constantes utilizadas en el código
- El frontend selecciona la dimensión demo correcta por nombre exacto

## Criterios de Aceptación

1. ✅ El frontend usa instanced rendering para agrupar partículas del mismo tipo/material
2. ✅ El rendimiento mejora significativamente: de 5-10 FPS a 50-60 FPS con 100k partículas
3. ✅ El viewport puede cargar hasta 160x160 celdas (40m x 40m) sin problemas
4. ✅ La grilla se ajusta dinámicamente al tamaño del terreno y se centra correctamente
5. ✅ Los ejes se posicionan en el centro del terreno
6. ✅ Se eliminan todas las constantes no utilizadas
7. ✅ El frontend selecciona la dimensión demo correcta por nombre exacto
8. ✅ El backend valida viewports de hasta 500,000 celdas
9. ✅ El cálculo del viewport considera rangos inclusivos correctamente

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Frontend: HTML5, JavaScript ES6+, Three.js
- Base de datos: PostgreSQL 16
- Containerización: Docker + Docker Compose

## Pasos de Implementación

### Paso 1: Implementar instanced rendering en frontend

**Descripción:**
Modificar `renderParticles()` en `scene.js` para agrupar partículas por tipo/material y usar `THREE.InstancedMesh` en lugar de crear meshes individuales.

**Archivos a modificar/crear:**
- `frontend/src/scene.js`

**Detalles de implementación:**
```javascript
// Agrupar partículas por tipo/material
const particlesByType = new Map();

particles.forEach((particle) => {
    const estilo = this.getStyle(particle.tipo);
    const opacity = estilo.opacity !== undefined ? estilo.opacity : 1.0;
    
    if (opacity === 0.0) return; // Saltar invisibles
    
    const materialKey = `${particle.tipo}_${estilo.metalness}_${estilo.roughness}_${opacity}`;
    
    if (!particlesByType.has(materialKey)) {
        particlesByType.set(materialKey, {
            tipo: particle.tipo,
            estilo: estilo,
            particles: []
        });
    }
    
    particlesByType.get(materialKey).particles.push(particle);
});

// Crear instanced meshes para cada grupo
particlesByType.forEach((group, materialKey) => {
    const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
    const material = this.createMaterial(group.estilo);
    const instancedMesh = new THREE.InstancedMesh(geometry, material, group.particles.length);
    
    // Configurar posiciones
    const matrix = new THREE.Matrix4();
    group.particles.forEach((particle, index) => {
        const x = particle.celda_x * cellSize + cellSize / 2;
        const y = particle.celda_z * cellSize + cellSize / 2;
        const z = particle.celda_y * cellSize + cellSize / 2;
        matrix.setPosition(x, y, z);
        instancedMesh.setMatrixAt(index, matrix);
    });
    
    instancedMesh.instanceMatrix.needsUpdate = true;
    this.instancedMeshes.set(materialKey, instancedMesh);
    this.scene.add(instancedMesh);
});
```

**Notas:**
- Agregar `this.instancedMeshes = new Map()` en el constructor
- Modificar `clearParticles()` para limpiar instanced meshes también
- Limitar a 100,000 instancias por grupo para evitar problemas de memoria

**Recursos útiles:**
- Three.js InstancedMesh: https://threejs.org/docs/#api/en/objects/InstancedMesh

---

### Paso 2: Aumentar límites del viewport

**Descripción:**
Aumentar los límites del viewport en constantes y ajustar el cálculo dinámico del viewport para considerar rangos inclusivos.

**Archivos a modificar/crear:**
- `frontend/src/constants.js`
- `frontend/src/main.js`
- `backend/src/models/schemas.py`

**Detalles de implementación:**
```javascript
// constants.js
export const VIEWPORT_MAX_CELLS_X = 160; // De 30 a 160
export const VIEWPORT_MAX_CELLS_Y = 160; // De 30 a 160

// main.js - Cálculo correcto de rangos inclusivos
const xMax = Math.min(celdas_x - 1, VIEWPORT_MAX_CELLS_X - 1);
const yMax = Math.min(celdas_y - 1, VIEWPORT_MAX_CELLS_Y - 1);
const xRange = xMax - 0 + 1; // Número real de celdas
const yRange = yMax - 0 + 1;
const maxCells = 500000;
const maxZRange = Math.floor(maxCells / (xRange * yRange));
```

```python
# schemas.py
# Aumentar límite de 100k a 500k celdas
if total_cells > 500000:
    raise ValueError(f"Viewport demasiado grande: {total_cells} celdas. Máximo: 500000")
```

**Notas:**
- Los rangos son inclusivos: x_max - x_min + 1 = número de celdas
- Validar que el total no exceda el límite antes de crear el viewport

---

### Paso 3: Implementar grilla dinámica

**Descripción:**
Modificar `createHelpers()` para crear helpers dinámicamente y agregar método `updateHelpers()` que ajusta la grilla y ejes al tamaño del terreno.

**Archivos a modificar/crear:**
- `frontend/src/scene.js`
- `frontend/src/main.js`

**Detalles de implementación:**
```javascript
// scene.js
createHelpers() {
    this.gridHelper = null;
    this.axesHelper = null;
}

updateHelpers(anchoMetros, altoMetros) {
    // Remover helpers antiguos
    if (this.gridHelper) this.scene.remove(this.gridHelper);
    if (this.axesHelper) this.scene.remove(this.axesHelper);
    
    // Calcular tamaño de grilla
    const gridSize = Math.max(anchoMetros, altoMetros) * 1.2;
    const gridDivisions = Math.max(20, Math.floor(gridSize / 2));
    
    // Crear grilla centrada
    this.gridHelper = new THREE.GridHelper(gridSize, gridDivisions, COLOR_GRID_PRIMARY, COLOR_GRID_SECONDARY);
    this.gridHelper.position.set(anchoMetros / 2, 0, altoMetros / 2);
    this.scene.add(this.gridHelper);
    
    // Crear ejes centrados
    this.axesHelper = new THREE.AxesHelper(Math.max(anchoMetros, altoMetros) * 0.3);
    this.axesHelper.position.set(anchoMetros / 2, 0, altoMetros / 2);
    this.scene.add(this.axesHelper);
}
```

```javascript
// main.js - Llamar después de renderizar partículas
scene.updateHelpers(demoDimension.ancho_metros, demoDimension.alto_metros);
```

**Notas:**
- La grilla debe ser 20% más grande que el terreno para contexto
- Los ejes deben ser proporcionales al tamaño del terreno

---

### Paso 4: Mejorar selección de dimensión demo

**Descripción:**
Agregar constante `DEMO_DIMENSION_NAME` y modificar la búsqueda para usar nombre exacto en lugar de búsqueda parcial.

**Archivos a modificar/crear:**
- `frontend/src/constants.js`
- `frontend/src/main.js`

**Detalles de implementación:**
```javascript
// constants.js
export const DEMO_DIMENSION_NAME = 'Demo - Bioma Bosque 40x40 con Acuífero';

// main.js
const demoDimension = dimensions.find(d => 
    d.nombre && d.nombre === DEMO_DIMENSION_NAME
);
```

**Notas:**
- Si no se encuentra, mostrar error con dimensiones disponibles
- Esto evita seleccionar dimensiones demo antiguas

---

### Paso 5: Limpiar constantes no utilizadas

**Descripción:**
Eliminar constantes que ya no se usan después de los cambios anteriores.

**Archivos a modificar/crear:**
- `frontend/src/constants.js`
- `frontend/src/scene.js`

**Detalles de implementación:**
Eliminar:
- `GRID_SIZE` (ahora se calcula dinámicamente)
- `GRID_DIVISIONS` (ahora se calcula dinámicamente)
- `AXES_SIZE` (ahora se calcula dinámicamente)
- `VIEWPORT_DEFAULT_Z_MIN` (no se usa)
- `VIEWPORT_DEFAULT_Z_MAX` (no se usa)

También eliminar las importaciones correspondientes en `scene.js`.

**Notas:**
- Verificar que no se usen en ningún otro archivo antes de eliminar

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-003_pr-description_2025-12-04_18-41-20.md` en `/instructions/prs/`
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git

---

## Consideraciones Técnicas

### Performance
- Instanced rendering reduce draw calls de 100k a ~5 (mejora de 20,000x)
- Compartir geometrías y materiales reduce uso de memoria
- El sistema puede manejar terrenos más grandes sin problemas de rendimiento

### Seguridad
- No hay cambios de seguridad en este PR

### Casos Edge
- Terrenos muy grandes (>500k celdas): el backend rechaza con error claro
- Múltiples dimensiones demo: el frontend selecciona la correcta por nombre
- Partículas con diferentes materiales: se agrupan correctamente

### Compatibilidad
- Los cambios son transparentes para el usuario (mismo resultado visual)
- Compatible con versiones anteriores de la API

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - InstancedMesh para optimización de renderizado
  - Agrupación inteligente por tipo/material
  - Helpers dinámicos que se ajustan al contenido

## Dependencias

### Nuevas Dependencias
Ninguna

### Variables de Entorno
Ninguna nueva

## Archivos Principales Involucrados

1. `frontend/src/scene.js` - Implementación de instanced rendering y helpers dinámicos
2. `frontend/src/main.js` - Cálculo dinámico de viewport y selección de dimensión
3. `frontend/src/constants.js` - Limpieza de constantes no usadas
4. `backend/src/models/schemas.py` - Aumento de límite de viewport

## Testing

### Escenarios de Prueba
1. Cargar terreno de 40m x 40m y verificar que se renderiza correctamente
2. Verificar que el FPS se mantiene por encima de 50 FPS con 100k+ partículas
3. Verificar que la grilla está centrada y alineada con el terreno
4. Verificar que se selecciona la dimensión demo correcta cuando hay múltiples dimensiones

## Deployment

### Orden de Deployment
1. Frontend: Rebuild Docker image y restart container
2. Backend: Rebuild Docker image y restart container (si hay cambios)
3. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar frontend en navegador
- [ ] Verificar que el terreno se carga correctamente
- [ ] Verificar que la grilla está alineada
- [ ] Verificar logs de Docker

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

