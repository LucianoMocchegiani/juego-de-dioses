# JDG-004 - Optimización de visualización de árboles y rendimiento

## Descripción de la Tarea

Optimizar la visualización de árboles altos y mejorar el rendimiento del frontend mediante:
1. Aumentar altura máxima de dimensiones para acomodar árboles hasta z=32
2. Aumentar límite de viewport del backend para permitir cargar más altura
3. Ajustar cálculo de viewport para priorizar altura sobre profundidad
4. Eliminar gaps visuales entre troncos y hojas
5. Optimizar generación de hojas con densidad variable
6. Optimizar frontend dividiendo InstancedMeshes grandes

**Comportamiento actual:**
- Dimensión demo tiene `altura_maxima = 10`, insuficiente para árboles hasta z=32
- Límite de viewport es 500k celdas, restringe rango Z visible
- Viewport no prioriza altura, corta copas de árboles altos
- Copas excluyen posiciones del tronco, creando gaps visuales
- Hojas se generan con 100% densidad, generando demasiadas partículas
- Frontend agrupa todo en un solo InstancedMesh, causando problemas de rendimiento

**Comportamiento esperado:**
- Dimensión con `altura_maxima = 40` para árboles hasta z=32
- Límite de viewport aumentado a 1M celdas
- Viewport prioriza altura (3/4 del rango hacia arriba)
- Copas incluyen posiciones del tronco, sin gaps
- Hojas con densidad variable (100% centro, 90% media, 70% bordes)
- Frontend divide grupos grandes en múltiples InstancedMeshes (máx 50k)

## Criterios de Aceptación

1. ✅ Dimensión demo se crea con `altura_maxima = 40`
2. ✅ Backend acepta viewports de hasta 1,000,000 celdas
3. ✅ Frontend calcula viewport priorizando altura (3/4 hacia arriba)
4. ✅ Copas se generan sin gaps (hojas incluyen posiciones del tronco)
5. ✅ Hojas se generan con densidad variable
6. ✅ Frontend divide grupos grandes en múltiples InstancedMeshes
7. ✅ Árboles hasta z=32 se visualizan completamente
8. ✅ Rendimiento mejora o se mantiene estable
9. ✅ No hay gaps visuales entre troncos y hojas

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Frontend: HTML5, JavaScript ES6+, Three.js
- Base de datos: PostgreSQL 16
- Containerización: Docker + Docker Compose

## Pasos de Implementación

### Paso 1: Aumentar altura máxima de dimensión en seed

**Descripción:**
Modificar `seed_demo.py` para que la dimensión demo se cree con `altura_maxima = 40` en lugar de 10, permitiendo que los árboles más altos (hasta z=32) quepan completamente.

**Archivos a modificar/crear:**
- `backend/src/database/seed_demo.py`

**Detalles de implementación:**
```python
# En seed_demo.py, línea ~90
altura_maxima,
# Cambiar de:
10,
# A:
40,  # Suficiente para árboles hasta z=32 (tronco z=30 + copa 3 niveles)
```

**Notas:**
- Agregar comentario explicando por qué 40 (árboles hasta z=33 con margen)
- La dimensión existente debe borrarse y recrearse para aplicar el cambio

---

### Paso 2: Aumentar límite de viewport en backend

**Descripción:**
Aumentar `MAX_VIEWPORT_CELLS` en `schemas.py` de 500,000 a 1,000,000 para permitir cargar viewports más grandes que incluyan toda la altura de los árboles.

**Archivos a modificar/crear:**
- `backend/src/models/schemas.py`

**Detalles de implementación:**
```python
# En schemas.py, en ParticleViewportQuery
# Cambiar de:
if total_cells > 500000:  # Límite de 500k celdas
    raise ValueError(f"Viewport demasiado grande: {total_cells} celdas. Máximo: 500000")
# A:
if total_cells > 1000000:  # Límite de 1M celdas
    raise ValueError(f"Viewport demasiado grande: {total_cells} celdas. Máximo: 1000000")
```

**Notas:**
- Actualizar comentario explicando el nuevo límite
- 160x160x40 = 1,024,000 celdas (justo dentro del límite)

---

### Paso 3: Ajustar cálculo de viewport en frontend para priorizar altura

**Descripción:**
Modificar el cálculo del viewport en `main.js` para usar 3/4 del rango Z hacia arriba (altura) y 1/4 hacia abajo (profundidad), asegurando que las copas de los árboles sean visibles.

**Archivos a modificar/crear:**
- `frontend/src/main.js`

**Detalles de implementación:**
```javascript
// En main.js, en loadDemo()
// Cambiar cálculo de zMin y zMax:
const espacioHaciaAbajo = Math.floor(maxZRange / 4);  // 1/4 hacia abajo
const espacioHaciaArriba = maxZRange - espacioHaciaAbajo;  // 3/4 hacia arriba

let zMin = Math.max(
    demoDimension.profundidad_maxima || -8, 
    zCenter - espacioHaciaAbajo
);
let zMax = Math.min(
    Math.max(demoDimension.altura_maxima || 35, 35),
    zCenter + espacioHaciaArriba - 1
);
```

**Notas:**
- Actualizar comentario explicando la priorización de altura
- Asegurar que zMax pueda llegar al menos a 35 para ver copas

---

### Paso 4: Actualizar límite de viewport en frontend

**Descripción:**
Actualizar la constante `maxCells` en `main.js` para reflejar el nuevo límite de 1M celdas del backend.

**Archivos a modificar/crear:**
- `frontend/src/main.js`

**Detalles de implementación:**
```javascript
// En main.js, en loadDemo()
// Cambiar de:
const maxCells = 500000; // Límite del backend
// A:
const maxCells = 1000000; // Límite del backend (1M celdas)
```

**Notas:**
- Mantener sincronizado con el límite del backend

---

### Paso 5: Eliminar gaps entre tronco y hojas

**Descripción:**
Modificar `get_posiciones_copa` en `tree_templates.py` para incluir las posiciones del tronco en la generación de hojas, eliminando gaps visuales.

**Archivos a modificar/crear:**
- `backend/src/database/tree_templates.py`

**Detalles de implementación:**
```python
# En tree_templates.py, método get_posiciones_copa
# Eliminar la exclusión de posiciones del tronco:
# ANTES:
if not dentro_tronco:
    posiciones.append((x_centro + dx, y_centro + dy, z))

# DESPUÉS:
# Incluir todas las posiciones dentro del radio de la copa
# Esto incluye las posiciones del tronco también, para que no haya gap
posiciones.append((x_centro + dx, y_centro + dy, z))
```

**Notas:**
- Las hojas ahora se generarán también en el centro del tronco, justo encima
- Esto elimina el gap visual pero no afecta la estructura del árbol

---

### Paso 6: Optimizar generación de hojas con densidad variable

**Descripción:**
Modificar `get_posiciones_copa` para generar hojas con densidad variable según la distancia del centro y el nivel, reduciendo el número total de partículas y mejorando el rendimiento.

**Archivos a modificar/crear:**
- `backend/src/database/tree_templates.py`

**Detalles de implementación:**
```python
# En tree_templates.py, método get_posiciones_copa
# Agregar lógica de densidad variable:
for z in range(z_base, z_base + self.copa_niveles):
    nivel_relativo = z - z_base
    densidad_base = 1.0 - (nivel_relativo * 0.15)  # Reduce 15% por nivel
    
    for dx in range(-self.copa_tamano, self.copa_tamano + 1):
        for dy in range(-self.copa_tamano, self.copa_tamano + 1):
            distancia = (dx*dx + dy*dy) ** 0.5
            
            if distancia <= self.copa_tamano:
                # Calcular densidad según distancia
                if distancia <= 1:
                    densidad = 1.0  # Centro: siempre lleno
                elif distancia <= self.copa_tamano * 0.5:
                    densidad = 0.9 * densidad_base  # Zona media: 90%
                else:
                    densidad = 0.7 * densidad_base  # Bordes: 70%
                
                # Aplicar densidad aleatoria
                if random.random() <= densidad:
                    posiciones.append((x_centro + dx, y_centro + dy, z))
```

**Notas:**
- La densidad variable reduce el número total de partículas de hojas
- Los árboles se verán más frondosos en el centro y más dispersos en los bordes
- Esto mejora el rendimiento sin sacrificar demasiado la apariencia visual

---

### Paso 7: Optimizar frontend dividiendo InstancedMeshes grandes

**Descripción:**
Modificar `renderParticles` en `scene.js` para dividir grupos grandes de partículas en múltiples InstancedMeshes, limitando cada uno a 50,000 instancias para mejorar el rendimiento.

**Archivos a modificar/crear:**
- `frontend/src/scene.js`

**Detalles de implementación:**
```javascript
// En scene.js, método renderParticles
// Cambiar de:
const instancedMesh = new THREE.InstancedMesh(geometry, material, group.particles.length);
// A:
const MAX_INSTANCES_PER_MESH = 50000; // Reducido de 100k para mejor rendimiento
const numMeshes = Math.ceil(count / MAX_INSTANCES_PER_MESH);

for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {
    const start = meshIndex * MAX_INSTANCES_PER_MESH;
    const end = Math.min(start + MAX_INSTANCES_PER_MESH, count);
    const particlesChunk = group.particles.slice(start, end);
    
    const instancedMesh = new THREE.InstancedMesh(geometry, material, particlesChunk.length);
    // ... configurar posiciones ...
    
    const meshKey = numMeshes > 1 ? `${materialKey}_${meshIndex}` : materialKey;
    this.instancedMeshes.set(meshKey, instancedMesh);
    this.scene.add(instancedMesh);
}
```

**Notas:**
- Esto divide automáticamente grupos grandes en múltiples meshes
- Mejora el rendimiento al reducir el tamaño de cada draw call
- Es transparente para el usuario final

---

### Paso 8: Regenerar seed demo

**Descripción:**
Regenerar la seed demo para aplicar todos los cambios: nueva altura máxima, copas sin gaps, y densidad variable de hojas.

**Archivos a modificar/crear:**
- Ninguno (ejecutar comando)

**Detalles de implementación:**
```bash
docker-compose exec backend python -m src.database.seed_demo
```

**Notas:**
- La seed borrará automáticamente la dimensión existente antes de crear una nueva
- Verificar que se creen árboles con las nuevas características
- Verificar en consola que no haya errores

---

### Paso 9: Verificar visualización y rendimiento

**Descripción:**
Verificar que los cambios funcionen correctamente: árboles completos visibles, sin gaps, y mejor rendimiento.

**Archivos a modificar/crear:**
- Ninguno (verificación manual)

**Detalles de implementación:**
1. Abrir frontend en navegador
2. Verificar que las copas de árboles hasta z=32 sean visibles
3. Inspeccionar visualmente que no haya gaps entre troncos y hojas
4. Verificar en consola del navegador que grupos grandes se dividan correctamente
5. Medir FPS antes y después (si es posible)

**Notas:**
- Si hay problemas, revisar logs del backend y frontend
- Verificar que el viewport se calcule correctamente en la consola del navegador

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-004_pr-description_2025-12-04_23-58-12.md` en `/instructions/prs/`
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git

---

## Consideraciones Técnicas

### Performance
- Reducción de densidad de hojas en bordes reduce número total de partículas
- División de InstancedMeshes mejora rendimiento con grandes cantidades
- Límite de 1M celdas permite cargar terrenos grandes sin problemas
- Priorización de altura en viewport asegura que se carguen las capas relevantes

### Seguridad
- No aplica (cambios son internos al sistema)

### Casos Edge
- Viewport que excede 1M celdas: Debe rechazarse con mensaje claro
- Árboles en bordes de dimensión: Deben generarse correctamente
- Árboles muy grandes: Deben visualizarse completamente
- Múltiples tipos de árboles: Todos deben verse correctamente

### Compatibilidad
- Los cambios son compatibles con dimensiones existentes
- El aumento del límite de viewport es retrocompatible
- No requiere migraciones de base de datos

## Patrones de Código a Usar

- **Backend (Python)**: 
  - Mantener type hints
  - Usar random para densidad variable
  - Comentarios explicativos para cambios importantes

- **Frontend (JavaScript)**: 
  - Dividir lógica en chunks manejables
  - Usar constantes para límites configurables
  - Logging para debugging

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna

### Variables de Entorno (si aplica)
Ninguna

## Archivos Principales Involucrados

1. `backend/src/database/seed_demo.py` - Aumentar altura máxima de dimensión
2. `backend/src/models/schemas.py` - Aumentar límite de viewport
3. `backend/src/database/tree_templates.py` - Optimizar generación de copas
4. `frontend/src/main.js` - Ajustar cálculo de viewport
5. `frontend/src/scene.js` - Dividir InstancedMeshes grandes

## Testing

### Tests a Crear/Modificar
Ninguno (verificación manual)

### Escenarios de Prueba
1. Verificar altura de dimensión = 40
2. Verificar viewport grande aceptado
3. Verificar visualización completa de árboles
4. Verificar ausencia de gaps
5. Verificar densidad variable de hojas
6. Verificar división de InstancedMeshes
7. Verificar rendimiento mejorado

## Deployment

### Orden de Deployment
1. Backend: Rebuild Docker image y restart container
2. Frontend: Actualizar archivos estáticos
3. Regenerar seed demo
4. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar que dimensión tenga altura_maxima = 40
- [ ] Verificar que viewport grande sea aceptado
- [ ] Verificar visualización completa de árboles
- [ ] Verificar ausencia de gaps visuales
- [ ] Verificar rendimiento en navegador
- [ ] Verificar logs de Docker sin errores

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

