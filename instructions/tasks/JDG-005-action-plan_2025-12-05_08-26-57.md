# JDG-005 - Componentización y Reorganización para Escalabilidad

## Descripción de la Tarea

Refactorizar la estructura del proyecto para prepararlo para escalar fácilmente agregando nuevos tipos de entidades (árboles específicos, plantas, animales cuadrúpedos, razas bípedas). Implementar arquitectura modular con separación por categorías, sistema de templates con herencia (incluyendo niveles intermedios como CuadrupedoTemplate y BipedoTemplate), builders y creators.

**Comportamiento actual:**
- `tree_templates.py` contiene templates genéricos mezclados
- `seed_demo.py` tiene lógica de creación mezclada con seed
- No hay separación por categoría
- Agregar nuevos tipos requiere modificar múltiples archivos
- No hay reutilización de código entre categorías

**Comportamiento esperado:**
- Estructura modular con carpetas separadas por categoría
- Clase base abstracta para compartir funcionalidad común
- Templates específicos que extienden clases base
- Sistema de builders separado
- Sistema de creators de alto nivel
- Registry pattern para descubrir templates dinámicamente
- Agregar nuevo tipo solo requiere crear nuevo archivo

## Criterios de Aceptación

1. ✅ Estructura de carpetas `templates/` con subcarpetas por categoría
2. ✅ Clase base abstracta `BaseTemplate` con métodos comunes
3. ✅ `TreeTemplate` extiende `BaseTemplate` y mantiene funcionalidad actual
4. ✅ Al menos 3 templates específicos de árboles (roble, palmera, paraíso)
5. ✅ Registry pattern para cada categoría
6. ✅ Sistema de builders (`BaseBuilder`, `TreeBuilder`) separado
7. ✅ Sistema de creators (`EntityCreator`) que simplifica creación
8. ✅ `seed_demo.py` usa nuevo sistema y funciona igual que antes
9. ✅ Agregar nuevo template solo requiere crear nuevo archivo
10. ✅ Estructura preparada para plantas, animales cuadrúpedos y razas bípedas
11. ✅ Todo el código existente sigue funcionando
12. ✅ Documentación explica cómo agregar nuevos tipos

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [ ] Frontend (Three.js) - Opcional para futuras mejoras
- [ ] Base de Datos (PostgreSQL) - No requiere cambios

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Patrones de diseño: Template Method, Builder, Registry, Factory
- Type hints y abstracciones (ABC)

## Pasos de Implementación

### Paso 1: Crear estructura de carpetas base

**Descripción:**
Crear la estructura de carpetas para templates, builders y creators siguiendo la arquitectura propuesta.

**Archivos a modificar/crear:**
- `backend/src/database/templates/__init__.py` (nuevo)
- `backend/src/database/templates/trees/__init__.py` (nuevo)
- `backend/src/database/templates/plants/__init__.py` (nuevo)
- `backend/src/database/templates/animals/__init__.py` (nuevo)
- `backend/src/database/templates/races/__init__.py` (nuevo)
- `backend/src/database/builders/__init__.py` (nuevo)
- `backend/src/database/creators/__init__.py` (nuevo)

**Detalles de implementación:**
```python
# backend/src/database/templates/__init__.py
"""Sistema de templates para entidades del juego"""

# backend/src/database/templates/trees/__init__.py
"""Templates de árboles"""

# backend/src/database/templates/plants/__init__.py
"""Templates de plantas"""

# backend/src/database/templates/animals/__init__.py
"""Templates de animales"""

# backend/src/database/templates/races/__init__.py
"""Templates de razas"""

# backend/src/database/builders/__init__.py
"""Builders para crear entidades"""

# backend/src/database/creators/__init__.py
"""Creators de alto nivel para crear entidades y biomas"""
```

**Notas:**
- Crear todas las carpetas y archivos `__init__.py` vacíos primero
- Esto establece la estructura sin romper nada

---

### Paso 2: Crear clase base abstracta BaseTemplate

**Descripción:**
Crear la clase base abstracta `BaseTemplate` que define la interfaz común para todos los templates.

**Archivos a modificar/crear:**
- `backend/src/database/templates/base.py` (nuevo)

**Detalles de implementación:**
```python
from abc import ABC, abstractmethod
from typing import List, Tuple, Dict, Any

class BaseTemplate(ABC):
    """Clase base abstracta para todos los templates de entidades"""
    
    def __init__(self, nombre: str, categoria: str):
        self.nombre = nombre
        self.categoria = categoria  # 'tree', 'plant', 'animal', 'race'
    
    @abstractmethod
    def get_posiciones(self, x_centro: int, y_centro: int, z_base: int) -> List[Tuple[int, int, int]]:
        """
        Obtener todas las posiciones (x, y, z) que forman esta entidad
        Debe ser implementado por cada template específico
        """
        pass
    
    @abstractmethod
    def get_propiedades_particula(self, parte: str) -> Dict[str, Any]:
        """
        Obtener propiedades de partícula para una parte específica de la entidad
        parte: 'tronco', 'hojas', 'raiz', 'cuerpo', 'cabeza', etc.
        """
        pass
    
    def get_metadata(self) -> Dict[str, Any]:
        """Obtener metadata del template (para debugging, logging, etc.)"""
        return {
            'nombre': self.nombre,
            'categoria': self.categoria
        }
```

**Notas:**
- Usar `ABC` de `abc` para hacer la clase abstracta
- Los métodos abstractos deben ser implementados por templates específicos
- `get_metadata()` puede ser sobrescrito por templates específicos para agregar más info

---

### Paso 3: Crear TreeTemplate base que extiende BaseTemplate

**Descripción:**
Crear `TreeTemplate` que extiende `BaseTemplate` y contiene la lógica común de árboles. Mover la funcionalidad actual de `TreeTemplate` de `tree_templates.py`.

**Archivos a modificar/crear:**
- `backend/src/database/templates/trees/base.py` (nuevo)

**Detalles de implementación:**
```python
from typing import List, Tuple, Dict, Any
import random
import math
from src.database.templates.base import BaseTemplate

class TreeTemplate(BaseTemplate):
    """Clase base para templates de árboles"""
    
    def __init__(
        self,
        nombre: str,
        grosor_tronco: int,
        altura_min: int,
        altura_max: int,
        copa_tamano: int,
        copa_niveles: int,
        raiz_tamano: int,
        raiz_profundidad: int,
        densidad: float = 0.15
    ):
        super().__init__(nombre, 'tree')
        self.grosor_tronco = grosor_tronco
        self.altura_min = altura_min
        self.altura_max = altura_max
        self.copa_tamano = copa_tamano
        self.copa_niveles = copa_niveles
        self.raiz_tamano = raiz_tamano
        self.raiz_profundidad = raiz_profundidad
        self.densidad = densidad
    
    def get_altura_aleatoria(self) -> int:
        """Obtener altura aleatoria del tronco"""
        return random.randint(self.altura_min, self.altura_max)
    
    def get_posiciones_tronco(self, x_centro: int, y_centro: int) -> List[Tuple[int, int]]:
        """Obtener posiciones (x, y) que forman el tronco"""
        posiciones = []
        offset = self.grosor_tronco // 2
        
        for dx in range(-offset, self.grosor_tronco - offset):
            for dy in range(-offset, self.grosor_tronco - offset):
                posiciones.append((x_centro + dx, y_centro + dy))
        
        return posiciones
    
    def get_posiciones_copa(self, x_centro: int, y_centro: int, z_base: int) -> List[Tuple[int, int, int]]:
        """Obtener posiciones (x, y, z) que forman la copa"""
        # Mover lógica actual de tree_templates.py aquí
        # ... (código actual de get_posiciones_copa)
        pass
    
    def get_posiciones_raices(self, x_centro: int, y_centro: int, z_superficie: int) -> List[Tuple[int, int, int]]:
        """Obtener posiciones (x, y, z) que forman las raíces"""
        # Mover lógica actual de tree_templates.py aquí
        # ... (código actual de get_posiciones_raices)
        pass
    
    def get_posiciones(self, x_centro: int, y_centro: int, z_base: int) -> List[Tuple[int, int, int]]:
        """
        Implementación de método abstracto: obtener todas las posiciones del árbol
        Combina tronco, copa y raíces
        """
        posiciones = []
        altura_tronco = self.get_altura_aleatoria()
        
        # Raíces
        posiciones.extend(self.get_posiciones_raices(x_centro, y_centro, z_base))
        
        # Tronco
        posiciones_tronco = self.get_posiciones_tronco(x_centro, y_centro)
        for z in range(z_base, z_base + altura_tronco):
            for tx, ty in posiciones_tronco:
                posiciones.append((tx, ty, z))
        
        # Copa
        z_copa_base = z_base + altura_tronco
        posiciones.extend(self.get_posiciones_copa(x_centro, y_centro, z_copa_base))
        
        return posiciones
    
    def get_propiedades_particula(self, parte: str) -> Dict[str, Any]:
        """Obtener propiedades de partícula según la parte del árbol"""
        if parte == 'tronco':
            return {'parte': 'tronco', 'tipo': self.nombre}
        elif parte == 'hojas':
            return {'parte': 'hojas', 'tipo': self.nombre}
        elif parte == 'raiz':
            return {'parte': 'raiz', 'tipo': self.nombre}
        else:
            return {'parte': parte, 'tipo': self.nombre}
```

**Notas:**
- Mover toda la lógica de `TreeTemplate` actual a esta clase
- Mantener compatibilidad con el código existente
- Los métodos `get_posiciones_copa` y `get_posiciones_raices` se copian tal cual del código actual

---

### Paso 4: Crear templates específicos de árboles (roble, palmera, paraíso)

**Descripción:**
Crear templates específicos que extienden `TreeTemplate` con propiedades únicas para cada tipo de árbol.

**Archivos a modificar/crear:**
- `backend/src/database/templates/trees/roble.py` (nuevo)
- `backend/src/database/templates/trees/palmera.py` (nuevo)
- `backend/src/database/templates/trees/paraiso.py` (nuevo)

**Detalles de implementación:**
```python
# backend/src/database/templates/trees/roble.py
from src.database.templates.trees.base import TreeTemplate

class RobleTemplate(TreeTemplate):
    """Template para árbol de roble"""
    
    def __init__(self):
        super().__init__(
            nombre='Roble',
            grosor_tronco=3,  # 3x3 = 9 partículas = 0.75m × 0.75m
            altura_min=20,    # 20 niveles
            altura_max=25,    # 25 niveles
            copa_tamano=5,    # Radio de 5 celdas
            copa_niveles=4,   # 4 niveles de copa
            raiz_tamano=4,    # Raíces se extienden 4 celdas
            raiz_profundidad=4,  # 4 niveles bajo tierra
            densidad=0.10
        )

# backend/src/database/templates/trees/palmera.py
from src.database.templates.trees.base import TreeTemplate

class PalmeraTemplate(TreeTemplate):
    """Template para palmera"""
    
    def __init__(self):
        super().__init__(
            nombre='Palmera',
            grosor_tronco=2,  # Tronco delgado
            altura_min=25,    # Muy alta
            altura_max=30,
            copa_tamano=3,   # Copa pequeña en la parte superior
            copa_niveles=2,  # Pocos niveles de copa
            raiz_tamano=3,
            raiz_profundidad=3,
            densidad=0.05
        )
    
    def get_posiciones_copa(self, x_centro: int, y_centro: int, z_base: int) -> List[Tuple[int, int, int]]:
        """Sobrescribir para copa de palmera (solo en la parte superior)"""
        # Implementación específica para palmera
        # ... (código específico)

# backend/src/database/templates/trees/paraiso.py
from src.database.templates.trees.base import TreeTemplate

class ParaisoTemplate(TreeTemplate):
    """Template para árbol paraíso"""
    
    def __init__(self):
        super().__init__(
            nombre='Paraíso',
            grosor_tronco=2,
            altura_min=15,
            altura_max=20,
            copa_tamano=4,
            copa_niveles=3,
            raiz_tamano=3,
            raiz_profundidad=3,
            densidad=0.15
        )
```

**Notas:**
- Cada template puede sobrescribir métodos para personalización
- Los valores deben ser realistas según el tipo de árbol
- Agregar docstrings descriptivos

---

### Paso 5: Crear registry de árboles

**Descripción:**
Crear un registry que registra todos los templates de árboles disponibles y permite descubrirlos dinámicamente.

**Archivos a modificar/crear:**
- `backend/src/database/templates/trees/registry.py` (nuevo)

**Detalles de implementación:**
```python
from typing import Dict, Optional
from src.database.templates.trees.base import TreeTemplate
from src.database.templates.trees.roble import RobleTemplate
from src.database.templates.trees.palmera import PalmeraTemplate
from src.database.templates.trees.paraiso import ParaisoTemplate

# Registry de todos los templates de árboles
TREE_TEMPLATES: Dict[str, TreeTemplate] = {
    'roble': RobleTemplate(),
    'palmera': PalmeraTemplate(),
    'paraiso': ParaisoTemplate(),
}

def get_tree_template(template_id: str) -> Optional[TreeTemplate]:
    """
    Obtener un template de árbol por ID
    
    Args:
        template_id: ID del template ('roble', 'palmera', etc.)
    
    Returns:
        TreeTemplate si existe, None si no existe
    """
    return TREE_TEMPLATES.get(template_id)

def get_all_tree_templates() -> Dict[str, TreeTemplate]:
    """Obtener todos los templates de árboles"""
    return TREE_TEMPLATES.copy()

def get_random_tree_template() -> TreeTemplate:
    """Obtener un template de árbol aleatorio según densidades"""
    import random
    templates = list(TREE_TEMPLATES.values())
    weights = [t.densidad for t in templates]
    
    # Normalizar pesos
    total_weight = sum(weights)
    if total_weight == 0:
        # Si no hay pesos, seleccionar aleatoriamente
        return random.choice(templates)
    
    normalized_weights = [w / total_weight for w in weights]
    return random.choices(templates, weights=normalized_weights)[0]

def list_tree_template_ids() -> List[str]:
    """Listar todos los IDs de templates de árboles disponibles"""
    return list(TREE_TEMPLATES.keys())
```

**Notas:**
- El registry centraliza todos los templates disponibles
- Permite descubrir templates dinámicamente
- Facilita agregar nuevos templates sin modificar código existente

---

### Paso 6: Crear BaseBuilder abstracto

**Descripción:**
Crear la clase base abstracta `BaseBuilder` que define la interfaz común para todos los builders.

**Archivos a modificar/crear:**
- `backend/src/database/builders/base.py` (nuevo)

**Detalles de implementación:**
```python
from abc import ABC, abstractmethod
from typing import List, Tuple, Dict, Any
from uuid import UUID
import asyncpg
from src.database.templates.base import BaseTemplate

class BaseBuilder(ABC):
    """Clase base abstracta para todos los builders de entidades"""
    
    def __init__(self, template: BaseTemplate):
        self.template = template
    
    @abstractmethod
    async def create_at_position(
        self,
        conn: asyncpg.Connection,
        dimension_id: UUID,
        x: int,
        y: int,
        z: int,
        **kwargs
    ) -> List[Tuple]:
        """
        Crear entidad en una posición específica
        
        Returns:
            Lista de tuplas para insertar en base de datos
        """
        pass
    
    @abstractmethod
    def get_particle_type_ids(self) -> Dict[str, str]:
        """
        Obtener IDs de tipos de partículas necesarios para esta entidad
        Debe retornar un dict con claves como 'tronco', 'hojas', 'cuerpo', etc.
        """
        pass
    
    def validate_position(self, x: int, y: int, z: int, max_x: int, max_y: int) -> bool:
        """Validar que la posición está dentro de los límites"""
        return 0 <= x < max_x and 0 <= y < max_y
```

**Notas:**
- Los builders se encargan de convertir templates en partículas para la BD
- Cada builder específico implementa la lógica de creación según su categoría

---

### Paso 7: Crear TreeBuilder específico

**Descripción:**
Crear `TreeBuilder` que extiende `BaseBuilder` e implementa la lógica de creación de árboles.

**Archivos a modificar/crear:**
- `backend/src/database/builders/tree_builder.py` (nuevo)

**Detalles de implementación:**
```python
from typing import List, Tuple, Dict
from uuid import UUID
import asyncpg
import json
from src.database.builders.base import BaseBuilder
from src.database.templates.trees.base import TreeTemplate

class TreeBuilder(BaseBuilder):
    """Builder para crear árboles usando TreeTemplate"""
    
    def __init__(self, template: TreeTemplate):
        if not isinstance(template, TreeTemplate):
            raise ValueError(f"TreeBuilder requiere TreeTemplate, recibió {type(template)}")
        super().__init__(template)
        self.template: TreeTemplate = template  # Type hint específico
    
    async def create_at_position(
        self,
        conn: asyncpg.Connection,
        dimension_id: UUID,
        x: int,
        y: int,
        z: int,
        madera_id: str = None,
        hojas_id: str = None,
        solido_id: str = None,
        **kwargs
    ) -> List[Tuple]:
        """
        Crear árbol en posición específica
        
        Args:
            conn: Conexión a la base de datos
            dimension_id: ID de la dimensión
            x, y, z: Posición donde crear el árbol
            madera_id: ID del tipo de partícula 'madera'
            hojas_id: ID del tipo de partícula 'hojas'
            solido_id: ID del estado de materia 'solido'
        
        Returns:
            Lista de tuplas (dimension_id, x, y, z, tipo_id, estado_id, cantidad, temp, energia, extraida, agrupacion_id, es_nucleo, propiedades)
        """
        if not all([madera_id, hojas_id, solido_id]):
            raise ValueError("Faltan IDs de tipos de partículas o estados de materia")
        
        particles = []
        altura_tronco = self.template.get_altura_aleatoria()
        
        # 1. Crear raíces
        posiciones_raices = self.template.get_posiciones_raices(x, y, z)
        for rx, ry, rz in posiciones_raices:
            particles.append((
                dimension_id, rx, ry, rz,
                madera_id, solido_id, 1.0, 18.0, 0.0, False,
                None, False, json.dumps(self.template.get_propiedades_particula('raiz'))
            ))
        
        # 2. Crear tronco
        posiciones_tronco = self.template.get_posiciones_tronco(x, y)
        for z_level in range(z, z + altura_tronco):
            for tx, ty in posiciones_tronco:
                particles.append((
                    dimension_id, tx, ty, z_level,
                    madera_id, solido_id, 1.0, 20.0, 0.0, False,
                    None, False, json.dumps(self.template.get_propiedades_particula('tronco'))
                ))
        
        # 3. Crear copa
        z_copa_base = z + altura_tronco
        posiciones_copa = self.template.get_posiciones_copa(x, y, z_copa_base)
        for cx, cy, cz in posiciones_copa:
            particles.append((
                dimension_id, cx, cy, cz,
                hojas_id, solido_id, 1.0, 22.0, 0.0, False,
                None, False, json.dumps(self.template.get_propiedades_particula('hojas'))
            ))
        
        return particles
    
    def get_particle_type_ids(self) -> Dict[str, str]:
        """Obtener IDs de tipos de partículas necesarios para árboles"""
        return {
            'madera': 'madera',
            'hojas': 'hojas',
            'solido': 'solido'
        }
```

**Notas:**
- Mover la lógica de creación de árboles de `seed_demo.py` a este builder
- El builder es reutilizable y puede usarse desde cualquier lugar
- Los IDs de tipos de partículas se pasan como parámetros para flexibilidad

---

### Paso 8: Crear EntityCreator genérico

**Descripción:**
Crear `EntityCreator` que actúa como factory y simplifica la creación de entidades usando builders.

**Archivos a modificar/crear:**
- `backend/src/database/creators/entity_creator.py` (nuevo)

**Detalles de implementación:**
```python
from typing import List, Tuple, Optional
from uuid import UUID
import asyncpg
from src.database.templates.base import BaseTemplate
from src.database.builders.base import BaseBuilder
from src.database.builders.tree_builder import TreeBuilder

class EntityCreator:
    """Creator genérico que simplifica la creación de entidades"""
    
    def __init__(self, conn: asyncpg.Connection, dimension_id: UUID):
        self.conn = conn
        self.dimension_id = dimension_id
        self._particle_type_cache = {}
        self._state_cache = {}
    
    async def _get_particle_type_id(self, nombre: str) -> str:
        """Obtener ID de tipo de partícula (con cache)"""
        if nombre not in self._particle_type_cache:
            tipo_id = await self.conn.fetchval(
                "SELECT id FROM juego_dioses.tipos_particulas WHERE nombre = $1",
                nombre
            )
            if not tipo_id:
                raise ValueError(f"Tipo de partícula '{nombre}' no encontrado")
            self._particle_type_cache[nombre] = tipo_id
        return self._particle_type_cache[nombre]
    
    async def _get_state_id(self, nombre: str) -> str:
        """Obtener ID de estado de materia (con cache)"""
        if nombre not in self._state_cache:
            state_id = await self.conn.fetchval(
                "SELECT id FROM juego_dioses.estados_materia WHERE nombre = $1",
                nombre
            )
            if not state_id:
                raise ValueError(f"Estado de materia '{nombre}' no encontrado")
            self._state_cache[nombre] = state_id
        return self._state_cache[nombre]
    
    def _get_builder(self, template: BaseTemplate) -> BaseBuilder:
        """Obtener builder apropiado según el template"""
        if template.categoria == 'tree':
            return TreeBuilder(template)
        # Futuro: elif template.categoria == 'plant': return PlantBuilder(template)
        # Futuro: elif template.categoria == 'animal': return AnimalBuilder(template)
        else:
            raise ValueError(f"No hay builder para categoría '{template.categoria}'")
    
    async def create_entity(
        self,
        template: BaseTemplate,
        x: int,
        y: int,
        z: int
    ) -> int:
        """
        Crear una entidad usando un template
        
        Returns:
            Número de partículas creadas
        """
        builder = self._get_builder(template)
        
        # Obtener IDs necesarios
        particle_types = builder.get_particle_type_ids()
        particle_type_ids = {}
        for key, nombre in particle_types.items():
            if key != 'solido':  # 'solido' es estado, no tipo
                particle_type_ids[key] = await self._get_particle_type_id(nombre)
        
        solido_id = await self._get_state_id('solido')
        
        # Crear partículas
        particles = await builder.create_at_position(
            self.conn,
            self.dimension_id,
            x, y, z,
            solido_id=solido_id,
            **particle_type_ids
        )
        
        # Insertar en batch
        if particles:
            await self.conn.executemany("""
                INSERT INTO juego_dioses.particulas
                (dimension_id, celda_x, celda_y, celda_z, tipo_particula_id, estado_materia_id,
                 cantidad, temperatura, energia, extraida, agrupacion_id, es_nucleo, propiedades)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13::jsonb)
                ON CONFLICT (dimension_id, celda_x, celda_y, celda_z) DO UPDATE
                SET tipo_particula_id = EXCLUDED.tipo_particula_id,
                    temperatura = EXCLUDED.temperatura,
                    propiedades = EXCLUDED.propiedades
            """, particles)
        
        return len(particles)
```

**Notas:**
- El creator simplifica la creación ocultando detalles de builders y tipos de partículas
- Usa cache para evitar consultas repetidas a la BD
- Fácil de extender para nuevas categorías

---

### Paso 9: Actualizar seed_demo.py para usar nuevo sistema

**Descripción:**
Refactorizar `seed_demo.py` para usar el nuevo sistema de templates, builders y creators en lugar de la lógica directa.

**Archivos a modificar/crear:**
- `backend/src/database/seed_demo.py`

**Detalles de implementación:**
```python
# Reemplazar imports
from src.database.templates.trees.registry import get_random_tree_template, get_tree_template
from src.database.creators.entity_creator import EntityCreator

# En seed_demo(), después de crear la dimensión:
# Reemplazar la lógica de creación de árboles con:

# Crear EntityCreator
creator = EntityCreator(conn, dimension_id)

# Generar posiciones de árboles
posiciones_arboles = []
templates_arboles = []
random.seed(42)

for x in range(0, max_x, espaciado_grilla):
    for y in range(0, max_y, espaciado_grilla):
        offset_x = random.randint(-1, 1)
        offset_y = random.randint(-1, 1)
        nx = x + offset_x
        ny = y + offset_y

        if 0 <= nx < max_x and 0 <= ny < max_y:
            if random.random() < 0.5:
                template = get_random_tree_template()
                posiciones_arboles.append((nx, ny))
                templates_arboles.append(template)

# Crear árboles usando creator
print("Creando árboles con nuevo sistema...")
stats_templates = {}
total_particulas = 0

for (arbol_x, arbol_y), template in zip(posiciones_arboles, templates_arboles):
    if template.nombre not in stats_templates:
        stats_templates[template.nombre] = 0
    stats_templates[template.nombre] += 1
    
    particulas_creadas = await creator.create_entity(template, arbol_x, arbol_y, 0)
    total_particulas += particulas_creadas

print(f"Árboles creados: {len(posiciones_arboles)}, {total_particulas} partículas")
```

**Notas:**
- Simplificar significativamente el código de seed_demo.py
- Mantener la misma funcionalidad pero con código más limpio
- Verificar que funciona igual que antes

---

### Paso 10: Crear documentación de cómo agregar nuevos tipos

**Descripción:**
Crear documentación clara que explique cómo agregar nuevos templates, builders y categorías.

**Archivos a modificar/crear:**
- `backend/src/database/templates/README.md` (nuevo)

**Detalles de implementación:**
```markdown
# Sistema de Templates

## Cómo Agregar un Nuevo Template de Árbol

1. Crear archivo `backend/src/database/templates/trees/nuevo_arbol.py`:

```python
from src.database.templates.trees.base import TreeTemplate

class NuevoArbolTemplate(TreeTemplate):
    def __init__(self):
        super().__init__(
            nombre='Nuevo Árbol',
            grosor_tronco=2,
            altura_min=10,
            altura_max=15,
            copa_tamano=3,
            copa_niveles=3,
            raiz_tamano=2,
            raiz_profundidad=2,
            densidad=0.15
        )
```

2. Registrar en `registry.py`:

```python
from src.database.templates.trees.nuevo_arbol import NuevoArbolTemplate

TREE_TEMPLATES['nuevo_arbol'] = NuevoArbolTemplate()
```

3. ¡Listo! El nuevo template está disponible.

## Cómo Agregar una Nueva Categoría (ej: Plantas)

1. Crear carpeta `templates/plants/`
2. Crear `base.py` con `PlantTemplate(BaseTemplate)`
3. Crear templates específicos
4. Crear `registry.py`
5. Crear `PlantBuilder(BaseBuilder)`
6. Actualizar `EntityCreator._get_builder()` para incluir plantas

[Documentación más detallada...]
```

**Notas:**
- La documentación debe ser clara y con ejemplos
- Debe explicar todos los pasos necesarios
- Debe incluir ejemplos de código

---

### Paso 11: Verificar compatibilidad y testing

**Descripción:**
Verificar que todo el código existente sigue funcionando y que el nuevo sistema funciona correctamente.

**Archivos a modificar/crear:**
- Ninguno (verificación)

**Detalles de implementación:**
1. Ejecutar seed demo y verificar que se crean árboles correctamente
2. Verificar que los árboles se ven igual en el frontend
3. Verificar que agregar un nuevo template funciona sin modificar código existente
4. Verificar que el registry funciona correctamente
5. Verificar que los builders crean partículas correctamente

**Notas:**
- Hacer pruebas exhaustivas
- Verificar que no se rompió nada
- Si hay problemas, corregirlos antes de continuar

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-005_pr-description_2025-12-05_08-26-57.md` en `/instructions/prs/`
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git

---

## Consideraciones Técnicas

### Performance
- El cache de IDs de tipos de partículas en EntityCreator mejora rendimiento
- Los builders pueden optimizarse para inserción en batch
- La estructura modular no afecta el rendimiento

### Seguridad
- Validación de tipos en builders previene errores
- Validación de posiciones previene crear entidades fuera de límites

### Casos Edge
- Templates inválidos: Deben validarse y lanzar errores claros
- Posiciones fuera de límites: Deben validarse antes de crear
- Tipos de partículas faltantes: Deben detectarse y reportarse claramente

### Compatibilidad
- Los cambios son internos, no afectan APIs
- El código existente debe seguir funcionando
- La migración es incremental y no rompe funcionalidad

## Patrones de Código a Usar

- **Backend (Python)**: 
  - ABC para clases abstractas
  - Type hints en todas las funciones
  - Docstrings en formato Google
  - Validación de tipos y parámetros

- **Estructura**: 
  - Separación por categoría y responsabilidad
  - Registry pattern para descubrimiento dinámico
  - Builder pattern para creación compleja
  - Factory pattern para selección de builders

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna (solo reorganización de código existente)

### Variables de Entorno (si aplica)
Ninguna

## Archivos Principales Involucrados

1. `backend/src/database/templates/base.py` - Clase base abstracta
2. `backend/src/database/templates/trees/base.py` - TreeTemplate base
3. `backend/src/database/templates/trees/roble.py` - Template específico
4. `backend/src/database/templates/trees/registry.py` - Registry de árboles
5. `backend/src/database/builders/base.py` - BaseBuilder
6. `backend/src/database/builders/tree_builder.py` - TreeBuilder
7. `backend/src/database/creators/entity_creator.py` - EntityCreator
8. `backend/src/database/seed_demo.py` - Refactorizado para usar nuevo sistema

## Testing

### Tests a Crear/Modificar
- Unit tests para cada template específico
- Unit tests para builders
- Unit tests para creators
- Integration tests para verificar que todo funciona junto

### Escenarios de Prueba
1. Crear árbol usando template específico (roble)
2. Crear árbol usando registry
3. Crear árbol usando EntityCreator
4. Verificar que seed demo funciona igual que antes
5. Agregar nuevo template y verificar que funciona sin modificar código existente

## Deployment

### Orden de Deployment
1. Backend: Rebuild Docker image y restart container
2. Verificar que seed demo funciona correctamente
3. Verificar que frontend renderiza correctamente
4. Verificar logs de Docker sin errores

### Verificación Post-Deployment
- [ ] Verificar que seed demo crea árboles correctamente
- [ ] Verificar que frontend renderiza árboles igual que antes
- [ ] Verificar que registry funciona correctamente
- [ ] Verificar que agregar nuevo template funciona
- [ ] Verificar logs de Docker sin errores

---

## Anexo: Práctica de Documentación con READMEs

### Práctica Establecida

**Cada carpeta/módulo debe tener su `README.md`** que explique:
- Qué es y qué contiene el módulo/carpeta
- Estructura de archivos y componentes principales
- Responsabilidades de cada componente
- Cómo usar el módulo (ejemplos de código)
- Referencias a READMEs de subcarpetas

### Mantenimiento de Documentación

**Cuando se modifica un módulo:**
1. **Actualizar el README del módulo/carpeta modificado**
2. **Verificar y actualizar READMEs padres si es necesario**
3. **Mantener documentación sincronizada con el código**

**Ejemplo:**
- Si se agrega un nuevo template en `templates/trees/`:
  - Actualizar `templates/trees/README.md` (si existe)
  - Actualizar `templates/README.md`
  - Verificar si `database/README.md` necesita actualización

### En Este Plan de Acción

**Pasos que requieren crear/actualizar READMEs:**
- **Paso 1**: Crear estructura de carpetas → No requiere READMEs aún
- **Paso 2-5**: Crear templates → Requiere `templates/README.md` y `templates/trees/README.md`
- **Paso 6-7**: Crear builders → Requiere `builders/README.md`
- **Paso 8**: Crear creators → Requiere `creators/README.md`
- **Paso 9**: Actualizar seed_demo → Verificar si `database/README.md` necesita actualización
- **Paso 10**: Crear documentación → Ya incluido explícitamente

**Verificación final:**
- [ ] `database/README.md` existe y está actualizado
- [ ] `templates/README.md` existe y está actualizado
- [ ] `templates/trees/README.md` existe (si aplica)
- [ ] `builders/README.md` existe y está actualizado
- [ ] `creators/README.md` existe y está actualizado
- [ ] Todos los READMEs tienen referencias cruzadas correctas

### Estructura de READMEs Esperada

```
database/
├── README.md              # Explica qué es database/, qué contiene, estructura
├── templates/
│   ├── README.md         # Explica sistema de templates, cómo agregar nuevos
│   └── trees/
│       └── README.md      # (Opcional) Explica templates de árboles específicamente
├── builders/
│   └── README.md         # Explica sistema de builders, flujo de ejecución
└── creators/
    └── README.md         # Explica sistema de creators, flujo de ejecución
```

### Contenido Mínimo de un README

Cada README debe incluir:
1. **Título y descripción**: Qué es el módulo/carpeta
2. **Estructura**: Lista de archivos/carpetas principales
3. **Componentes principales**: Qué hace cada componente
4. **Cómo usar**: Ejemplos de código prácticos
5. **Referencias**: Links a READMEs hijos o relacionados
6. **Mantenimiento**: Notas sobre cuándo actualizar este README

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

