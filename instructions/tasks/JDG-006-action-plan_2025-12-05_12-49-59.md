# JDG-006 - Componentización del Frontend y Sistema de Formas Geométricas

## Descripción de la Tarea

Refactorizar el frontend para una arquitectura modular y escalable, implementar sistema de formas geométricas almacenadas en base de datos, y preparar infraestructura para agrupaciones (implementación básica opcional).

**Comportamiento actual:**
- Frontend monolítico con lógica mezclada en `main.js` y `scene.js`
- Todas las partículas se renderizan como cubos (`BoxGeometry`)
- Formas geométricas hardcodeadas en el código del frontend
- No hay diferenciación visual entre tipos de entidades
- No se crean agrupaciones cuando se crean entidades (árboles)

**Comportamiento esperado:**
- Frontend modular con separación clara de responsabilidades
- Renderizadores especializados por tipo de entidad
- Formas geométricas definidas en base de datos (tipos de partículas y agrupaciones)
- Frontend interpreta formas desde BD y las renderiza según su capacidad
- Sistema preparado para agrupaciones (implementación básica opcional)

## Criterios de Aceptación

1. ✅ Existe estructura de carpetas modular (`core/`, `renderers/`, `components/`, `state/`, `utils/`, `api/`)
2. ✅ Renderizado genérico separado de renderizado especializado
3. ✅ Sistema de formas geométricas implementado (tipos de partículas con geometría en BD)
4. ✅ Frontend interpreta y renderiza formas desde BD
5. ✅ Al menos un renderizador especializado implementado (ej: `TreeRenderer`)
6. ✅ Sistema de gestión de estado centralizado implementado
7. ✅ Componentes UI reutilizables creados (al menos 2-3 ejemplos)
8. ✅ Separación clara de responsabilidades entre módulos
9. ✅ El frontend funciona igual que antes (mismo resultado visual)
10. ✅ Agregar nuevo tipo de renderizador solo requiere crear nuevo archivo
11. ✅ Documentación completa (READMEs en cada módulo)
12. ✅ Sistema preparado para agrupaciones (opcional: implementación básica)

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI) - Extender schemas y endpoints para formas geométricas
- [x] Frontend (Three.js) - Refactorización completa
- [x] Base de Datos (PostgreSQL) - Agregar campo `geometria_agrupacion` (opcional)
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg, Pydantic
- Frontend: HTML5, JavaScript ES6+, Three.js, OrbitControls
- Base de datos: PostgreSQL 16, JSONB
- Patrones de diseño: Strategy, Factory, Observer, Component, Registry

## Pasos de Implementación

### Paso 1: Extender Schemas Backend para Formas Geométricas

**Descripción:**
Extender los schemas Pydantic para soportar formas geométricas en tipos de partículas y agrupaciones.

**Archivos a modificar/crear:**
- `backend/src/models/schemas.py`
- `backend/src/models/README.md` (si no existe, crear)

**Detalles de implementación:**
```python
# Agregar a schemas.py

class GeometriaParametros(BaseModel):
    """
    Parámetros de geometría según tipo.
    IMPORTANTE: Estos parámetros son RELATIVOS a tamano_celda de la dimensión.
    Tamaño absoluto = parametro × tamano_celda × escala
    """
    # Box
    width: Optional[float] = Field(None, description="Ancho relativo a tamano_celda")
    height: Optional[float] = Field(None, description="Alto relativo a tamano_celda")
    depth: Optional[float] = Field(None, description="Profundidad relativa a tamano_celda")
    
    # Sphere
    radius: Optional[float] = Field(None, description="Radio relativo a tamano_celda")
    segments: Optional[int] = Field(default=16, ge=3, le=64)
    
    # Cylinder
    radiusTop: Optional[float] = Field(None, description="Radio superior relativo a tamano_celda")
    radiusBottom: Optional[float] = Field(None, description="Radio inferior relativo a tamano_celda")
    height: Optional[float] = Field(None, description="Altura relativa a tamano_celda")
    
    # Cone, Torus (similar)

class GeometriaVisual(BaseModel):
    """Definición de geometría visual"""
    tipo: Literal["box", "sphere", "cylinder", "cone", "torus", "custom"] = "box"
    parametros: GeometriaParametros = Field(default_factory=GeometriaParametros)

class VisualProperties(BaseModel):
    """Propiedades visuales extendidas"""
    modelo: Optional[str] = None  # Deprecated, usar geometria.tipo
    escala: float = Field(default=1.0, ge=0.1, le=10.0)
    geometria: Optional[GeometriaVisual] = None

# Extender EstilosParticula para incluir geometria
class EstilosParticula(BaseModel):
    """Estilos de partícula extendidos"""
    color_hex: Optional[str] = None
    color_rgb: Optional[List[int]] = None
    material: Optional[MaterialProperties] = None
    visual: Optional[VisualProperties] = None  # Ahora incluye geometria

# Para agrupaciones (opcional)
class GeometriaParte(BaseModel):
    """Geometría de una parte de una agrupación"""
    geometria: GeometriaVisual
    offset: Optional[Dict[str, float]] = Field(default_factory=lambda: {"x": 0, "y": 0, "z": 0})
    rotacion: Optional[Dict[str, float]] = Field(default_factory=lambda: {"x": 0, "y": 0, "z": 0})

class GeometriaAgrupacion(BaseModel):
    """Geometría completa de una agrupación"""
    tipo: str
    partes: Dict[str, GeometriaParte] = Field(default_factory=dict)
```

**Notas:**
- Los parámetros son relativos a `tamano_celda`, no tamaños absolutos
- Documentar claramente la relación: `Tamaño absoluto = parámetro × tamano_celda × escala`
- **⚠️ READMEs:** Actualizar `models/README.md` explicando los nuevos schemas

---

### Paso 2: Agregar Campo geometria_agrupacion a Base de Datos (Opcional)

**Descripción:**
Agregar campo `geometria_agrupacion` a la tabla `agrupaciones` para formas especializadas por agrupación.

**Archivos a modificar/crear:**
- `database/init/01-init-schema.sql` (o crear migración)
- `database/README.md` (actualizar)

**Detalles de implementación:**
```sql
-- Agregar campo a agrupaciones
ALTER TABLE juego_dioses.agrupaciones
ADD COLUMN IF NOT EXISTS geometria_agrupacion JSONB DEFAULT '{}'::jsonb;

COMMENT ON COLUMN juego_dioses.agrupaciones.geometria_agrupacion IS 
'Definición de geometría para la agrupación completa. Estructura:
{
  "tipo": "arbol|animal|construccion|...",
  "partes": {
    "parte_nombre": {
      "geometria": {
        "tipo": "box|sphere|cylinder|...",
        "parametros": {...}
      },
      "offset": {"x": 0, "y": 0, "z": 0},
      "rotacion": {"x": 0, "y": 0, "z": 0}
    }
  }
}';

CREATE INDEX IF NOT EXISTS idx_agrupaciones_geometria 
ON juego_dioses.agrupaciones USING GIN (geometria_agrupacion);
```

**Notas:**
- Este paso es opcional si no se implementan agrupaciones básicas ahora
- Si se omite, puede agregarse después sin romper funcionalidad
- **⚠️ READMEs:** Actualizar `database/README.md` documentando el nuevo campo

---

### Paso 3: Crear Estructura Base del Frontend Modular

**Descripción:**
Crear la estructura de carpetas modular del frontend según el análisis de arquitectura.

**Archivos a crear:**
- `frontend/src/core/` (carpeta)
- `frontend/src/renderers/` (carpeta)
- `frontend/src/components/` (carpeta)
- `frontend/src/state/` (carpeta)
- `frontend/src/utils/` (carpeta)
- `frontend/src/api/` (carpeta)
- `frontend/src/managers/` (carpeta)
- `frontend/src/core/__init__.js` (o archivos individuales)
- `frontend/src/renderers/__init__.js`
- `frontend/src/components/__init__.js`
- `frontend/src/state/__init__.js`
- `frontend/src/utils/__init__.js`
- `frontend/src/api/__init__.js`
- `frontend/src/managers/__init__.js`

**Detalles de implementación:**
```
frontend/src/
├── core/           # Núcleo de Three.js
├── renderers/      # Sistema de renderizadores
├── components/     # Componentes reutilizables
├── state/          # Gestión de estado
├── utils/          # Utilidades organizadas
├── api/            # Cliente API modular
└── managers/       # Gestores de alto nivel
```

**Notas:**
- Crear carpetas vacías con `__init__.js` o archivos placeholder
- **⚠️ READMEs:** Crear `frontend/src/README.md` explicando la nueva estructura modular
- **⚠️ READMEs:** Crear READMEs en cada carpeta nueva explicando su propósito

---

### Paso 4: Separar Core de Three.js (Escena, Cámara, Controles, Renderizador)

**Descripción:**
Extraer responsabilidades del núcleo de Three.js de `scene.js` a módulos separados.

**Archivos a modificar/crear:**
- `frontend/src/core/scene.js` - Escena base (configuración mínima)
- `frontend/src/core/camera.js` - Gestión de cámara
- `frontend/src/core/controls.js` - Controles de cámara (OrbitControls wrapper)
- `frontend/src/core/renderer.js` - Renderizador WebGL
- `frontend/src/core/lights.js` - Gestión de luces
- `frontend/src/core/helpers.js` - Helpers (grid, axes) con gestión dinámica
- `frontend/src/scene.js` - Refactorizar para usar módulos core
- `frontend/src/core/README.md`

**Detalles de implementación:**
```javascript
// core/camera.js
export class Camera {
    constructor(container) {
        const width = container.clientWidth;
        const height = container.clientHeight;
        this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        this.camera.position.set(15, 15, 15);
        this.camera.lookAt(0, 0, 0);
    }
    
    updateAspect(width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
    }
    
    // ... más métodos
}

// core/controls.js
export class Controls {
    constructor(camera, domElement) {
        this.controls = new OrbitControls(camera, domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        // ... configuración
    }
    
    update() {
        this.controls.update();
    }
    
    // ... más métodos
}

// core/renderer.js
export class Renderer {
    constructor(container) {
        const width = container.clientWidth;
        const height = container.clientHeight;
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(width, height);
        this.renderer.setClearColor(0x87CEEB);
        container.appendChild(this.renderer.domElement);
    }
    
    render(scene, camera) {
        this.renderer.render(scene, camera);
    }
    
    // ... más métodos
}
```

**Notas:**
- Mantener compatibilidad con código existente durante la migración
- **⚠️ READMEs:** Crear `core/README.md` explicando cada módulo y su responsabilidad

---

### Paso 5: Modularizar API Client

**Descripción:**
Separar el cliente API en módulos por recurso.

**Archivos a modificar/crear:**
- `frontend/src/api/client.js` - Cliente base con configuración
- `frontend/src/api/endpoints/dimensions.js` - Endpoints de dimensiones
- `frontend/src/api/endpoints/particles.js` - Endpoints de partículas
- `frontend/src/api/endpoints/agrupaciones.js` - Endpoints de agrupaciones
- `frontend/src/api/__init__.js` - Exportaciones centralizadas
- `frontend/src/api.js` - Refactorizar para usar nuevo API client
- `frontend/src/api/README.md`

**Detalles de implementación:**
```javascript
// api/client.js
export class ApiClient {
    constructor(baseUrl = '/api/v1') {
        this.baseUrl = baseUrl;
    }
    
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const response = await fetch(url, options);
        if (!response.ok) {
            throw new Error(`Error: ${response.statusText}`);
        }
        return await response.json();
    }
}

// api/endpoints/dimensions.js
import { ApiClient } from '../client.js';

export class DimensionsApi {
    constructor(client) {
        this.client = client;
    }
    
    async getDimensions() {
        return await this.client.request('/dimensions');
    }
    
    async getDimension(dimensionId) {
        return await this.client.request(`/dimensions/${dimensionId}`);
    }
}
```

**Notas:**
- Mantener compatibilidad con código existente
- **⚠️ READMEs:** Crear `api/README.md` explicando la estructura modular

---

### Paso 6: Crear Sistema de Renderizadores con Soporte de Formas Geométricas

**Descripción:**
Implementar sistema de renderizadores con registry de geometrías y soporte para formas desde BD.

**Archivos a crear:**
- `frontend/src/renderers/base-renderer.js` - Renderizador base abstracto
- `frontend/src/renderers/particle-renderer.js` - Renderizador genérico de partículas
- `frontend/src/renderers/tree-renderer.js` - Renderizador especializado para árboles
- `frontend/src/renderers/registry.js` - Registry de renderizadores
- `frontend/src/renderers/geometries/registry.js` - Registry de geometrías
- `frontend/src/renderers/README.md`

**Detalles de implementación:**
```javascript
// renderers/geometries/registry.js
export class GeometryRegistry {
    constructor() {
        this.geometries = new Map();
        this.registerDefaults();
    }
    
    registerDefaults() {
        // Box
        this.register('box', (params, cellSize) => {
            const scaled = this.scaleParams(params, cellSize);
            return new THREE.BoxGeometry(
                scaled.width || cellSize,
                scaled.height || cellSize,
                scaled.depth || cellSize
            );
        });
        
        // Sphere
        this.register('sphere', (params, cellSize) => {
            const scaled = this.scaleParams(params, cellSize);
            return new THREE.SphereGeometry(
                scaled.radius || cellSize * 0.5,
                scaled.segments || 16
            );
        });
        
        // Cylinder
        this.register('cylinder', (params, cellSize) => {
            const scaled = this.scaleParams(params, cellSize);
            return new THREE.CylinderGeometry(
                scaled.radiusTop || cellSize * 0.5,
                scaled.radiusBottom || cellSize * 0.5,
                scaled.height || cellSize,
                scaled.segments || 8
            );
        });
        
        // Cone, Torus (similar)
    }
    
    scaleParams(params, cellSize) {
        /**
         * Escalar parámetros relativos a tamaño absoluto
         * Tamaño absoluto = parametro × tamano_celda
         */
        const scaled = {...params};
        ['width', 'height', 'depth', 'radius', 'radiusTop', 'radiusBottom', 'tube', 'height'].forEach(key => {
            if (scaled[key] !== undefined) {
                scaled[key] *= cellSize;
            }
        });
        // NO escalar segments (número de divisiones)
        return scaled;
    }
    
    register(tipo, factory) {
        this.geometries.set(tipo, factory);
    }
    
    create(tipo, params, cellSize = 0.25) {
        const factory = this.geometries.get(tipo);
        if (!factory) {
            console.warn(`Geometría desconocida: ${tipo}, usando box`);
            return new THREE.BoxGeometry(cellSize, cellSize, cellSize);
        }
        return factory(params, cellSize);
    }
}

// renderers/base-renderer.js
export class BaseRenderer {
    constructor(geometryRegistry) {
        this.geometryRegistry = geometryRegistry;
    }
    
    getGeometry(particle, tipoEstilos, agrupacionGeometria, cellSize) {
        // 1. Verificar agrupación (si existe)
        if (particle.agrupacion_id && agrupacionGeometria) {
            const parte = particle.propiedades?.parte_entidad;
            if (parte && agrupacionGeometria.partes[parte]) {
                const geometriaDef = agrupacionGeometria.partes[parte].geometria;
                return this.geometryRegistry.create(
                    geometriaDef.tipo,
                    geometriaDef.parametros,
                    cellSize
                );
            }
        }
        
        // 2. Verificar tipo de partícula
        if (tipoEstilos?.visual?.geometria) {
            const geometriaDef = tipoEstilos.visual.geometria;
            return this.geometryRegistry.create(
                geometriaDef.tipo,
                geometriaDef.parametros,
                cellSize
            );
        }
        
        // 3. Default (box)
        return new THREE.BoxGeometry(cellSize, cellSize, cellSize);
    }
}

// renderers/particle-renderer.js
import { BaseRenderer } from './base-renderer.js';

export class ParticleRenderer extends BaseRenderer {
    constructor(geometryRegistry) {
        super(geometryRegistry);
        this.geometryCache = new Map();
    }
    
    renderParticles(particles, tiposEstilos, agrupacionesGeometria, cellSize, scene) {
        // Agrupar por tipo/material/geometría para instanced rendering
        const particlesByGeometry = new Map();
        
        particles.forEach(particle => {
            const estilo = tiposEstilos[particle.tipo];
            const agrupacionGeom = agrupacionesGeometria?.[particle.agrupacion_id];
            const geometry = this.getGeometry(particle, estilo, agrupacionGeom, cellSize);
            
            // Crear clave única para geometría+material
            const geometryKey = this.getGeometryKey(geometry, estilo);
            
            if (!particlesByGeometry.has(geometryKey)) {
                particlesByGeometry.set(geometryKey, {
                    geometry: geometry,
                    estilo: estilo,
                    particles: []
                });
            }
            
            particlesByGeometry.get(geometryKey).particles.push(particle);
        });
        
        // Crear instanced meshes para cada grupo
        // ... (lógica de instanced rendering)
    }
}
```

**Notas:**
- Los parámetros de geometría son relativos a `tamano_celda`
- Cachear geometrías para mejor performance
- **⚠️ READMEs:** Crear `renderers/README.md` explicando el sistema de renderizadores y geometrías

---

### Paso 7: Crear Managers (Viewport, Style, Entity)

**Descripción:**
Crear managers de alto nivel para gestionar viewport, estilos y entidades.

**Archivos a crear:**
- `frontend/src/managers/viewport-manager.js` - Gestión de viewport y carga de datos
- `frontend/src/managers/style-manager.js` - Gestión de cache de estilos
- `frontend/src/managers/entity-manager.js` - Gestión de entidades y renderizadores
- `frontend/src/managers/README.md`

**Detalles de implementación:**
```javascript
// managers/viewport-manager.js
export class ViewportManager {
    constructor(dimension, maxCells = 1000000) {
        this.dimension = dimension;
        this.maxCells = maxCells;
    }
    
    calculateViewport() {
        // Calcular viewport dinámicamente basado en límites del backend
        // Priorizar altura para árboles
        // ... (lógica de cálculo)
        return { x_min, x_max, y_min, y_max, z_min, z_max };
    }
}

// managers/style-manager.js
export class StyleManager {
    constructor() {
        this.styleCache = new Map();
    }
    
    cacheStyles(tiposEstilos) {
        tiposEstilos.forEach(tipo => {
            this.styleCache.set(tipo.nombre, tipo.estilos);
        });
    }
    
    getStyle(tipoNombre) {
        return this.styleCache.get(tipoNombre) || this.getDefaultStyle();
    }
}

// managers/entity-manager.js
export class EntityManager {
    constructor(rendererRegistry) {
        this.rendererRegistry = rendererRegistry;
    }
    
    selectRenderer(particle, tipoEstilos) {
        // Seleccionar renderizador apropiado según tipo de entidad
        // Por ahora, usar ParticleRenderer para todo
        // Futuro: TreeRenderer para árboles, etc.
        return this.rendererRegistry.get('particle');
    }
}
```

**Notas:**
- Managers coordinan múltiples sistemas
- **⚠️ READMEs:** Crear `managers/README.md` explicando cada manager y su responsabilidad

---

### Paso 8: Crear Sistema de Gestión de Estado

**Descripción:**
Implementar sistema de gestión de estado centralizado (custom store simple).

**Archivos a crear:**
- `frontend/src/state/store.js` - Store centralizado
- `frontend/src/state/actions.js` - Acciones para modificar estado
- `frontend/src/state/selectors.js` - Selectores de estado
- `frontend/src/state/README.md`

**Detalles de implementación:**
```javascript
// state/store.js
export class Store {
    constructor() {
        this.state = {
            currentDimension: null,
            currentParticles: [],
            viewport: null,
            loading: false,
            error: null
        };
        this.listeners = [];
    }
    
    getState() {
        return this.state;
    }
    
    setState(newState) {
        this.state = { ...this.state, ...newState };
        this.notifyListeners();
    }
    
    subscribe(listener) {
        this.listeners.push(listener);
        return () => {
            this.listeners = this.listeners.filter(l => l !== listener);
        };
    }
    
    notifyListeners() {
        this.listeners.forEach(listener => listener(this.state));
    }
}

// state/actions.js
export const actions = {
    setDimension: (store, dimension) => {
        store.setState({ currentDimension: dimension });
    },
    
    setParticles: (store, particles) => {
        store.setState({ currentParticles: particles });
    },
    
    setLoading: (store, loading) => {
        store.setState({ loading });
    }
};

// state/selectors.js
export const selectors = {
    getCurrentDimension: (state) => state.currentDimension,
    getCurrentParticles: (state) => state.currentParticles,
    isLoading: (state) => state.loading
};
```

**Notas:**
- Store simple custom (no requiere Redux)
- **⚠️ READMEs:** Crear `state/README.md` explicando el sistema de estado

---

### Paso 9: Crear Componentes UI Reutilizables

**Descripción:**
Componentizar UI en componentes reutilizables.

**Archivos a crear:**
- `frontend/src/components/ui/button.js`
- `frontend/src/components/ui/panel.js`
- `frontend/src/components/ui/loading.js`
- `frontend/src/components/ui/info-panel.js`
- `frontend/src/components/README.md`

**Detalles de implementación:**
```javascript
// components/ui/panel.js
export class Panel {
    constructor(options) {
        this.title = options.title;
        this.content = options.content;
        this.element = null;
    }
    
    render(container) {
        this.element = document.createElement('div');
        this.element.className = 'panel';
        this.element.innerHTML = `
            <h3>${this.title}</h3>
            <div class="panel-content">${this.content}</div>
        `;
        container.appendChild(this.element);
    }
    
    update(content) {
        if (this.element) {
            const contentEl = this.element.querySelector('.panel-content');
            contentEl.textContent = content;
        }
    }
    
    destroy() {
        if (this.element) {
            this.element.remove();
        }
    }
}
```

**Notas:**
- Componentes simples sin framework
- **⚠️ READMEs:** Crear `components/README.md` explicando los componentes disponibles

---

### Paso 10: Organizar Utilidades

**Descripción:**
Extraer funciones de utilidad de `scene.js` a módulos organizados.

**Archivos a crear:**
- `frontend/src/utils/colors.js` - Utilidades de colores
- `frontend/src/utils/geometry.js` - Utilidades de geometría
- `frontend/src/utils/math.js` - Utilidades matemáticas
- `frontend/src/utils/helpers.js` - Helpers generales
- `frontend/src/utils/README.md`

**Detalles de implementación:**
```javascript
// utils/colors.js
export function increaseBrightness(color, multiplier) {
    // ... lógica existente de scene.js
}

export function parseColor(colorHex) {
    // ... lógica de parsing
}

// utils/geometry.js
export function calculateBoundingBox(particles) {
    // ... cálculos de bounding box
}

// utils/math.js
export function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
```

**Notas:**
- Mover funciones de `scene.js` a módulos apropiados
- **⚠️ READMEs:** Crear `utils/README.md` explicando las utilidades disponibles

---

### Paso 11: Crear App.js y Refactorizar main.js

**Descripción:**
Crear `app.js` para orquestación y simplificar `main.js` a punto de entrada mínimo.

**Archivos a modificar/crear:**
- `frontend/src/app.js` - Aplicación principal (orquestación)
- `frontend/src/main.js` - Refactorizar para ser punto de entrada mínimo

**Detalles de implementación:**
```javascript
// app.js
import { Store } from './state/store.js';
import { ViewportManager } from './managers/viewport-manager.js';
import { StyleManager } from './managers/style-manager.js';
import { EntityManager } from './managers/entity-manager.js';
import { DimensionsApi, ParticlesApi } from './api/index.js';
import { Scene3D } from './core/scene.js';
import { ParticleRenderer } from './renderers/particle-renderer.js';
import { GeometryRegistry } from './renderers/geometries/registry.js';

export class App {
    constructor(container) {
        this.container = container;
        this.store = new Store();
        this.viewportManager = new ViewportManager();
        this.styleManager = new StyleManager();
        this.geometryRegistry = new GeometryRegistry();
        this.entityManager = new EntityManager();
        
        // Inicializar API
        const apiClient = new ApiClient();
        this.dimensionsApi = new DimensionsApi(apiClient);
        this.particlesApi = new ParticlesApi(apiClient);
        
        // Inicializar escena
        this.scene = new Scene3D(container);
    }
    
    async loadDemo() {
        // Orquestar carga de demo
        // 1. Obtener dimensiones
        // 2. Calcular viewport
        // 3. Cargar partículas y tipos
        // 4. Cachear estilos
        // 5. Renderizar
    }
}

// main.js (simplificado)
import { App } from './app.js';

const container = document.getElementById('canvas-container');
const app = new App(container);

// Cargar demo al iniciar
app.loadDemo();
```

**Notas:**
- `main.js` solo inicializa la app
- `app.js` contiene toda la lógica de orquestación
- **⚠️ READMEs:** Actualizar `frontend/src/README.md` con el nuevo flujo

---

### Paso 12: Actualizar Backend para Incluir Geometría en Respuestas

**Descripción:**
Modificar endpoints del backend para incluir información de geometría en las respuestas de tipos de partículas.

**Archivos a modificar:**
- `backend/src/api/routes/particles.py` - Incluir `estilos.visual.geometria` en respuesta
- `backend/src/models/schemas.py` - Ya extendido en Paso 1

**Detalles de implementación:**
```python
# En particles.py, la query ya incluye estilos
# Solo asegurarse de que se retorna correctamente

rows = await conn.fetch("""
    SELECT 
        p.id,
        p.celda_x,
        p.celda_y,
        p.celda_z,
        tp.nombre as tipo_nombre,
        tp.estilos as tipo_estilos,  -- Ya incluye geometria si está definida
        em.nombre as estado_nombre
    FROM juego_dioses.particulas p
    JOIN juego_dioses.tipos_particulas tp ON p.tipo_particula_id = tp.id
    JOIN juego_dioses.estados_materia em ON p.estado_materia_id = em.id
    WHERE p.dimension_id = $1
      AND p.celda_x BETWEEN $2 AND $3
      -- ... resto de condiciones
""", dimension_id, x_min, x_max, y_min, y_max, z_min, z_max)

# El schema ParticleResponse ya incluye tipo_estilos
# que contiene visual.geometria si está definida
```

**Notas:**
- La estructura ya existe, solo verificar que se retorna correctamente
- **⚠️ READMEs:** Actualizar documentación de API si es necesario

---

### Paso 13: Actualizar Tipos de Partículas en BD con Formas Geométricas

**Descripción:**
Actualizar tipos de partículas existentes en la BD para incluir formas geométricas (opcional, para testing).

**Archivos a modificar/crear:**
- `database/init/02-seed-data.sql` (o script de migración)
- Script SQL para actualizar tipos existentes

**Detalles de implementación:**
```sql
-- Ejemplo: Actualizar tipo "madera" con forma cilíndrica
UPDATE juego_dioses.tipos_particulas 
SET estilos = jsonb_set(
    COALESCE(estilos, '{}'::jsonb),
    '{visual,geometria}',
    '{
        "tipo": "cylinder",
        "parametros": {
            "radiusTop": 0.4,
            "radiusBottom": 0.5,
            "height": 1.0,
            "segments": 8
        }
    }'::jsonb
)
WHERE nombre = 'madera';

-- Ejemplo: Actualizar tipo "hojas" con forma esférica
UPDATE juego_dioses.tipos_particulas 
SET estilos = jsonb_set(
    COALESCE(estilos, '{}'::jsonb),
    '{visual,geometria}',
    '{
        "tipo": "sphere",
        "parametros": {
            "radius": 0.5,
            "segments": 16
        }
    }'::jsonb
)
WHERE nombre = 'hojas';
```

**Notas:**
- Este paso es opcional, solo para testing
- Los tipos pueden actualizarse después sin romper funcionalidad
- **⚠️ READMEs:** Documentar en `database/README.md` cómo actualizar formas geométricas

---

### Paso 14: Implementar Agrupaciones Básicas en Backend (Opcional)

**Descripción:**
Implementar creación básica de agrupaciones cuando se crean entidades (árboles). Este paso es opcional según la decisión del análisis de agrupaciones.

**Archivos a modificar:**
- `backend/src/database/builders/base.py` - Agregar métodos abstractos para agrupaciones
- `backend/src/database/builders/tree_builder.py` - Implementar creación de agrupaciones
- `backend/src/database/creators/entity_creator.py` - Gestionar creación de agrupaciones

**Detalles de implementación:**
```python
# builders/base.py
@abstractmethod
async def create_agrupacion(
    self,
    conn: asyncpg.Connection,
    dimension_id: UUID,
    x: int,
    y: int,
    z: int
) -> UUID:
    """Crear agrupación para esta entidad. Retorna UUID de agrupación."""
    pass

@abstractmethod
def get_agrupacion_metadata(self) -> Dict[str, Any]:
    """Obtener metadata para crear agrupación (nombre, tipo, especie, etc.)"""
    pass

# builders/tree_builder.py
async def create_agrupacion(self, conn, dimension_id, x, y, z):
    metadata = self.get_agrupacion_metadata()
    agrupacion_id = await conn.fetchval("""
        INSERT INTO juego_dioses.agrupaciones
        (dimension_id, nombre, tipo, especie, posicion_x, posicion_y, posicion_z)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id
    """, dimension_id, metadata['nombre'], metadata['tipo'], 
        metadata.get('especie'), x, y, z)
    return agrupacion_id

def get_agrupacion_metadata(self):
    return {
        'nombre': f"{self.template.nombre} #{random.randint(1000, 9999)}",
        'tipo': 'arbol',
        'especie': self.template.nombre.lower()
    }

# Modificar create_at_position para aceptar agrupacion_id
async def create_at_position(
    self,
    conn: asyncpg.Connection,
    dimension_id: UUID,
    x: int,
    y: int,
    z: int,
    agrupacion_id: UUID = None,  # NUEVO
    # ... resto de parámetros
):
    # Asignar agrupacion_id a todas las partículas
    particles.append((
        dimension_id, rx, ry, rz,
        madera_id, solido_id, 1.0, 18.0, 0.0, False,
        agrupacion_id, False, json.dumps({...})  # agrupacion_id asignado
    ))
```

**Notas:**
- Este paso es opcional según decisión del análisis
- Si se implementa, seguir recomendación de "Nivel 2: Agrupaciones Básicas"
- **⚠️ READMEs:** Actualizar `builders/README.md` y `creators/README.md` con información de agrupaciones

---

### Paso 15: Verificar y Probar Implementación

**Descripción:**
Verificar que toda la implementación funciona correctamente y que el frontend renderiza correctamente con las nuevas formas geométricas.

**Archivos a verificar:**
- Todos los archivos creados/modificados
- Frontend en navegador
- Backend en logs

**Pasos de verificación:**
1. Levantar Docker: `docker-compose up -d`
2. Verificar que el frontend carga correctamente
3. Verificar que las partículas se renderizan con formas correctas
4. Verificar que no hay errores en consola
5. Verificar que el rendimiento es similar o mejor que antes
6. Verificar que los controles de cámara funcionan
7. Verificar que el viewport dinámico funciona

**Notas:**
- Si hay errores, corregirlos antes de continuar
- Verificar que la documentación está completa

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-006_pr-description_[FECHA-HORA].md` en `/instructions/prs/`
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git

---

## Consideraciones Técnicas

### Performance
- Mantener instanced rendering para partículas
- Cachear geometrías para evitar recrearlas
- Optimizar consultas de viewport
- Considerar LOD (Level of Detail) para entidades lejanas (futuro)

### Seguridad
- Validar parámetros de geometría en backend (Pydantic)
- Sanitizar valores de parámetros (rangos válidos)
- Validar que tipos de geometría son permitidos

### Casos Edge
- Partículas sin geometría definida (usar default: box)
- Geometrías desconocidas (fallback a box)
- Parámetros inválidos (usar valores por defecto)
- Viewport vacío o sin partículas
- Agrupaciones sin geometría (usar geometría del tipo)

### Compatibilidad
- Partículas existentes sin geometría siguen funcionando (default: box)
- Frontend antiguo puede seguir funcionando (ignora geometría si no la entiende)
- No rompe funcionalidad existente

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Clases ES6 para organización
  - Registry pattern para geometrías y renderizadores
  - Strategy pattern para renderizadores especializados
  - Factory pattern para creación de geometrías
  - Observer pattern para gestión de estado

- **Backend (FastAPI)**: 
  - Schemas Pydantic para validación
  - Validación de parámetros de geometría
  - Valores por defecto si parámetros inválidos

## Dependencias

### Nuevas Dependencias
No se requieren nuevas dependencias. Todo se implementa con tecnologías existentes.

### Variables de Entorno
No se requieren nuevas variables de entorno.

## Archivos Principales Involucrados

1. `frontend/src/app.js` - Aplicación principal (NUEVO)
2. `frontend/src/core/*.js` - Módulos core de Three.js (NUEVOS)
3. `frontend/src/renderers/*.js` - Sistema de renderizadores (NUEVOS)
4. `frontend/src/managers/*.js` - Managers de alto nivel (NUEVOS)
5. `frontend/src/state/*.js` - Sistema de estado (NUEVOS)
6. `frontend/src/api/*.js` - API client modular (NUEVOS)
7. `backend/src/models/schemas.py` - Schemas extendidos para geometrías
8. `database/init/01-init-schema.sql` - Campo geometria_agrupacion (opcional)

## Testing

### Escenarios de Prueba
1. Frontend carga correctamente con nueva estructura
2. Partículas se renderizan con formas geométricas desde BD
3. Geometrías desconocidas usan fallback (box)
4. Parámetros inválidos usan valores por defecto
5. Instanced rendering funciona correctamente
6. Controles de cámara funcionan
7. Viewport dinámico funciona
8. Performance similar o mejor que antes

### Casos Edge a Considerar
- Partículas sin geometría definida
- Geometrías desconocidas
- Parámetros fuera de rango
- Viewport vacío
- Agrupaciones sin geometría

## Deployment

### Orden de Deployment
1. Backend: Rebuild Docker image y restart container
2. Frontend: Actualizar archivos estáticos
3. Base de datos: Ejecutar migración (si se agregó campo geometria_agrupacion)
4. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar frontend en navegador
- [ ] Verificar que partículas se renderizan correctamente
- [ ] Verificar que formas geométricas se aplican correctamente
- [ ] Verificar logs de Docker
- [ ] Verificar que no hay errores en consola
- [ ] Verificar performance

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

