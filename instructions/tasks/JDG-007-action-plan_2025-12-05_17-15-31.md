# JDG-007 - Optimización de Rendimiento del Frontend (FPS Bajo)

## Descripción de la Tarea

Implementar optimizaciones de rendimiento en el frontend para alcanzar 60 FPS estables en terrenos grandes (40x40m con ~400k partículas). El sistema actual renderiza todas las partículas del viewport sin filtrado, lo que causa FPS muy bajos.

**Comportamiento actual:**
- Se renderizan todas las partículas del viewport (~400k), incluso las fuera del campo de visión
- Ordenamiento costoso múltiple (O(n log n) varias veces)
- Sin Level of Detail (LOD): partículas lejanas con mismo detalle que cercanas
- Múltiples draw calls innecesarios
- FPS muy bajo (objetivo: 60 FPS)

**Comportamiento esperado:**
- 60 FPS estables en demo 40x40m (~400k partículas)
- Frustum culling: solo renderizar partículas visibles por la cámara
- LOD básico: reducir detalle de partículas lejanas
- Ordenamiento optimizado: una sola vez con algoritmo eficiente
- Reducción de draw calls en al menos 50%
- Profiling integrado para monitorear métricas

## Criterios de Aceptación

1. ❌ FPS mínimo de 60 en demo 40x40m (~400k partículas) - **OBJETIVO PRINCIPAL**
2. ❌ FPS mínimo de 60 en demo 20x20m (~100k partículas)
3. ❌ Frustum culling implementado: solo se renderizan partículas visibles por la cámara
4. ❌ LOD básico implementado: partículas lejanas usan geometrías simplificadas
5. ❌ Reducción de draw calls: menos instanced meshes creados (objetivo: reducir en al menos 50%)
6. ❌ Optimización de ordenamiento: ordenamiento más eficiente o reducido
7. ❌ Geometrías optimizadas: esferas con menos segments cuando están lejos
8. ❌ Sin degradación visual significativa: la calidad visual se mantiene aceptable
9. ❌ Performance profiling: se puede medir FPS y draw calls antes/después
10. ❌ Optimizaciones adicionales si es necesario: occlusion culling básico, chunking espacial, o reducción de partículas renderizadas

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI) - No afectado
- [x] Frontend (Three.js) - Principalmente afectado
- [ ] Base de Datos (PostgreSQL) - No afectado
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js
- Three.js: WebGLRenderer, InstancedMesh, Frustum, OrbitControls
- Posiblemente: Web Workers (para cálculos pesados en background)

## Pasos de Implementación

### Paso 1: Crear Utilidades de Culling

**Descripción:**
Crear módulo de utilidades para frustum culling que filtre partículas fuera del campo de visión de la cámara. Este es el primer paso crítico para reducir partículas renderizadas.

**Archivos a modificar/crear:**
- `frontend/src/utils/culling.js` (nuevo)
- `frontend/src/utils/__init__.js` (actualizar para exportar)

**Detalles de implementación:**
```javascript
/**
 * Utilidades para culling de partículas
 */
import * as THREE from 'three';

/**
 * Filtrar partículas visibles usando frustum culling
 * @param {Array} particles - Array de partículas con celda_x, celda_y, celda_z
 * @param {THREE.Camera} camera - Cámara Three.js
 * @param {number} cellSize - Tamaño de celda en metros
 * @returns {Array} - Array de partículas visibles
 */
export function frustumCull(particles, camera, cellSize) {
    const frustum = new THREE.Frustum();
    const matrix = new THREE.Matrix4().multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
    );
    frustum.setFromProjectionMatrix(matrix);
    
    return particles.filter(particle => {
        // Convertir posición de celda a posición 3D
        const position = new THREE.Vector3(
            particle.celda_x * cellSize,
            particle.celda_y * cellSize,
            particle.celda_z * cellSize
        );
        
        // Crear bounding box pequeño para la partícula
        const box = new THREE.Box3(
            position.clone().subScalar(cellSize * 0.5),
            position.clone().addScalar(cellSize * 0.5)
        );
        
        return frustum.intersectsBox(box);
    });
}

/**
 * Cache de frustum para evitar recalcular si cámara no se mueve
 */
export class FrustumCache {
    constructor() {
        this.lastCameraMatrix = null;
        this.cachedResult = null;
    }
    
    /**
     * Obtener partículas visibles con cache
     * @param {Array} particles - Array de partículas
     * @param {THREE.Camera} camera - Cámara Three.js
     * @param {number} cellSize - Tamaño de celda
     * @returns {Array} - Partículas visibles
     */
    getVisible(particles, camera, cellSize) {
        const currentMatrix = camera.matrixWorldInverse.clone();
        
        // Verificar si cámara se movió
        if (this.lastCameraMatrix && 
            this.lastCameraMatrix.equals(currentMatrix) &&
            this.cachedResult) {
            return this.cachedResult;
        }
        
        // Recalcular
        this.lastCameraMatrix = currentMatrix;
        this.cachedResult = frustumCull(particles, camera, cellSize);
        return this.cachedResult;
    }
    
    /**
     * Invalidar cache
     */
    invalidate() {
        this.lastCameraMatrix = null;
        this.cachedResult = null;
    }
}
```

**Notas:**
- Usar `THREE.Frustum` y `THREE.Box3` para cálculos eficientes
- Cachear resultados si cámara no se mueve
- Invalidar cache cuando cámara se mueve
- **⚠️ READMEs:** Actualizar `frontend/src/utils/README.md` si existe, o crear uno explicando las utilidades de culling

**Recursos útiles:**
- Three.js Frustum: https://threejs.org/docs/#api/en/math/Frustum
- Three.js Box3: https://threejs.org/docs/#api/en/math/Box3

---

### Paso 2: Exponer Frustum en Core Camera

**Descripción:**
Modificar el módulo de cámara para exponer el frustum y facilitar el acceso desde otros módulos.

**Archivos a modificar/crear:**
- `frontend/src/core/camera.js` (modificar)

**Detalles de implementación:**
```javascript
// Agregar método para obtener frustum
getFrustum() {
    const frustum = new THREE.Frustum();
    const matrix = new THREE.Matrix4().multiplyMatrices(
        this.camera.projectionMatrix,
        this.camera.matrixWorldInverse
    );
    frustum.setFromProjectionMatrix(matrix);
    return frustum;
}

// Agregar método para verificar si cámara se movió
hasCameraMoved() {
    // Comparar matrixWorldInverse con última conocida
    // Retornar true si cambió
}
```

**Notas:**
- Mantener API existente de `Camera`
- Agregar métodos nuevos sin romper compatibilidad
- **⚠️ READMEs:** Actualizar `frontend/src/core/README.md` si existe

---

### Paso 3: Integrar Frustum Culling en ParticleRenderer

**Descripción:**
Modificar `ParticleRenderer` para aplicar frustum culling antes de ordenar y renderizar partículas. Esto reducirá significativamente el número de partículas procesadas.

**Archivos a modificar/crear:**
- `frontend/src/renderers/particle-renderer.js` (modificar)

**Detalles de implementación:**
```javascript
import { FrustumCache } from '../utils/culling.js';

export class ParticleRenderer extends BaseRenderer {
    constructor(geometryRegistry) {
        super(geometryRegistry);
        this.frustumCache = new FrustumCache();
        this.enableFrustumCulling = true; // Configurable
    }
    
    renderParticles(particles, tiposEstilos, agrupacionesGeometria, cellSize, scene) {
        // Aplicar frustum culling si está habilitado
        let particlesToRender = particles;
        if (this.enableFrustumCulling && scene.camera) {
            const camera = scene.camera; // Obtener cámara de la escena
            particlesToRender = this.frustumCache.getVisible(
                particles,
                camera,
                cellSize
            );
            
            // Log para debugging (remover en producción)
            console.log(`Frustum culling: ${particles.length} -> ${particlesToRender.length} partículas`);
        }
        
        // Continuar con ordenamiento y renderizado usando particlesToRender
        // ... resto del código existente ...
    }
}
```

**Notas:**
- Aplicar frustum culling ANTES de ordenar (reduce partículas a ordenar)
- Hacer frustum culling configurable (poder desactivarlo para debugging)
- Medir mejora de rendimiento (objetivo: 50-80% menos partículas renderizadas)
- **⚠️ READMEs:** Actualizar `frontend/src/renderers/README.md` si existe

**Recursos útiles:**
- Verificar que `scene.camera` esté disponible o pasar cámara como parámetro adicional

---

### Paso 4: Crear LOD Manager

**Descripción:**
Crear módulo para gestionar Level of Detail (LOD), reduciendo el detalle de partículas lejanas según su distancia a la cámara.

**Archivos a modificar/crear:**
- `frontend/src/renderers/optimizations/lod-manager.js` (nuevo)
- `frontend/src/renderers/optimizations/__init__.js` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Gestor de Level of Detail (LOD) para partículas
 */
import * as THREE from 'three';

export class LODManager {
    constructor(geometryRegistry) {
        this.geometryRegistry = geometryRegistry;
        this.lodCache = new Map(); // Cache de geometrías LOD
        
        // Umbrales de distancia para cada nivel LOD (en metros)
        this.distanceThresholds = {
            high: 10,    // < 10m: detalle alto
            medium: 30,  // 10-30m: detalle medio
            low: 100     // > 30m: detalle bajo
        };
    }
    
    /**
     * Obtener nivel LOD según distancia
     * @param {number} distance - Distancia en metros
     * @returns {string} - Nivel LOD: 'high', 'medium', 'low'
     */
    getLODLevel(distance) {
        if (distance < this.distanceThresholds.high) {
            return 'high';
        } else if (distance < this.distanceThresholds.medium) {
            return 'medium';
        } else {
            return 'low';
        }
    }
    
    /**
     * Aplicar LOD a partículas: calcular distancias y agregar metadata LOD
     * @param {Array} particles - Array de partículas
     * @param {THREE.Vector3} cameraPosition - Posición de la cámara
     * @param {number} cellSize - Tamaño de celda en metros
     * @returns {Array} - Partículas con metadata LOD
     */
    applyLOD(particles, cameraPosition, cellSize) {
        return particles.map(particle => {
            // Calcular distancia al cuadrado (evitar sqrt para performance)
            const particlePos = new THREE.Vector3(
                particle.celda_x * cellSize,
                particle.celda_y * cellSize,
                particle.celda_z * cellSize
            );
            
            const distanceSq = particlePos.distanceToSquared(cameraPosition);
            const distance = Math.sqrt(distanceSq); // Solo calcular sqrt una vez
            
            const lodLevel = this.getLODLevel(distance);
            
            return {
                ...particle,
                _lodLevel: lodLevel,
                _distance: distance
            };
        });
    }
    
    /**
     * Obtener parámetros LOD para una geometría según nivel
     * @param {string} geometryType - Tipo de geometría
     * @param {Object} originalParams - Parámetros originales
     * @param {string} lodLevel - Nivel LOD
     * @returns {Object} - Parámetros modificados para LOD
     */
    getLODParams(geometryType, originalParams, lodLevel) {
        if (lodLevel === 'high') {
            return originalParams; // Sin cambios
        }
        
        const lodParams = { ...originalParams };
        
        // Reducir segments según nivel LOD
        if (geometryType === 'sphere') {
            if (lodLevel === 'medium') {
                lodParams.segments = Math.max(8, Math.floor((originalParams.segments || 16) * 0.5));
            } else if (lodLevel === 'low') {
                lodParams.segments = Math.max(4, Math.floor((originalParams.segments || 16) * 0.25));
            }
        } else if (geometryType === 'cylinder') {
            if (lodLevel === 'medium') {
                lodParams.segments = Math.max(4, Math.floor((originalParams.segments || 8) * 0.5));
            } else if (lodLevel === 'low') {
                lodParams.segments = Math.max(3, Math.floor((originalParams.segments || 8) * 0.25));
            }
        }
        // Box, cone, torus: reducir segments si existen
        
        return lodParams;
    }
}
```

**Notas:**
- Usar distancia al cuadrado para cálculos (evitar sqrt hasta el final)
- Cachear geometrías LOD para reutilización
- Definir umbrales de distancia configurables
- **⚠️ READMEs:** Crear `frontend/src/renderers/optimizations/README.md` explicando el sistema de optimizaciones

**Recursos útiles:**
- Three.js Vector3: https://threejs.org/docs/#api/en/math/Vector3

---

### Paso 5: Crear Geometry Cache para LOD

**Descripción:**
Crear sistema de cache para geometrías LOD, evitando recrear geometrías con los mismos parámetros.

**Archivos a modificar/crear:**
- `frontend/src/managers/geometry-cache.js` (nuevo)
- `frontend/src/managers/__init__.js` (actualizar)

**Detalles de implementación:**
```javascript
/**
 * Cache de geometrías LOD para reutilización
 */
import * as THREE from 'three';

export class GeometryCache {
    constructor(geometryRegistry) {
        this.geometryRegistry = geometryRegistry;
        this.cache = new Map(); // key -> THREE.BufferGeometry
    }
    
    /**
     * Obtener o crear geometría LOD
     * @param {string} geometryType - Tipo de geometría
     * @param {Object} params - Parámetros
     * @param {string} lodLevel - Nivel LOD
     * @param {number} cellSize - Tamaño de celda
     * @returns {THREE.BufferGeometry} - Geometría (cached o nueva)
     */
    getGeometry(geometryType, params, lodLevel, cellSize) {
        const key = this.getCacheKey(geometryType, params, lodLevel);
        
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        // Crear nueva geometría
        const lodParams = this.getLODParams(geometryType, params, lodLevel);
        const geometry = this.geometryRegistry.create(geometryType, lodParams, cellSize);
        
        // Cachear
        this.cache.set(key, geometry);
        return geometry;
    }
    
    /**
     * Generar clave de cache
     */
    getCacheKey(geometryType, params, lodLevel) {
        const paramsStr = JSON.stringify(params);
        return `${geometryType}_${lodLevel}_${paramsStr}`;
    }
    
    /**
     * Obtener parámetros LOD (similar a LODManager)
     */
    getLODParams(geometryType, originalParams, lodLevel) {
        // ... implementar lógica similar a LODManager ...
    }
    
    /**
     * Limpiar cache
     */
    clear() {
        this.cache.forEach(geometry => geometry.dispose());
        this.cache.clear();
    }
}
```

**Notas:**
- Cachear geometrías por tipo + parámetros + nivel LOD
- Disposar geometrías al limpiar cache
- **⚠️ READMEs:** Actualizar `frontend/src/managers/README.md` si existe

---

### Paso 6: Integrar LOD en ParticleRenderer

**Descripción:**
Modificar `ParticleRenderer` para usar LOD Manager y Geometry Cache, aplicando diferentes niveles de detalle según distancia a la cámara.

**Archivos a modificar/crear:**
- `frontend/src/renderers/particle-renderer.js` (modificar)

**Detalles de implementación:**
```javascript
import { LODManager } from './optimizations/lod-manager.js';
import { GeometryCache } from '../managers/geometry-cache.js';

export class ParticleRenderer extends BaseRenderer {
    constructor(geometryRegistry) {
        super(geometryRegistry);
        this.frustumCache = new FrustumCache();
        this.lodManager = new LODManager(geometryRegistry);
        this.geometryCache = new GeometryCache(geometryRegistry);
        this.enableLOD = true; // Configurable
    }
    
    renderParticles(particles, tiposEstilos, agrupacionesGeometria, cellSize, scene) {
        // 1. Frustum culling
        let particlesToRender = particles;
        if (this.enableFrustumCulling && scene.camera) {
            particlesToRender = this.frustumCache.getVisible(
                particlesToRender,
                scene.camera,
                cellSize
            );
        }
        
        // 2. Aplicar LOD
        if (this.enableLOD && scene.camera) {
            const cameraPosition = scene.camera.position;
            particlesToRender = this.lodManager.applyLOD(
                particlesToRender,
                cameraPosition,
                cellSize
            );
        }
        
        // 3. Ordenar (una sola vez)
        const sortedParticles = [...particlesToRender].sort((a, b) => {
            return b.celda_z - a.celda_z;
        });
        
        // 4. Agrupar por geometría+material+LOD
        const particlesByGeometry = new Map();
        
        sortedParticles.forEach((particle) => {
            // ... obtener tipoEstilos, agrupacionGeom ...
            
            // Obtener geometría con LOD
            const lodLevel = particle._lodLevel || 'high';
            const geometry = this.getGeometryWithLOD(
                particle,
                tipoEstilos,
                agrupacionGeom,
                cellSize,
                lodLevel
            );
            
            // ... resto de agrupación ...
        });
        
        // ... resto del renderizado ...
    }
    
    getGeometryWithLOD(particle, tipoEstilos, agrupacionGeom, cellSize, lodLevel) {
        // Obtener geometría base
        const baseGeometry = this.getGeometry(particle, tipoEstilos, agrupacionGeom, cellSize);
        
        // Obtener tipo y parámetros
        let geometryType = 'box';
        let geometryParams = {};
        // ... obtener de agrupación o tipo ...
        
        // Obtener geometría con LOD desde cache
        return this.geometryCache.getGeometry(
            geometryType,
            geometryParams,
            lodLevel,
            cellSize
        );
    }
}
```

**Notas:**
- Aplicar LOD después de frustum culling
- Usar cache de geometrías para evitar recrear
- Hacer LOD configurable
- Medir mejora de rendimiento (objetivo: 30-70% menos polígonos en partículas lejanas)
- **⚠️ READMEs:** Actualizar `frontend/src/renderers/README.md`

---

### Paso 7: Optimizar Ordenamiento

**Descripción:**
Optimizar el ordenamiento de partículas: reducir a una sola vez y usar algoritmo más eficiente si es posible.

**Archivos a modificar/crear:**
- `frontend/src/utils/sorting.js` (nuevo)
- `frontend/src/renderers/particle-renderer.js` (modificar)

**Detalles de implementación:**
```javascript
/**
 * Utilidades de ordenamiento optimizado
 */

/**
 * Ordenar partículas por celda_z (radix sort para enteros, más eficiente)
 * @param {Array} particles - Array de partículas
 * @returns {Array} - Partículas ordenadas por celda_z descendente
 */
export function sortParticlesByDepth(particles) {
    // Para enteros, radix sort es O(n) vs O(n log n) de sort estándar
    // Pero para simplicidad, usar sort estándar optimizado
    // Si hay problemas de performance, implementar radix sort
    
    return [...particles].sort((a, b) => {
        return b.celda_z - a.celda_z;
    });
}

/**
 * Cache de ordenamiento si partículas no cambian
 */
export class SortingCache {
    constructor() {
        this.lastParticlesHash = null;
        this.cachedResult = null;
    }
    
    getSorted(particles) {
        const hash = this.getParticlesHash(particles);
        
        if (this.lastParticlesHash === hash && this.cachedResult) {
            return this.cachedResult;
        }
        
        this.lastParticlesHash = hash;
        this.cachedResult = sortParticlesByDepth(particles);
        return this.cachedResult;
    }
    
    getParticlesHash(particles) {
        // Hash simple basado en número de partículas y primera/última
        if (particles.length === 0) return '0';
        return `${particles.length}_${particles[0].id}_${particles[particles.length - 1].id}`;
    }
    
    invalidate() {
        this.lastParticlesHash = null;
        this.cachedResult = null;
    }
}
```

**Notas:**
- Reducir ordenamientos a uno solo al inicio
- Cachear ordenamiento si partículas no cambian
- Considerar radix sort si hay problemas de performance
- **⚠️ READMEs:** Actualizar `frontend/src/utils/README.md`

---

### Paso 8: Optimizar Agrupación y Draw Calls

**Descripción:**
Mejorar la agrupación de partículas para reducir draw calls: combinar grupos similares cuando sea posible y aumentar límite de instancias si es seguro.

**Archivos a modificar/crear:**
- `frontend/src/renderers/particle-renderer.js` (modificar)

**Detalles de implementación:**
```javascript
// Aumentar MAX_INSTANCES_PER_MESH si es seguro
const MAX_INSTANCES_PER_MESH = 100000; // Aumentado de 50k

// Mejorar agrupación: combinar grupos similares
// Agrupar por geometría+material+LOD (ya se hace)
// Pero también considerar combinar grupos pequeños similares

// Implementar material pooling
class MaterialPool {
    constructor() {
        this.pool = new Map();
    }
    
    getMaterial(style) {
        const key = this.getMaterialKey(style);
        if (!this.pool.has(key)) {
            this.pool.set(key, this.createMaterial(style));
        }
        return this.pool.get(key);
    }
    
    getMaterialKey(style) {
        return `${style.color}_${style.metalness}_${style.roughness}_${style.opacity || 1.0}`;
    }
    
    createMaterial(style) {
        // ... crear THREE.MeshStandardMaterial ...
    }
    
    clear() {
        this.pool.forEach(material => material.dispose());
        this.pool.clear();
    }
}
```

**Notas:**
- Aumentar `MAX_INSTANCES_PER_MESH` a 100k si es seguro (probar primero)
- Implementar material pooling para reutilizar materiales
- Medir mejora de rendimiento (objetivo: 50% menos draw calls)
- **⚠️ READMEs:** Actualizar `frontend/src/renderers/README.md`

---

### Paso 9: Crear Performance Manager

**Descripción:**
Crear módulo para medir y monitorear métricas de rendimiento (FPS, draw calls) en tiempo real.

**Archivos a modificar/crear:**
- `frontend/src/managers/performance-manager.js` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Gestor de métricas de rendimiento
 */
export class PerformanceManager {
    constructor() {
        this.fps = 0;
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.subscribers = [];
        this.isProfiling = false;
    }
    
    /**
     * Medir FPS
     */
    measureFPS() {
        this.frameCount++;
        const currentTime = performance.now();
        const delta = currentTime - this.lastTime;
        
        if (delta >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / delta);
            this.frameCount = 0;
            this.lastTime = currentTime;
            
            this.notify({ fps: this.fps });
        }
    }
    
    /**
     * Contar draw calls (aproximado)
     * @param {Map} instancedMeshes - Map de instanced meshes
     * @returns {number} - Número aproximado de draw calls
     */
    countDrawCalls(instancedMeshes) {
        let drawCalls = 0;
        instancedMeshes.forEach(mesh => {
            // Cada instanced mesh es un draw call
            drawCalls++;
        });
        return drawCalls;
    }
    
    /**
     * Suscribirse a métricas
     */
    subscribe(callback) {
        this.subscribers.push(callback);
    }
    
    /**
     * Notificar métricas
     */
    notify(metrics) {
        this.subscribers.forEach(callback => callback(metrics));
    }
    
    /**
     * Iniciar profiling
     */
    startProfiling() {
        this.isProfiling = true;
    }
    
    /**
     * Detener profiling
     */
    stopProfiling() {
        this.isProfiling = false;
    }
    
    /**
     * Obtener métricas actuales
     */
    getMetrics() {
        return {
            fps: this.fps,
            // Agregar más métricas según necesidad
        };
    }
}
```

**Notas:**
- Medir FPS usando `performance.now()`
- Contar draw calls aproximado
- Sistema de suscripción para notificar cambios
- **⚠️ READMEs:** Actualizar `frontend/src/managers/README.md`

---

### Paso 10: Integrar Performance Manager en App

**Descripción:**
Integrar Performance Manager en `App` para monitorear métricas continuamente y mostrar FPS en consola o UI opcional.

**Archivos a modificar/crear:**
- `frontend/src/app.js` (modificar)

**Detalles de implementación:**
```javascript
import { PerformanceManager } from './managers/performance-manager.js';

export class App {
    constructor(container) {
        // ... código existente ...
        
        // Inicializar Performance Manager
        this.performanceManager = new PerformanceManager();
        this.performanceManager.subscribe((metrics) => {
            // Log en consola (opcional: mostrar en UI)
            if (this.performanceManager.isProfiling) {
                console.log(`FPS: ${metrics.fps}`);
            }
        });
    }
    
    async loadDemo() {
        // ... código existente ...
        
        // Iniciar profiling
        this.performanceManager.startProfiling();
        
        // Medir FPS en cada frame
        const animate = () => {
            this.performanceManager.measureFPS();
            requestAnimationFrame(animate);
        };
        animate();
        
        // ... resto del código ...
    }
}
```

**Notas:**
- Integrar con loop de animación
- Mostrar métricas en consola (opcional: UI)
- **⚠️ READMEs:** Actualizar `frontend/src/README.md` si existe

---

### Paso 11: Verificar Implementación y Medir Mejoras

**Descripción:**
Verificar que todas las optimizaciones funcionan correctamente y medir mejoras de rendimiento. Si no se alcanza 60 FPS, considerar optimizaciones adicionales.

**Archivos a modificar/crear:**
- Ninguno (verificación)

**Detalles de implementación:**
1. Ejecutar demo 40x40m
2. Medir FPS antes y después
3. Verificar que frustum culling funciona (rotar cámara, verificar reducción de partículas)
4. Verificar que LOD funciona (acercar/alejar cámara, verificar cambio de detalle)
5. Contar draw calls antes y después
6. Verificar que no hay degradación visual significativa

**Notas:**
- Si FPS < 60, considerar optimizaciones adicionales:
  - Occlusion culling básico
  - Chunking espacial
  - Reducción agresiva de partículas
- Documentar métricas obtenidas
- **⚠️ READMEs:** No requiere cambios

---

### Paso 12: Optimizaciones Adicionales (Si es necesario)

**Descripción:**
Si frustum culling + LOD + optimización de ordenamiento no alcanzan 60 FPS, implementar optimizaciones adicionales según necesidad.

**Opciones:**

**A. Occlusion Culling Básico:**
- Crear `frontend/src/renderers/optimizations/occlusion-culler.js`
- Usar raycaster para detectar partículas ocultas
- Filtrar partículas completamente ocultas por otras

**B. Chunking Espacial:**
- Crear `frontend/src/renderers/optimizations/chunk-manager.js`
- Cargar/descargar chunks según posición de cámara
- Reducir partículas cargadas simultáneamente

**C. Reducción Agresiva de Partículas:**
- Limitar número máximo de partículas renderizadas
- Priorizar partículas cercanas a cámara
- Reducir densidad de partículas lejanas

**Archivos a modificar/crear:**
- Según optimización elegida

**Notas:**
- Solo implementar si es necesario
- Medir mejora de cada optimización
- **⚠️ READMEs:** Actualizar READMEs según optimizaciones implementadas

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-007_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance

- **Frustum culling**: Debe ser muy rápido (< 1ms para 400k partículas)
- **LOD**: Calcular distancias eficientemente (usar distancia al cuadrado, evitar sqrt hasta el final)
- **Cache**: Invalidar correctamente cuando cámara se mueve
- **Ordenamiento**: Reducir a una sola vez, cachear si partículas no cambian

### Calidad Visual

- **LOD**: No debe ser notorio para partículas cercanas
- **Transiciones**: Transiciones entre niveles LOD deben ser suaves
- **Frustum culling**: No debe causar "pop-in" visible

### Compatibilidad

- Mantener API existente de `ParticleRenderer.renderParticles()`
- Optimizaciones deben ser transparentes para código que usa el renderer
- No romper renderizado actual
- Hacer optimizaciones configurables (poder desactivarlas para debugging)

### Extensibilidad

- Fácil agregar nuevos tipos de culling
- Fácil agregar nuevos niveles LOD
- Sistema debe ser configurable según hardware

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Clases ES6 para organización
  - Composición sobre herencia (FrustumCuller, LODManager como composición)
  - Cache para evitar recrear objetos costosos
  - Strategy pattern para algoritmos de culling
  - Factory pattern para geometrías LOD
  - Observer pattern para métricas de performance

## Dependencias

### Nuevas Dependencias
Ninguna - solo Three.js que ya está en uso.

### Variables de Entorno
Ninguna nueva.

## Archivos Principales Involucrados

1. `frontend/src/utils/culling.js` - Utilidades de frustum culling
2. `frontend/src/renderers/optimizations/lod-manager.js` - Gestión de LOD
3. `frontend/src/managers/geometry-cache.js` - Cache de geometrías LOD
4. `frontend/src/managers/performance-manager.js` - Métricas de rendimiento
5. `frontend/src/renderers/particle-renderer.js` - Renderizador principal (modificado)
6. `frontend/src/app.js` - Aplicación principal (modificado)

## Testing

### Tests a Crear/Modificar
- Unit tests: `tests/frontend/utils/culling.test.js` (frustum culling)
- Unit tests: `tests/frontend/renderers/lod-manager.test.js` (LOD manager)
- Performance tests: Medir FPS antes/después de optimizaciones

### Escenarios de Prueba
1. **Demo 40x40m**: Cargar demo completo, medir FPS (objetivo: >= 60 FPS)
2. **Frustum culling**: Rotar cámara, verificar que solo se renderizan partículas visibles
3. **LOD**: Acercar/alejar cámara, verificar cambio de detalle
4. **Movimiento de cámara**: Rotar rápidamente, verificar que FPS se mantiene estable
5. **Zoom in/out**: Verificar que LOD aumenta/disminuye detalle correctamente

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos (rebuild si es necesario)
2. Verificar en ambiente local con Docker Compose
3. Verificar FPS en demo 40x40m

### Verificación Post-Deployment
- [ ] Verificar FPS >= 60 en demo 40x40m
- [ ] Verificar frustum culling funciona (rotar cámara)
- [ ] Verificar LOD funciona (acercar/alejar cámara)
- [ ] Verificar que no hay degradación visual
- [ ] Verificar logs de consola (métricas de performance)

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Medir mejoras de rendimiento en cada fase. Si frustum culling + LOD + optimización de ordenamiento no alcanzan 60 FPS, implementar optimizaciones adicionales según necesidad.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

