# JDG-008-2 - Mejoras de Buenas Prácticas en Optimizaciones de Partículas

## Descripción de la Tarea

Refactorizar y mejorar el código implementado en JDG-008 aplicando buenas prácticas de desarrollo. El código funcional está completo, pero hay oportunidades de mejora en términos de mantenibilidad, legibilidad, y eliminación de código duplicado.

**Problemas identificados:**
- Magic numbers y valores hardcodeados en múltiples lugares
- Código duplicado (cálculo de posición, lógica de eliminación)
- Métodos muy largos que violan el principio de responsabilidad única
- Falta de validación de inputs en algunos métodos
- Optimizaciones de performance menores pendientes
- Constantes de configuración dispersas

**Objetivo:**
- Mover valores hardcodeados a archivos de configuración
- Eliminar código duplicado extrayendo métodos helper
- Dividir métodos largos en funciones más pequeñas y mantenibles
- Agregar validaciones de inputs donde falten
- Optimizar creación de objetos (reutilización de Matrix4)
- Mejorar la organización y legibilidad del código

## Criterios de Aceptación

1. ❌ Todos los magic numbers movidos a configuración
2. ❌ Código duplicado eliminado (métodos helper reutilizables)
3. ❌ Método `renderParticles()` refactorizado en métodos más pequeños
4. ❌ Validaciones de inputs agregadas donde sea necesario
5. ❌ Optimización de reutilización de objetos (Matrix4)
6. ❌ Sin regresiones funcionales (comportamiento idéntico)
7. ❌ Código más legible y mantenible

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI) - No afectado
- [x] Frontend (Three.js) - Principalmente afectado
- [ ] Base de Datos (PostgreSQL) - No afectado
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (InstancedMesh, Vector3, Matrix4)
- Refactorización y buenas prácticas de código

## Pasos de Implementación

### Paso 1: Mover Magic Numbers a Configuración

**Descripción:**
Mover todos los valores hardcodeados a `particle-optimization-config.js` para centralizar la configuración y facilitar el mantenimiento.

**Archivos a modificar:**
- `frontend/src/config/particle-optimization-config.js`
- `frontend/src/terrain/renderers/particle-renderer.js`
- `frontend/src/terrain/optimizations/adaptive-limiter.js`
- `frontend/src/terrain/optimizations/particle-limiter.js`

**Valores a mover:**

1. **Posición fuera de vista** (`-10000`):
   - Actualmente en `particle-renderer.js` líneas 649, 699
   - Mover a config como `HIDDEN_PARTICLE_POSITION = -10000`

2. **Opciones de agua hardcodeadas** (líneas 314-316 de `particle-renderer.js`):
   - `waterReductionFactor: 0.25`
   - `waterNearDistance: 12`
   - `waterTypes: ['agua', 'agua_sucia', 'lava', 'pantano']`
   - Estos ya están en config, pero se están pasando inline en lugar de usar la config

3. **Ratios de distribución de agua** (líneas 149-150 de `particle-limiter.js`):
   - `0.7` (70% para medias)
   - `0.3` (30% para lejanas)
   - Mover a config como `WATER_DISTRIBUTION_RATIOS = { medium: 0.7, far: 0.3 }`

4. **FPS thresholds en AdaptiveLimiter** (líneas 51-58 de `adaptive-limiter.js`):
   - `45`, `55`, `59`
   - Mover a config como `ADAPTIVE_LIMITER_FPS_THRESHOLDS = { low: 45, medium: 55, high: 59 }`

**Detalles de implementación:**

```javascript
// En particle-optimization-config.js, agregar:
/**
 * Posición para ocultar partículas (fuera de la vista)
 * Se usa cuando una partícula se elimina pero no queremos recrear el mesh
 */
export const HIDDEN_PARTICLE_POSITION = -10000;

/**
 * Ratios de distribución para agua cuando excede MAX_WATER_PARTICLES
 */
export const WATER_DISTRIBUTION_RATIOS = {
    medium: 0.7,  // 70% de los slots restantes para partículas medias
    far: 0.3      // 30% de los slots restantes para partículas lejanas
};

/**
 * Thresholds de FPS para AdaptiveLimiter
 */
export const ADAPTIVE_LIMITER_FPS_THRESHOLDS = {
    low: 45,    // FPS < 45: usar límite mínimo
    medium: 55, // FPS 45-55: usar límite bajo
    high: 59    // FPS 55-59: usar límite medio, >= 60: máximo
};

/**
 * Opciones por defecto para limitación de agua
 */
export const WATER_OPTIMIZATION_OPTIONS = {
    waterReductionFactor: WATER_REDUCTION_FACTOR,
    waterNearDistance: WATER_NEAR_DISTANCE,
    waterTypes: WATER_TYPES
};
```

**Notas:**
- Mantener compatibilidad hacia atrás si hay otros lugares usando estos valores
- Actualizar imports en los archivos que usan estos valores
- Verificar que todos los lugares hardcodeados se actualicen

---

### Paso 2: Extraer Métodos Helper para Código Duplicado

**Descripción:**
Eliminar código duplicado extrayendo métodos helper privados que se reutilicen en múltiples lugares.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Código duplicado a extraer:**

1. **Cálculo de posición 3D desde coordenadas de celda** (aparece 3 veces):
   - Línea 478-480: En `renderParticles()` al crear instancias
   - Línea 652-654: En `updateParticleInstance()`
   - Línea 701-703: En `updateParticleInstances()`

2. **Lógica de mover partícula fuera de vista** (aparece 2 veces):
   - Línea 649: En `updateParticleInstance()`
   - Línea 699: En `updateParticleInstances()`

**Detalles de implementación:**

```javascript
// En ParticleRenderer, agregar métodos helper privados:

/**
 * Calcular posición 3D de una partícula desde coordenadas de celda
 * @private
 * @param {Object} particle - Partícula con celda_x, celda_y, celda_z
 * @param {number} cellSize - Tamaño de celda en metros
 * @returns {{x: number, y: number, z: number}} - Posición 3D en metros
 */
_calculateParticlePosition(particle, cellSize) {
    return {
        x: particle.celda_x * cellSize + cellSize / 2,
        y: particle.celda_z * cellSize + cellSize / 2,
        z: particle.celda_y * cellSize + cellSize / 2
    };
}

/**
 * Configurar matriz para ocultar una partícula (moverla fuera de vista)
 * @private
 * @param {THREE.Matrix4} matrix - Matriz a configurar
 * @returns {THREE.Matrix4} - Matriz configurada
 */
_setHiddenParticleMatrix(matrix) {
    matrix.setPosition(HIDDEN_PARTICLE_POSITION, HIDDEN_PARTICLE_POSITION, HIDDEN_PARTICLE_POSITION);
    return matrix;
}
```

**Uso en los métodos existentes:**

```javascript
// En renderParticles(), línea ~478:
const pos = this._calculateParticlePosition(particle, cellSize);
matrix.setPosition(pos.x, pos.y, pos.z);

// En updateParticleInstance(), línea ~649-655:
if (newData === null) {
    this._setHiddenParticleMatrix(matrix);
} else {
    const pos = this._calculateParticlePosition(newData, cellSize);
    matrix.setPosition(pos.x, pos.y, pos.z);
}

// En updateParticleInstances(), línea ~698-704:
if (newData === null) {
    this._setHiddenParticleMatrix(matrix);
} else {
    const pos = this._calculateParticlePosition(newData, cellSize);
    matrix.setPosition(pos.x, pos.y, pos.z);
}
```

**Notas:**
- Estos métodos son privados (prefijo `_`)
- Mantener la misma funcionalidad, solo reorganizar código
- Verificar que no haya regresiones en el comportamiento

---

### Paso 3: Refactorizar renderParticles() en Métodos Más Pequeños

**Descripción:**
Dividir el método `renderParticles()` que tiene ~340 líneas en métodos más pequeños y enfocados, siguiendo el principio de responsabilidad única.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Métodos a extraer:**

1. `_applyFrustumCulling(particles, camera, cellSize)` - Aplicar frustum culling
2. `_applyLODOptimization(particles, playerPosition, camera, cellSize)` - Aplicar LOD
3. `_applyAdaptiveLimiting()` - Ajustar límite según FPS
4. `_applyParticleLimiting(particles, playerPosition, camera, cellSize)` - Aplicar limitación por densidad
5. `_buildParticleGroups(particles, tiposEstilos, agrupacionesGeometria, cellSize)` - Agrupar por geometría
6. `_createInstancedMeshes(groups, cellSize, scene)` - Crear instanced meshes

**Estructura propuesta:**

```javascript
renderParticles(particles, tiposEstilos, agrupacionesGeometria, cellSize, scene, camera = null, playerPosition = null) {
    // Log inicial
    debugLogger.info('ParticleRenderer', 'Inicio renderParticles', { ... });
    
    // 1. Aplicar optimizaciones en cadena
    let particlesToRender = this._applyFrustumCulling(particles, camera, cellSize);
    particlesToRender = this._applyLODOptimization(particlesToRender, playerPosition, camera, cellSize);
    this._applyAdaptiveLimiting();
    particlesToRender = this._applyParticleLimiting(particlesToRender, playerPosition, camera, cellSize);
    
    // 2. Construir grupos y meshes
    const groups = this._buildParticleGroups(particlesToRender, tiposEstilos, agrupacionesGeometria, cellSize);
    const instancedMeshes = this._createInstancedMeshes(groups, cellSize, scene);
    
    return instancedMeshes;
}
```

**Detalles de cada método:**

```javascript
/**
 * Aplicar frustum culling si está habilitado
 * @private
 * @param {Array} particles - Partículas a filtrar
 * @param {THREE.Camera|null} camera - Cámara para frustum culling
 * @param {number} cellSize - Tamaño de celda
 * @returns {Array} - Partículas visibles
 */
_applyFrustumCulling(particles, camera, cellSize) {
    if (!this.enableFrustumCulling || !camera) {
        return particles;
    }
    
    if (!this._frustumCache) {
        this._frustumCache = new FrustumCache();
    }
    
    const particlesBefore = particles.length;
    const visible = this._frustumCache.getVisible(particles, camera, cellSize);
    
    debugLogger.info('ParticleRenderer', 'Frustum culling aplicado', {
        antes: particlesBefore,
        despues: visible.length,
        // ... resto de logs
    });
    
    return visible;
}

/**
 * Aplicar optimización LOD si está habilitado
 * @private
 * @param {Array} particles - Partículas a procesar
 * @param {THREE.Vector3|Object|null} playerPosition - Posición del jugador
 * @param {THREE.Camera|null} camera - Cámara
 * @param {number} cellSize - Tamaño de celda
 * @returns {Array} - Partículas con metadata LOD
 */
_applyLODOptimization(particles, playerPosition, camera, cellSize) {
    if (!this.enableLOD || (!playerPosition && !camera)) {
        return particles;
    }
    
    const { position: referencePosition, source: positionSource } = this._getReferencePosition(playerPosition, camera);
    
    if (!referencePosition || particles.length === 0) {
        if (this.enableLOD) {
            debugLogger.warn('ParticleRenderer', 'LOD habilitado pero sin referencia o sin partículas', { ... });
        }
        return particles;
    }
    
    const particlesBefore = particles.length;
    const result = this.lodManager.applyLOD(particles, referencePosition, cellSize);
    
    debugLogger.info('ParticleRenderer', 'LOD aplicado', {
        antes: particlesBefore,
        despues: result.length,
        // ... resto de logs
    });
    
    return result;
}

/**
 * Aplicar ajuste dinámico de límite según FPS
 * @private
 */
_applyAdaptiveLimiting() {
    if (!this.enableAdaptiveLimiting || !this.adaptiveLimiter) {
        if (this.enableAdaptiveLimiting) {
            debugLogger.warn('ParticleRenderer', 'Adaptación dinámica habilitada pero AdaptiveLimiter no está disponible');
        }
        return;
    }
    
    const adaptiveLimit = this.adaptiveLimiter.getCurrentLimit();
    const previousLimit = this.particleLimiter.maxParticles;
    
    if (adaptiveLimit !== previousLimit) {
        this.particleLimiter.setMaxParticles(adaptiveLimit);
        const fps = this.adaptiveLimiter.performanceManager?.getMetrics()?.fps || 0;
        debugLogger.info('ParticleRenderer', 'Límite adaptativo aplicado', {
            fps,
            limiteAdaptivo: adaptiveLimit,
            limiteAnterior: previousLimit
        });
    }
}

/**
 * Aplicar limitación por densidad si está habilitado
 * @private
 * @param {Array} particles - Partículas a limitar
 * @param {THREE.Vector3|Object|null} playerPosition - Posición del jugador
 * @param {THREE.Camera|null} camera - Cámara
 * @param {number} cellSize - Tamaño de celda
 * @returns {Array} - Partículas limitadas
 */
_applyParticleLimiting(particles, playerPosition, camera, cellSize) {
    if (!this.enableParticleLimiting || (!playerPosition && !camera)) {
        if (this.enableParticleLimiting && !camera) {
            debugLogger.warn('ParticleRenderer', 'Limitación con densidad DESHABILITADA: sin cámara', { ... }, { throttleMs: 1000 });
        }
        return particles;
    }
    
    const { position: referencePosition, source: positionSource } = this._getReferencePosition(playerPosition, camera);
    
    if (!referencePosition) {
        debugLogger.warn('ParticleRenderer', 'Limitación habilitada pero no hay posición de referencia');
        return particles;
    }
    
    const particlesBefore = particles.length;
    
    if (particlesBefore === 0) {
        debugLogger.warn('ParticleRenderer', 'No hay partículas para limitar', { ... });
        return particles;
    }
    
    const limited = this.particleLimiter.limitParticlesWithDensity(
        particles,
        referencePosition,
        cellSize,
        this.densityDistances.near,
        this.densityDistances.far,
        WATER_OPTIMIZATION_OPTIONS // Usar config en lugar de valores inline
    );
    
    debugLogger.info('ParticleRenderer', 'Limitación por densidad aplicada', {
        particlesBefore,
        particlesAfter: limited.length,
        // ... resto de logs
    });
    
    return limited;
}

/**
 * Construir grupos de partículas por geometría+material
 * @private
 * @param {Array} particles - Partículas ya optimizadas
 * @param {Map} tiposEstilos - Estilos por tipo
 * @param {Map} agrupacionesGeometria - Geometrías por agrupación
 * @param {number} cellSize - Tamaño de celda
 * @returns {Array} - Grupos separados por opacos/transparentes
 */
_buildParticleGroups(particles, tiposEstilos, agrupacionesGeometria, cellSize) {
    const sortedParticles = sortParticlesByDepth(particles);
    const particlesByGeometry = new Map();
    
    // Agrupar por geometría+material (código existente de líneas 351-410)
    // ... (mover código existente aquí)
    
    // Separar opacos de transparentes
    const opaqueGroups = [];
    const transparentGroups = [];
    
    // ... (mover código existente de líneas 412-441)
    
    return { opaqueGroups, transparentGroups };
}

/**
 * Crear instanced meshes para los grupos
 * @private
 * @param {Object} groups - Grupos {opaqueGroups, transparentGroups}
 * @param {number} cellSize - Tamaño de celda
 * @param {THREE.Scene} scene - Escena Three.js
 * @returns {Map<string, THREE.InstancedMesh>} - Map de meshes creados
 */
_createInstancedMeshes(groups, cellSize, scene) {
    this.particleIndex.clear();
    const instancedMeshes = new Map();
    const groupsToRender = [...groups.opaqueGroups, ...groups.transparentGroups];
    
    // ... (mover código existente de líneas 443-498)
    
    return instancedMeshes;
}
```

**Notas:**
- Mantener exactamente la misma funcionalidad
- Los métodos privados tienen prefijo `_`
- Verificar que todos los logs se mantengan
- Probar que el comportamiento sea idéntico

---

### Paso 4: Agregar Validaciones de Inputs

**Descripción:**
Agregar validaciones de inputs en métodos públicos para prevenir errores en tiempo de ejecución y mejorar la robustez del código.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`
- `frontend/src/terrain/systems/update-system.js`

**Validaciones a agregar:**

1. **En `updateParticleInstances()`** (particle-renderer.js):
   - Validar que `particleIds.length === newDataArray.length`
   - Validar que arrays no estén vacíos

2. **En `updateParticleRender()`** (update-system.js):
   - Validar que `particleId` no sea null/undefined
   - Validar que `currentMeshes` sea un Map válido

**Detalles de implementación:**

```javascript
// En ParticleRenderer.updateParticleInstances():
updateParticleInstances(particleIds, newDataArray, instancedMeshes, cellSize) {
    // Validaciones
    if (!Array.isArray(particleIds) || !Array.isArray(newDataArray)) {
        debugLogger.error('ParticleRenderer', 'updateParticleInstances: particleIds y newDataArray deben ser arrays', {
            particleIdsType: typeof particleIds,
            newDataArrayType: typeof newDataArray
        });
        return false;
    }
    
    if (particleIds.length !== newDataArray.length) {
        debugLogger.error('ParticleRenderer', 'updateParticleInstances: arrays deben tener la misma longitud', {
            particleIdsLength: particleIds.length,
            newDataArrayLength: newDataArray.length
        });
        return false;
    }
    
    if (particleIds.length === 0) {
        debugLogger.warn('ParticleRenderer', 'updateParticleInstances: arrays vacíos');
        return true; // No hay nada que actualizar, pero es válido
    }
    
    if (!instancedMeshes || !(instancedMeshes instanceof Map)) {
        debugLogger.error('ParticleRenderer', 'updateParticleInstances: instancedMeshes debe ser un Map válido');
        return false;
    }
    
    if (typeof cellSize !== 'number' || cellSize <= 0) {
        debugLogger.error('ParticleRenderer', 'updateParticleInstances: cellSize debe ser un número positivo', { cellSize });
        return false;
    }
    
    // ... resto del código existente
}

// En UpdateSystem.updateParticleRender():
updateParticleRender(particleId, newData, currentMeshes, renderer, cellSize) {
    // Validaciones
    if (!particleId || typeof particleId !== 'string') {
        debugLogger.error('UpdateSystem', 'updateParticleRender: particleId debe ser un string no vacío', { particleId });
        return false;
    }
    
    if (!currentMeshes || !(currentMeshes instanceof Map)) {
        debugLogger.error('UpdateSystem', 'updateParticleRender: currentMeshes debe ser un Map válido');
        return false;
    }
    
    if (!renderer) {
        debugLogger.error('UpdateSystem', 'updateParticleRender: renderer es requerido');
        return false;
    }
    
    if (typeof cellSize !== 'number' || cellSize <= 0) {
        debugLogger.error('UpdateSystem', 'updateParticleRender: cellSize debe ser un número positivo', { cellSize });
        return false;
    }
    
    // ... resto del código existente
}
```

**Notas:**
- Las validaciones deben ser tempranas (fail-fast)
- Usar `debugLogger.error` para errores críticos
- Retornar `false` en caso de error para que el caller pueda manejar
- No romper código existente que asume comportamiento actual

---

### Paso 5: Optimizar Reutilización de Matrix4

**Descripción:**
Optimizar `updateParticleInstances()` para reutilizar una sola instancia de `Matrix4` en lugar de crear una nueva en cada iteración.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Problema actual:**
En `updateParticleInstances()`, línea 695, se crea una nueva `Matrix4()` dentro del forEach de meshes, y luego se usa en el forEach de updates. Esto funciona pero es ineficiente.

**Solución:**
Crear una sola matriz y reutilizarla, reseteándola con `matrix.identity()` antes de cada uso.

**Detalles de implementación:**

```javascript
// Antes (líneas 690-711):
updatesByMesh.forEach((updates, meshKey) => {
    const mesh = instancedMeshes.get(meshKey);
    if (!mesh) return;
    
    const matrix = new THREE.Matrix4(); // ❌ Nueva matriz por mesh
    
    updates.forEach(({ instanceIndex, newData }) => {
        if (newData === null) {
            matrix.setPosition(-10000, -10000, -10000);
        } else {
            const x = newData.celda_x * cellSize + cellSize / 2;
            const y = newData.celda_z * cellSize + cellSize / 2;
            const z = newData.celda_y * cellSize + cellSize / 2;
            matrix.setPosition(x, y, z);
        }
        
        mesh.setMatrixAt(instanceIndex, matrix);
    });
    
    mesh.instanceMatrix.needsUpdate = true;
});

// Después:
updatesByMesh.forEach((updates, meshKey) => {
    const mesh = instancedMeshes.get(meshKey);
    if (!mesh) return;
    
    const matrix = new THREE.Matrix4(); // Una sola matriz por mesh
    
    updates.forEach(({ instanceIndex, newData }) => {
        matrix.identity(); // Resetear matriz antes de cada uso
        
        if (newData === null) {
            this._setHiddenParticleMatrix(matrix);
        } else {
            const pos = this._calculateParticlePosition(newData, cellSize);
            matrix.setPosition(pos.x, pos.y, pos.z);
        }
        
        mesh.setMatrixAt(instanceIndex, matrix);
    });
    
    mesh.instanceMatrix.needsUpdate = true;
});
```

**Notas:**
- `matrix.identity()` resetea la matriz a la identidad antes de configurarla
- Esto es más eficiente que crear nuevas instancias
- Combinar con los métodos helper del Paso 2 para código más limpio

---

### Paso 6: Usar Configuración en Lugar de Valores Inline

**Descripción:**
Actualizar `particle-renderer.js` para usar las constantes de configuración en lugar de pasar valores inline cuando se llama a `limitParticlesWithDensity()`.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Problema actual:**
En línea 312-317, se pasan opciones inline:
```javascript
{
    waterReductionFactor: 0.25,
    waterNearDistance: 12,
    waterTypes: ['agua', 'agua_sucia', 'lava', 'pantano']
}
```

**Solución:**
Usar la constante `WATER_OPTIMIZATION_OPTIONS` del config.

**Detalles de implementación:**

```javascript
// En imports, agregar:
import {
    // ... imports existentes
    WATER_OPTIMIZATION_OPTIONS
} from '../../config/particle-optimization-config.js';

// En _applyParticleLimiting() o donde se use:
particlesToRender = this.particleLimiter.limitParticlesWithDensity(
    particlesToRender,
    referencePosition,
    cellSize,
    this.densityDistances.near,
    this.densityDistances.far,
    WATER_OPTIMIZATION_OPTIONS // ✅ Usar config en lugar de valores inline
);
```

**Notas:**
- Esto centraliza la configuración
- Facilita cambiar valores sin tocar el código
- Mantiene consistencia con el resto del sistema

---

### Paso 7: Actualizar AdaptiveLimiter para Usar Config

**Descripción:**
Actualizar `AdaptiveLimiter` para usar los thresholds de FPS desde configuración en lugar de valores hardcodeados.

**Archivos a modificar:**
- `frontend/src/terrain/optimizations/adaptive-limiter.js`
- `frontend/src/config/particle-optimization-config.js`

**Detalles de implementación:**

```javascript
// En adaptive-limiter.js, actualizar constructor:
import {
    ADAPTIVE_LIMITER_FPS_THRESHOLDS
} from '../../config/particle-optimization-config.js';

constructor(performanceManager, options = {}) {
    this.performanceManager = performanceManager;
    
    // Usar thresholds de config
    this.fpsThresholds = options.fpsThresholds || ADAPTIVE_LIMITER_FPS_THRESHOLDS;
    
    // ... resto del constructor
}

// En getCurrentLimit(), actualizar:
getCurrentLimit() {
    if (!this.enabled) {
        return this.limits.max;
    }
    
    const fps = this.performanceManager.getMetrics().fps;
    const now = performance.now();
    
    if (now - this.lastAdjustmentTime < this.adjustmentDebounce) {
        return this.currentLimit;
    }
    
    // Usar thresholds de config
    let newLimit;
    if (fps === 0 || fps < this.fpsThresholds.low) {
        newLimit = this.limits.min;
    } else if (fps < this.fpsThresholds.medium) {
        newLimit = this.limits.low;
    } else if (fps < this.fpsThresholds.high) {
        newLimit = this.limits.medium;
    } else {
        newLimit = this.limits.max;
    }
    
    // ... resto del método
}
```

**Notas:**
- Mantener compatibilidad hacia atrás (usar defaults si no se proporcionan)
- Permite override desde options si es necesario

---

### Paso 8: Actualizar ParticleLimiter para Usar Config de Distribución

**Descripción:**
Actualizar `particle-limiter.js` para usar `WATER_DISTRIBUTION_RATIOS` desde configuración.

**Archivos a modificar:**
- `frontend/src/terrain/optimizations/particle-limiter.js`
- `frontend/src/config/particle-optimization-config.js`

**Detalles de implementación:**

```javascript
// En imports de particle-limiter.js, agregar:
import {
    // ... imports existentes
    WATER_DISTRIBUTION_RATIOS
} from '../../config/particle-optimization-config.js';

// En limitParticlesWithDensity(), línea ~149-150:
// Antes:
const remainingMedium = Math.floor(remainingSlots * 0.7); // 70% para medias
const remainingFar = remainingSlots - remainingMedium; // 30% para lejanas

// Después:
const remainingMedium = Math.floor(remainingSlots * WATER_DISTRIBUTION_RATIOS.medium);
const remainingFar = remainingSlots - remainingMedium;
```

**Notas:**
- Simple reemplazo de magic numbers
- Hace el código más mantenible

---

### Paso Final: Verificación y Testing

**Descripción:**
Verificar que todas las mejoras funcionan correctamente y que no hay regresiones.

**Checklist de verificación:**

1. ✅ **Compilación sin errores**: Verificar que no hay errores de sintaxis
2. ✅ **Linter limpio**: Ejecutar linter y corregir cualquier error
3. ✅ **Sin regresiones funcionales**: 
   - Probar renderizado de partículas
   - Probar actualización incremental
   - Verificar que FPS se mantiene
   - Verificar que las optimizaciones siguen funcionando
4. ✅ **Validaciones funcionando**: Probar casos edge (arrays vacíos, valores null, etc.)
5. ✅ **Configuración centralizada**: Verificar que todos los valores están en config
6. ✅ **Código más legible**: Revisar que los métodos son más fáciles de entender

**Testing manual sugerido:**

1. **Renderizado básico**: Cargar demo y verificar que las partículas se renderizan correctamente
2. **Actualización incremental**: Simular actualización de partícula individual (cuando backend lo soporte)
3. **Validaciones**: Intentar pasar valores inválidos y verificar que se manejan correctamente
4. **Performance**: Verificar que no hay degradación de rendimiento

---

## Consideraciones Técnicas

### Mantenibilidad

- **Configuración centralizada**: Todos los valores ajustables están en un solo lugar
- **Código más pequeño**: Métodos más fáciles de entender y modificar
- **Reutilización**: Helpers eliminan duplicación

### Compatibilidad

- **Sin cambios de API pública**: Todos los cambios son internos
- **Comportamiento idéntico**: El código funciona exactamente igual
- **Validaciones no rompen código existente**: Solo agregan protección

### Performance

- **Mejora menor**: Reutilización de Matrix4 reduce allocaciones
- **Sin impacto negativo**: Las refactorizaciones no afectan el rendimiento
- **Código más optimizable**: El compilador puede optimizar mejor código más pequeño

### Testing

- **Mismos tests**: Los tests existentes deben seguir funcionando
- **Nuevos casos edge**: Validaciones cubren casos que antes fallarían silenciosamente

---

## Archivos Principales Involucrados

1. `frontend/src/config/particle-optimization-config.js` - Agregar nuevas constantes
2. `frontend/src/terrain/renderers/particle-renderer.js` - Refactorización principal
3. `frontend/src/terrain/optimizations/adaptive-limiter.js` - Usar config de thresholds
4. `frontend/src/terrain/optimizations/particle-limiter.js` - Usar config de distribución
5. `frontend/src/terrain/systems/update-system.js` - Agregar validaciones

---

## Beneficios Esperados

1. **Mantenibilidad mejorada**: Código más fácil de entender y modificar
2. **Configuración centralizada**: Valores ajustables en un solo lugar
3. **Menos bugs**: Validaciones previenen errores en tiempo de ejecución
4. **Código más limpio**: Sin duplicación, métodos más pequeños
5. **Mejor performance**: Reutilización de objetos reduce allocaciones
6. **Facilidad de testing**: Métodos más pequeños son más fáciles de testear

---

## Notas Adicionales

- Esta refactorización NO cambia la funcionalidad, solo mejora la calidad del código
- Puede hacerse incrementalmente, paso por paso
- Cada paso puede probarse independientemente
- Es una buena práctica hacer esto después de que el código funcional está completo (como ahora)

---

**⚠️ IMPORTANTE:** Después de completar todos los pasos y verificar que todo funciona, considera ejecutar los tests existentes (si los hay) y hacer pruebas manuales para asegurar que no hay regresiones.
