# JDG-008 - Optimización de Renderizado de Partículas para Alcanzar 60 FPS

## Descripción de la Tarea

Optimizar el renderizado de partículas para alcanzar 60 FPS estables cuando la cámara apunta a las partículas del terreno. El problema actual es que cuando la cámara apunta hacia el terreno, el FPS cae drásticamente, mientras que cuando apunta al cielo el rendimiento es aceptable. Además, se debe preparar el sistema para interacciones futuras (romper, recolectar, farmear) sin impactar el rendimiento.

**Comportamiento actual:**
- FPS muy bajos (~27-31) cuando cámara apunta a partículas en demo 40x40m
- FPS OK cuando cámara apunta al cielo
- `limitParticlesWithDensity()` existe pero NO se está usando
- Límite estático de 150k partículas sin adaptación dinámica
- Actualización de partícula recarga toda la dimensión (extremadamente costoso)

**Comportamiento esperado:**
- 60 FPS estables cuando cámara apunta a partículas (demo 40x40m)
- Limitación con densidad reducida activa y funcionando
- Adaptación dinámica que ajusta límite según FPS
- Actualización incremental de partículas individuales sin recargar todo
- Sistema preparado para interacciones futuras (romper, recolectar, farmear)

## Criterios de Aceptación

1. ❌ FPS mínimo de 60 cuando cámara apunta a partículas en demo 40x40m (~400k partículas) - **OBJETIVO PRINCIPAL**
2. ❌ FPS mínimo de 60 en demo 20x20m (~100k partículas)
3. ❌ Limitación con densidad reducida implementada y activa
4. ❌ Limitación adaptativa implementada: ajusta límite según FPS actual
5. ❌ Actualización incremental funcionando: modificar partícula individual no requiere recargar dimensión completa
6. ❌ Sin degradación visual significativa
7. ❌ Sistema preparado para interacciones futuras

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI) - No afectado
- [x] Frontend (Three.js) - Principalmente afectado
- [ ] Base de Datos (PostgreSQL) - No afectado
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (InstancedMesh, Vector3, frustum culling)
- Performance API (para medir FPS y adaptar)

## Pasos de Implementación

### Paso 1: Activar Limitación con Densidad en ParticleRenderer

**Descripción:**
Modificar `ParticleRenderer.renderParticles()` para usar `limitParticlesWithDensity()` en lugar de `limitParticles()`. Este método ya existe en `ParticleLimiter` pero no se está usando actualmente. Reduce la densidad de partículas lejanas manteniendo la distribución visual.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**
```javascript
// En renderParticles(), cambiar de:
if (this.enableParticleLimiting && camera) {
    const cameraPosition = camera.position;
    particlesToRender = this.particleLimiter.limitParticles(
        particlesToRender,
        cameraPosition,
        cellSize
    );
}

// A:
if (this.enableParticleLimiting && camera) {
    const cameraPosition = camera.position;
    particlesToRender = this.particleLimiter.limitParticlesWithDensity(
        particlesToRender,
        cameraPosition,
        cellSize,
        20,  // nearDistance (metros) - todas las partículas dentro de 20m se renderizan al 100%
        50   // farDistance (metros) - partículas lejanas se reducen
    );
}
```

**Notas:**
- Reutilizar `_distance` calculado por LOD si está disponible para evitar recalcular
- Las distancias (20m/50m) son iniciales y pueden necesitar ajuste según pruebas
- Verificar que calidad visual se mantiene aceptable después del cambio
- **⚠️ READMEs:** Verificar si `frontend/src/terrain/README.md` necesita actualización

**Recursos útiles:**
- Revisar método `limitParticlesWithDensity()` en `frontend/src/terrain/optimizations/particle-limiter.js` para entender parámetros

---

### Paso 2: Optimizar ParticleLimiter para Reutilizar Distancias de LOD

**Descripción:**
Optimizar `limitParticlesWithDensity()` en `ParticleLimiter` para reutilizar las distancias ya calculadas por el LOD Manager (`_distance`), evitando recalcular distancias innecesariamente.

**Archivos a modificar:**
- `frontend/src/terrain/optimizations/particle-limiter.js`

**Detalles de implementación:**
```javascript
// En limitParticlesWithDensity(), verificar si _distance ya existe:
limitParticlesWithDensity(particles, cameraPosition, cellSize, nearDistance = 20, farDistance = 50) {
    if (particles.length <= this.maxParticles) {
        return particles;
    }
    
    // Reutilizar _distance si está disponible (viene de LOD)
    const particlesWithDistance = particles.map(particle => {
        let distance;
        if (particle._distance !== undefined) {
            // Ya calculado por LOD, reutilizar
            distance = particle._distance;
        } else {
            // Calcular distancia
            const particlePos = new THREE.Vector3(
                particle.celda_x * cellSize,
                particle.celda_y * cellSize,
                particle.celda_z * cellSize
            );
            distance = particlePos.distanceTo(cameraPosition);
        }
        
        return {
            ...particle,
            _distance: distance
        };
    });
    
    // ... resto del método (agrupar por distancia y aplicar densidad)
}
```

**Notas:**
- Esto mejora el rendimiento al evitar cálculos redundantes
- Mantener compatibilidad con código que no usa LOD

---

### Paso 3: Crear AdaptiveLimiter para Adaptación Dinámica

**Descripción:**
Crear una nueva clase `AdaptiveLimiter` que observe las métricas de FPS del `PerformanceManager` y ajuste dinámicamente el límite de partículas según el rendimiento actual.

**Archivos a crear:**
- `frontend/src/terrain/optimizations/adaptive-limiter.js`

**Detalles de implementación:**
```javascript
/**
 * Limitador adaptativo que ajusta el límite de partículas según FPS
 * 
 * Observa métricas de PerformanceManager y ajusta límite dinámicamente
 * para mantener 60 FPS incluso bajo carga variable.
 */
export class AdaptiveLimiter {
    /**
     * @param {PerformanceManager} performanceManager - Performance Manager para obtener FPS
     * @param {Object} options - Opciones de configuración
     */
    constructor(performanceManager, options = {}) {
        this.performanceManager = performanceManager;
        
        // Límites configurables
        this.limits = {
            min: options.min || 80000,      // FPS < 45
            low: options.low || 100000,     // FPS 45-55
            medium: options.medium || 120000, // FPS 55-59
            max: options.max || 150000       // FPS >= 60
        };
        
        this.currentLimit = this.limits.max;
        this.lastAdjustmentTime = 0;
        this.adjustmentDebounce = options.debounce || 2000; // 2 segundos por defecto
        this.enabled = options.enabled !== false; // Habilitado por defecto
    }
    
    /**
     * Obtener límite actual ajustado según FPS
     * @returns {number} - Límite actual de partículas
     */
    getCurrentLimit() {
        if (!this.enabled) {
            return this.limits.max;
        }
        
        const fps = this.performanceManager.getMetrics().fps;
        const now = performance.now();
        
        // Debounce: Solo ajustar cada X segundos para evitar oscilación
        if (now - this.lastAdjustmentTime < this.adjustmentDebounce) {
            return this.currentLimit;
        }
        
        // Ajustar según FPS
        let newLimit;
        if (fps < 45) {
            newLimit = this.limits.min;
        } else if (fps < 55) {
            newLimit = this.limits.low;
        } else if (fps < 59) {
            newLimit = this.limits.medium;
        } else {
            newLimit = this.limits.max;
        }
        
        // Solo actualizar si cambió
        if (newLimit !== this.currentLimit) {
            this.currentLimit = newLimit;
            this.lastAdjustmentTime = now;
        }
        
        return this.currentLimit;
    }
    
    /**
     * Configurar límites
     * @param {Object} limits - Objeto con límites (min, low, medium, max)
     */
    setLimits(limits) {
        this.limits = { ...this.limits, ...limits };
    }
    
    /**
     * Habilitar/deshabilitar adaptación
     * @param {boolean} enabled - true para habilitar, false para deshabilitar
     */
    setEnabled(enabled) {
        this.enabled = enabled;
    }
    
    /**
     * Obtener límite actual sin ajustar (útil para debugging)
     * @returns {number}
     */
    getCurrentLimitWithoutAdjustment() {
        return this.currentLimit;
    }
}
```

**Notas:**
- El debounce evita oscilación de límites entre frames
- Los límites son configurables según hardware
- Permite deshabilitar adaptación si es necesario
- **⚠️ READMEs:** Actualizar `frontend/src/terrain/optimizations/README.md` si existe

---

### Paso 4: Integrar AdaptiveLimiter en ParticleRenderer

**Descripción:**
Integrar `AdaptiveLimiter` en `ParticleRenderer` para que ajuste dinámicamente el límite de partículas antes de aplicar la limitación. El límite se ajusta cada frame según el FPS actual.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**
```javascript
export class ParticleRenderer extends BaseRenderer {
    /**
     * @param {GeometryRegistry} geometryRegistry - Registry de geometrías
     * @param {PerformanceManager} performanceManager - Performance Manager (opcional)
     */
    constructor(geometryRegistry, performanceManager = null) {
        super(geometryRegistry);
        // ... código existente ...
        
        // Crear AdaptiveLimiter si se proporciona PerformanceManager
        if (performanceManager) {
            this.adaptiveLimiter = new AdaptiveLimiter(performanceManager, {
                min: 80000,
                low: 100000,
                medium: 120000,
                max: 150000,
                debounce: 2000
            });
        } else {
            this.adaptiveLimiter = null;
        }
        
        this.enableAdaptiveLimiting = true; // Configurable
    }
    
    // En renderParticles(), antes de limitar partículas:
    renderParticles(particles, tiposEstilos, agrupacionesGeometria, cellSize, scene, camera = null) {
        // ... código existente (frustum culling, LOD) ...
        
        // 2.5. Ajustar límite dinámicamente según FPS si está habilitado
        if (this.enableAdaptiveLimiting && this.adaptiveLimiter) {
            const adaptiveLimit = this.adaptiveLimiter.getCurrentLimit();
            this.particleLimiter.setMaxParticles(adaptiveLimit);
        }
        
        // 2.6. Aplicar limitación con densidad si está habilitado
        if (this.enableParticleLimiting && camera) {
            const cameraPosition = camera.position;
            particlesToRender = this.particleLimiter.limitParticlesWithDensity(
                particlesToRender,
                cameraPosition,
                cellSize,
                20,  // nearDistance
                50   // farDistance
            );
        }
        
        // ... resto del código ...
    }
}
```

**Notas:**
- El `PerformanceManager` debe pasarse desde `TerrainManager` o `app.js`
- Verificar que el adaptador se inicializa correctamente
- Mantener flag `enableAdaptiveLimiting` para poder deshabilitar si es necesario

---

### Paso 5: Pasar PerformanceManager a ParticleRenderer

**Descripción:**
Modificar `TerrainManager` para pasar el `PerformanceManager` a `ParticleRenderer`, permitiendo que el adaptador dinámico funcione correctamente.

**Archivos a modificar:**
- `frontend/src/terrain/manager.js`

**Detalles de implementación:**
```javascript
export class TerrainManager {
    /**
     * @param {THREE.Scene} scene - Escena Three.js
     * @param {Object} particlesApi - Cliente API para partículas
     * @param {Object} bloquesApi - Cliente API para bloques
     * @param {GeometryRegistry} geometryRegistry - Registry de geometrías
     * @param {PerformanceManager} performanceManager - Performance Manager (opcional)
     */
    constructor(scene, particlesApi, bloquesApi, geometryRegistry, performanceManager = null) {
        // ... código existente ...
        
        // Pasar PerformanceManager al renderer
        this.renderer = new ParticleRenderer(geometryRegistry, performanceManager);
        
        // ... resto del código ...
    }
}
```

**Notas:**
- Verificar dónde se instancia `TerrainManager` y pasar `PerformanceManager` desde allí
- Probablemente desde `app.js` donde ya existe `PerformanceManager`
- El parámetro es opcional para mantener compatibilidad

---

### Paso 6: Implementar Índice de Partículas en ParticleRenderer

**Descripción:**
Modificar `ParticleRenderer` para mantener un índice que mapea `particleId` a `{meshKey, instanceIndex}`. Esto permite actualizar partículas individuales sin buscar en todos los meshes.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**
```javascript
export class ParticleRenderer extends BaseRenderer {
    constructor(geometryRegistry, performanceManager = null) {
        // ... código existente ...
        
        // Índice de partículas: particleId -> {meshKey, instanceIndex}
        this.particleIndex = new Map();
    }
    
    // En renderParticles(), después de crear instanced meshes:
    renderParticles(particles, tiposEstilos, agrupacionesGeometria, cellSize, scene, camera = null) {
        // ... código existente hasta crear instancedMeshes ...
        
        // Limpiar índice anterior
        this.particleIndex.clear();
        
        // Construir índice de partículas
        groupsToRender.forEach(({ group, geometryKey }) => {
            // ... código de creación de meshes ...
            
            for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {
                // ... código existente ...
                
                particlesChunk.forEach((particle, chunkIndex) => {
                    const instanceIndex = chunkIndex;
                    const meshKey = numMeshes > 1 ? `${geometryKey}_${meshIndex}` : geometryKey;
                    
                    // Guardar en índice
                    this.particleIndex.set(particle.id, {
                        meshKey: meshKey,
                        instanceIndex: instanceIndex
                    });
                });
                
                // ... resto del código ...
            }
        });
        
        // ... resto del método ...
    }
    
    /**
     * Obtener índice de partículas (para debugging)
     * @returns {Map} - Índice de partículas
     */
    getParticleIndex() {
        return this.particleIndex;
    }
}
```

**Notas:**
- El índice se reconstruye cada vez que se renderizan partículas
- Se usa para encontrar rápidamente qué instancia de qué mesh representa cada partícula
- Es crítico para la actualización incremental

---

### Paso 7: Implementar Actualización Incremental de Partículas

**Descripción:**
Implementar métodos para actualizar partículas individuales en instanced meshes sin recrear todo el mesh. Usa `instanceMatrix.setMatrixAt()` de Three.js para actualizar solo la instancia específica.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**
```javascript
export class ParticleRenderer extends BaseRenderer {
    /**
     * Actualizar instancia de partícula individual
     * @param {string} particleId - ID de la partícula
     * @param {Object|null} newData - Nuevos datos (null = eliminar)
     * @param {Map<string, THREE.InstancedMesh>} instancedMeshes - Map de meshes actuales
     * @param {number} cellSize - Tamaño de celda
     */
    updateParticleInstance(particleId, newData, instancedMeshes, cellSize) {
        const index = this.particleIndex.get(particleId);
        if (!index) {
            console.warn(`[ParticleRenderer] Partícula ${particleId} no encontrada en índice`);
            return false;
        }
        
        const mesh = instancedMeshes.get(index.meshKey);
        if (!mesh) {
            console.warn(`[ParticleRenderer] Mesh ${index.meshKey} no encontrado`);
            return false;
        }
        
        const matrix = new THREE.Matrix4();
        
        if (newData === null) {
            // Eliminar: Mover instancia fuera de vista (o usar escala 0)
            matrix.setPosition(-10000, -10000, -10000); // Fuera de vista
        } else {
            // Actualizar posición
            const x = newData.celda_x * cellSize + cellSize / 2;
            const y = newData.celda_z * cellSize + cellSize / 2;
            const z = newData.celda_y * cellSize + cellSize / 2;
            matrix.setPosition(x, y, z);
        }
        
        mesh.setMatrixAt(index.instanceIndex, matrix);
        mesh.instanceMatrix.needsUpdate = true;
        
        return true;
    }
    
    /**
     * Actualizar múltiples partículas en batch
     * @param {Array<string>} particleIds - IDs de partículas
     * @param {Array<Object|null>} newDataArray - Array de nuevos datos
     * @param {Map<string, THREE.InstancedMesh>} instancedMeshes - Map de meshes actuales
     * @param {number} cellSize - Tamaño de celda
     */
    updateParticleInstances(particleIds, newDataArray, instancedMeshes, cellSize) {
        const updatesByMesh = new Map(); // Agrupar actualizaciones por mesh
        
        particleIds.forEach((particleId, index) => {
            const particleIndex = this.particleIndex.get(particleId);
            if (!particleIndex) return;
            
            const meshKey = particleIndex.meshKey;
            if (!updatesByMesh.has(meshKey)) {
                updatesByMesh.set(meshKey, []);
            }
            
            updatesByMesh.get(meshKey).push({
                instanceIndex: particleIndex.instanceIndex,
                newData: newDataArray[index]
            });
        });
        
        // Aplicar actualizaciones por mesh
        updatesByMesh.forEach((updates, meshKey) => {
            const mesh = instancedMeshes.get(meshKey);
            if (!mesh) return;
            
            const matrix = new THREE.Matrix4();
            
            updates.forEach(({ instanceIndex, newData }) => {
                if (newData === null) {
                    matrix.setPosition(-10000, -10000, -10000);
                } else {
                    const x = newData.celda_x * cellSize + cellSize / 2;
                    const y = newData.celda_z * cellSize + cellSize / 2;
                    const z = newData.celda_y * cellSize + cellSize / 2;
                    matrix.setPosition(x, y, z);
                }
                
                mesh.setMatrixAt(instanceIndex, matrix);
            });
            
            mesh.instanceMatrix.needsUpdate = true;
        });
        
        return true;
    }
}
```

**Notas:**
- `instanceMatrix.needsUpdate = true` solo se marca una vez por mesh después de todas las actualizaciones
- Batch updates agrupan actualizaciones por mesh para eficiencia
- Eliminar partículas moviéndolas fuera de vista es más eficiente que recrear el mesh

---

### Paso 8: Modificar UpdateSystem para Usar Actualización Incremental

**Descripción:**
Modificar `UpdateSystem.updateParticleRender()` para usar la actualización incremental en lugar de recargar toda la dimensión. Esto permite romper/colocar partículas sin stutters.

**Archivos a modificar:**
- `frontend/src/terrain/systems/update-system.js`

**Detalles de implementación:**
```javascript
export class UpdateSystem {
    /**
     * Actualizar renderizado de partícula individual (incremental)
     * @param {string} particleId - ID de la partícula
     * @param {Object|null} newData - Nuevos datos (null = eliminar)
     * @param {Map<string, THREE.InstancedMesh>} currentMeshes - Map de meshes actuales
     * @param {ParticleRenderer} renderer - Renderer de partículas
     * @param {number} cellSize - Tamaño de celda
     */
    updateParticleRender(particleId, newData, currentMeshes, renderer, cellSize) {
        if (!renderer || !currentMeshes) {
            console.warn('[UpdateSystem] Renderer o meshes no disponibles para actualización incremental');
            return;
        }
        
        // Usar actualización incremental
        const success = renderer.updateParticleInstance(
            particleId,
            newData,
            currentMeshes,
            cellSize
        );
        
        if (!success) {
            console.warn(`[UpdateSystem] No se pudo actualizar partícula ${particleId} incrementalmente`);
            // Fallback: Podría recargar si es necesario (comentado por ahora)
            // return false;
        }
        
        return success;
    }
    
    /**
     * Actualizar renderizado de múltiples partículas (batch)
     * @param {Array<string>} particleIds - IDs de partículas
     * @param {Array<Object|null>} newDataArray - Array de nuevos datos
     * @param {Map<string, THREE.InstancedMesh>} currentMeshes - Map de meshes actuales
     * @param {ParticleRenderer} renderer - Renderer de partículas
     * @param {number} cellSize - Tamaño de celda
     */
    updateParticlesRender(particleIds, newDataArray, currentMeshes, renderer, cellSize) {
        if (!renderer || !currentMeshes) {
            console.warn('[UpdateSystem] Renderer o meshes no disponibles para actualización incremental');
            return;
        }
        
        // Usar actualización incremental en batch
        const success = renderer.updateParticleInstances(
            particleIds,
            newDataArray,
            currentMeshes,
            cellSize
        );
        
        return success;
    }
}
```

**Notas:**
- Mantener fallback comentado por si acaso (puede necesitarse en casos edge)
- El método es eficiente y no requiere recargar toda la dimensión

---

### Paso 9: Modificar TerrainManager para Usar Actualización Incremental

**Descripción:**
Modificar `TerrainManager.updateParticle()` y `updateParticles()` para usar actualización incremental en lugar de recargar toda la dimensión con `loadDimension()`.

**Archivos a modificar:**
- `frontend/src/terrain/manager.js`

**Detalles de implementación:**
```javascript
export class TerrainManager {
    /**
     * Actualizar partícula individual (romper/colocar)
     * @param {string} particleId - ID de la partícula
     * @param {Particle|null} newData - Nuevos datos (null = eliminar)
     */
    async updateParticle(particleId, newData) {
        // 1. Actualizar en backend (si aplica)
        if (this.currentDimension) {
            await this.updateSystem.updateParticleInBackend(particleId, newData);
        }
        
        // 2. Actualizar cache local
        if (newData === null) {
            // Partícula eliminada (rota)
            this.currentParticles.delete(particleId);
        } else {
            // Partícula modificada/colocada
            this.currentParticles.set(particleId, newData);
        }
        
        // 3. Actualización incremental (en lugar de recargar todo)
        if (this.currentDimension && this.currentMeshes.size > 0) {
            this.updateSystem.updateParticleRender(
                particleId,
                newData,
                this.currentMeshes,
                this.renderer,
                this.currentDimension.tamano_celda
            );
        }
    }
    
    /**
     * Actualizar múltiples partículas (batch)
     * @param {string[]} particleIds - IDs de partículas
     * @param {Array<Particle|null>} newDataArray - Array de nuevos datos
     */
    async updateParticles(particleIds, newDataArray) {
        // Similar a updateParticle pero en batch para eficiencia
        if (this.currentDimension) {
            await this.updateSystem.updateParticlesBatch(particleIds, newDataArray);
            
            // Actualizar cache local
            particleIds.forEach((id, index) => {
                if (newDataArray[index] === null) {
                    this.currentParticles.delete(id);
                } else {
                    this.currentParticles.set(id, newDataArray[index]);
                }
            });
            
            // Actualización incremental en batch
            if (this.currentMeshes.size > 0) {
                this.updateSystem.updateParticlesRender(
                    particleIds,
                    newDataArray,
                    this.currentMeshes,
                    this.renderer,
                    this.currentDimension.tamano_celda
                );
            }
        }
    }
}
```

**Notas:**
- Ya no recarga toda la dimensión, solo actualiza las instancias específicas
- Mantiene sincronización entre cache local y renderizado
- Mucho más eficiente para interacciones

---

### Paso 10: Pasar PerformanceManager desde app.js a TerrainManager

**Descripción:**
Modificar `app.js` para pasar el `PerformanceManager` a `TerrainManager` cuando se instancia, permitiendo que el adaptador dinámico funcione correctamente.

**Archivos a modificar:**
- `frontend/src/app.js`

**Detalles de implementación:**
```javascript
// Buscar donde se instancia TerrainManager y pasar PerformanceManager
// Probablemente algo como:

this.terrainManager = new TerrainManager(
    this.scene.scene,
    this.particlesApi,
    this.bloquesApi,
    this.geometryRegistry,
    this.performanceManager // Agregar este parámetro
);
```

**Notas:**
- Verificar dónde exactamente se instancia `TerrainManager` en `app.js`
- Asegurarse de que `PerformanceManager` esté inicializado antes de instanciar `TerrainManager`

---

### Paso 11: Verificar y Ajustar Distancias de Densidad

**Descripción:**
Probar el sistema con diferentes distancias de densidad y ajustar según resultados. Las distancias iniciales (20m/50m) pueden necesitar ajuste según pruebas.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js` (ajustar parámetros)

**Detalles de implementación:**
```javascript
// Hacer distancias configurables:
constructor(geometryRegistry, performanceManager = null) {
    // ... código existente ...
    
    this.densityDistances = {
        near: 20,  // Partículas dentro de 20m: 100%
        far: 50    // Partículas lejanas: densidad reducida
    };
}

// En renderParticles():
particlesToRender = this.particleLimiter.limitParticlesWithDensity(
    particlesToRender,
    cameraPosition,
    cellSize,
    this.densityDistances.near,
    this.densityDistances.far
);
```

**Notas:**
- Probar con diferentes valores (15m/40m, 25m/60m) y medir FPS y calidad visual
- Ajustar según resultados de pruebas manuales
- Puede necesitar valores diferentes según hardware

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-008_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance

- **Reutilización de distancias**: Evitar recalcular distancias ya calculadas por LOD
- **Actualización incremental**: Solo actualizar instancias específicas en lugar de recrear meshes completos
- **Adaptación dinámica**: Ajustar límite según FPS para mantener 60 FPS estables
- **Debounce**: Evitar oscilación de límites con debounce de 2-3 segundos
- **Batch updates**: Agrupar actualizaciones de múltiples partículas por mesh

### Seguridad

- Validación de IDs de partículas antes de actualizar
- Manejo de errores cuando partículas o meshes no se encuentran

### Casos Edge

- **Partícula no encontrada en índice**: Manejar graciosamente, loguear warning
- **Mesh no encontrado**: Manejar graciosamente, loguear warning
- **Cámara muy cerca del terreno**: Todas las partículas cercanas, alta densidad (normal)
- **Cámara muy lejana**: Todas las partículas lejanas, baja densidad (normal)
- **Cambio rápido de FPS**: Debounce previene oscilación
- **Actualización mientras se renderiza**: Three.js maneja esto automáticamente
- **Partícula que cambia de tipo**: Requiere recargar mesh completo (future enhancement)

### Compatibilidad

- Mantener API de `ParticleLimiter` compatible con código existente
- `PerformanceManager` es opcional en constructores (compatibilidad hacia atrás)
- Permitir deshabilitar adaptación dinámica si es necesario

## Patrones de Código a Usar

- **Frontend (Three.js)**:
  - Clases ES6 para organización
  - InstancedMesh para renderizado eficiente
  - Map para índices y agrupaciones
  - Debounce para evitar cambios frecuentes
  - Flags configurables (enableAdaptiveLimiting, enableParticleLimiting)

## Dependencias

### Nuevas Dependencias (si aplica)
No se requieren nuevas dependencias. Todo usa código existente.

### Variables de Entorno (si aplica)
No se requieren nuevas variables de entorno.

## Archivos Principales Involucrados

1. `frontend/src/terrain/renderers/particle-renderer.js` - Renderizador principal (activar densidad, agregar adaptación, índice, actualización incremental)
2. `frontend/src/terrain/optimizations/particle-limiter.js` - Limitador (optimizar reutilización de distancias)
3. `frontend/src/terrain/optimizations/adaptive-limiter.js` - **NUEVO** - Adaptador dinámico según FPS
4. `frontend/src/terrain/manager.js` - Manager (pasar PerformanceManager, usar actualización incremental)
5. `frontend/src/terrain/systems/update-system.js` - Sistema de actualización (usar actualización incremental)
6. `frontend/src/app.js` - App principal (pasar PerformanceManager a TerrainManager)

## Testing Manual

### Escenarios de Prueba

1. **Demo 40x40m con cámara apuntando a partículas (Objetivo principal):**
   - Cargar demo completo (~400k partículas)
   - Apuntar cámara hacia el terreno
   - Verificar que limitación con densidad funciona (partículas lejanas reducidas)
   - Verificar que adaptación dinámica ajusta límite según FPS
   - **Objetivo: Alcanzar 60 FPS estables**
   - Verificar que calidad visual se mantiene aceptable

2. **Cámara apuntando al cielo:**
   - Verificar que FPS se mantiene alto (confirmar que frustum culling funciona bien)
   - Comparar con FPS cuando apunta a partículas (debe ser similar ahora)

3. **Adaptación dinámica:**
   - Mover cámara rápidamente para simular diferentes cargas
   - Verificar que límite se ajusta correctamente con debounce (cada 2-3 segundos)
   - Verificar que FPS mejora con ajuste
   - Verificar que no oscila entre límites

4. **Limitación con densidad:**
   - Verificar que partículas cercanas (< 20m) se mantienen al 100%
   - Verificar que partículas lejanas (> 50m) se reducen correctamente
   - Verificar que distribución visual se mantiene (no hay "huecos" visibles)
   - Verificar que partículas importantes (agua) se mantienen cuando es posible

5. **Actualización incremental (cuando esté implementado):**
   - Simular romper una partícula (cuando backend lo soporte)
   - Verificar que solo se actualiza esa instancia específica
   - Verificar que NO se recarga toda la dimensión
   - Verificar que no hay stutters o lag
   - Medir tiempo de actualización (debe ser < 1ms para una partícula)

6. **Batch updates:**
   - Simular talar árbol (múltiples partículas) cuando esté implementado
   - Verificar que actualización en batch es eficiente
   - Verificar que no hay lag perceptible

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos (solo cambios frontend)
2. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar que FPS alcanza 60 cuando cámara apunta a partículas
- [ ] Verificar que no hay errores en consola
- [ ] Verificar que calidad visual se mantiene aceptable
- [ ] Verificar que adaptación dinámica funciona (mover cámara y observar ajustes)

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Especialmente importante verificar el FPS después de cada fase para asegurar que se están alcanzando los objetivos.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
