# JDG-009 - Crear Terreno de Prueba para Primer Humano

## Descripción de la Tarea

Crear un terreno de prueba simple y controlado de 40x40 metros para facilitar la creación del primer humano del juego. El terreno debe incluir: terreno plano con tierra y hierba, un lago de agua en superficie, y exactamente 10 árboles distribuidos estratégicamente.

**Comportamiento actual:**
Actualmente existe un demo de bioma bosque 40x40m (`seed_demo.py`) que genera un terreno complejo con muchas partículas, árboles distribuidos aleatoriamente y un acuífero subterráneo. Este terreno es demasiado complejo para las pruebas iniciales de creación de humanos.

**Comportamiento esperado:**
- Terreno plano 40x40m con una montaña pequeña
- Capa base de piedra (z=-4)
- Capas de tierra (z=-3 a z=-1)
- Superficie de hierba (z=0) cubriendo todo excepto el lago y la montaña
- Un lago de agua (8x8 metros) en superficie (z=0 y z=1)
- Una montaña pequeña hecha con tierra y piedra en algún lugar del terreno
- Exactamente 10 árboles distribuidos evitando el lago y la montaña
- Sin acuífero subterráneo (terreno simple)

## Criterios de Aceptación

1. ❌ Terreno de prueba creado con dimensión 40x40 metros
2. ❌ Terreno completamente plano (sin elevaciones)
3. ❌ Capa base de piedra en z=-4 cubriendo todo el área
4. ❌ Capas de tierra en z=-3, z=-2, z=-1 cubriendo todo el área
5. ❌ Superficie de hierba en z=0 cubriendo todo el área (excepto donde está el lago y la montaña)
6. ❌ Un lago de agua creado en superficie (z=0 y z=1) de tamaño apropiado (8x8 metros aproximadamente)
7. ❌ Una montaña pequeña creada con tierra y piedra en algún lugar del terreno
8. ❌ Exactamente 10 árboles creados y distribuidos en el terreno
9. ❌ Árboles no se superponen con el lago ni con la montaña
10. ❌ Árboles distribuidos de forma visible y accesible
11. ❌ Terreno se puede cargar desde el frontend correctamente
12. ❌ Script de seed es ejecutable y crea el terreno de forma reproducible
13. ❌ Documentación del terreno creada (ubicación, cómo ejecutarlo)

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI) - No afectado directamente
- [ ] Frontend (Three.js) - No afectado directamente
- [x] Base de Datos (PostgreSQL) - Creación de nueva dimensión y partículas
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado

### Tecnologías Involucradas
- Backend: Python 3.11, asyncpg
- Base de datos: PostgreSQL 16
- Sistema de builders (TreeBuilder, EntityCreator)
- Plantillas de árboles existentes

## Pasos de Implementación

### Paso 1: Crear Estructura Base del Script de Seed

**Descripción:**
Crear el archivo `seed_human_test.py` con la estructura básica, imports necesarios, configuración de conexión a la base de datos y función principal `seed_human_test()`.

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py` (nuevo)

**Detalles de implementación:**
```python
"""
Script de seed para crear terreno de prueba 40x40m para primer humano
"""
import asyncio
import asyncpg
import os
import random
from dotenv import load_dotenv
from uuid import UUID
from src.database.terrain_builder import create_boundary_layer
from src.database.templates.trees.registry import get_random_tree_template
from src.database.creators.entity_creator import EntityCreator

load_dotenv()

# Configuración de conexión
POSTGRES_HOST = os.getenv("POSTGRES_HOST", "postgres")
POSTGRES_PORT = int(os.getenv("POSTGRES_PORT", 5432))
POSTGRES_USER = os.getenv("POSTGRES_USER", "juegodioses")
POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "juegodioses123")
POSTGRES_DB = os.getenv("POSTGRES_DB", "juego_dioses")


async def seed_human_test():
    """
    Crear terreno de prueba 40x40m para crear el primer humano.
    
    Estructura:
    - Terreno plano con tierra y hierba
    - Un lago de agua en superficie
    - 10 árboles distribuidos estratégicamente
    """
    conn = await asyncpg.connect(
        host=POSTGRES_HOST,
        port=POSTGRES_PORT,
        user=POSTGRES_USER,
        password=POSTGRES_PASSWORD,
        database=POSTGRES_DB
    )
    
    try:
        print("Iniciando seed de terreno de prueba - 40x40m para primer humano...")
        # Implementación en pasos siguientes
    except Exception as e:
        print(f"Error en seed: {e}")
        import traceback
        traceback.print_exc()
        raise
    finally:
        await conn.close()


if __name__ == "__main__":
    asyncio.run(seed_human_test())
```

**Notas:**
- Usar la misma estructura que `seed_demo.py` como referencia
- Incluir manejo de errores y logging
- Hacer el script ejecutable desde línea de comandos

**Recursos útiles:**
- `backend/src/database/seed_demo.py` - Script de referencia

---

### Paso 2: Implementar Limpieza y Creación de Dimensión

**Descripción:**
Agregar lógica para verificar si existe una dimensión de prueba anterior, eliminarla si existe (junto con sus partículas), y crear una nueva dimensión de 40x40 metros.

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Dentro de seed_human_test()

# 0. Borrar dimensión existente si existe
print("Verificando si existe dimensión de prueba anterior...")
existing_dim_id = await conn.fetchval("""
    SELECT id FROM juego_dioses.dimensiones 
    WHERE nombre = 'Terreno de Prueba - Primer Humano'
""")

if existing_dim_id:
    print(f"Eliminando dimensión existente (ID: {existing_dim_id}) y todas sus partículas...")
    # Borrar partículas primero (por foreign key)
    particulas_borradas = await conn.execute("""
        DELETE FROM juego_dioses.particulas 
        WHERE dimension_id = $1
    """, existing_dim_id)
    print(f"  Partículas eliminadas: {particulas_borradas.split()[-1]}")
    
    # Borrar dimensión
    await conn.execute("""
        DELETE FROM juego_dioses.dimensiones 
        WHERE id = $1
    """, existing_dim_id)
    print("  Dimensión eliminada correctamente")
else:
    print("  No se encontró dimensión de prueba anterior")

# 1. Crear dimensión 40x40m
# Tamaño de celda: 0.1m (400x400 celdas)
# Profundidad: z=-4 a z=1 (suficiente para terreno plano)
# Altura: z=0 a z=40 (suficiente para árboles)
print("Creando dimensión de prueba...")
dimension_id = await conn.fetchval("""
    INSERT INTO juego_dioses.dimensiones (
        nombre,
        ancho_metros,
        alto_metros,
        profundidad_maxima,
        altura_maxima,
        tamano_celda
    ) VALUES (
        'Terreno de Prueba - Primer Humano',
        40.0,
        40.0,
        -5,
        40,
        0.1
    ) RETURNING id
""")
print(f"Dimensión creada: ID = {dimension_id}")

# Calcular celdas
max_x = int(40.0 / 0.1)  # 400 celdas
max_y = int(40.0 / 0.1)  # 400 celdas
print(f"Tamaño en celdas: {max_x}x{max_y}")

# Crear capa límite
dimension_data = {
    'ancho_metros': 40.0,
    'alto_metros': 40.0,
    'profundidad_maxima': -5,
    'tamano_celda': 0.1
}
limite_count = await create_boundary_layer(conn, dimension_id, dimension_data)
print(f"Capa límite creada: {limite_count} partículas")
```

**Notas:**
- Usar nombre único para la dimensión: "Terreno de Prueba - Primer Humano"
- Tamaño de celda: 0.1m (más preciso que el demo que usa 0.25m)
- Profundidad máxima: -5 (suficiente para capa base)
- Altura máxima: 40 (suficiente para árboles)

---

### Paso 3: Obtener IDs de Tipos y Estados de Materia

**Descripción:**
Obtener los IDs de los tipos de partículas y estados de materia necesarios (tierra, hierba, piedra, agua, madera, hojas, sólido, líquido).

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Obtener IDs de tipos y estados necesarios
print("Obteniendo IDs de tipos y estados...")
hierba_id = await conn.fetchval(
    "SELECT id FROM juego_dioses.tipos_particulas WHERE nombre = 'hierba'"
)
tierra_id = await conn.fetchval(
    "SELECT id FROM juego_dioses.tipos_particulas WHERE nombre = 'tierra'"
)
piedra_id = await conn.fetchval(
    "SELECT id FROM juego_dioses.tipos_particulas WHERE nombre = 'piedra'"
)
agua_id = await conn.fetchval(
    "SELECT id FROM juego_dioses.tipos_particulas WHERE nombre = 'agua'"
)
solido_id = await conn.fetchval(
    "SELECT id FROM juego_dioses.estados_materia WHERE nombre = 'solido'"
)
liquido_id = await conn.fetchval(
    "SELECT id FROM juego_dioses.estados_materia WHERE nombre = 'liquido'"
)

if not all([hierba_id, tierra_id, piedra_id, agua_id, solido_id, liquido_id]):
    print("Error: Faltan tipos de partículas o estados de materia en la BD")
    print("Ejecuta primero los scripts de inicialización de la BD")
    return

print("IDs obtenidos correctamente")
```

**Notas:**
- Verificar que todos los tipos existen antes de continuar
- Los IDs de madera y hojas se obtienen automáticamente por EntityCreator

---

### Paso 4: Crear Capas Base del Terreno (Piedra y Tierra)

**Descripción:**
Crear la capa base de piedra en z=-4 y las capas de tierra en z=-3, z=-2, z=-1 cubriendo todo el área del terreno.

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Paso 1: Crear capa base de piedra (z=-4)
print("Creando capa base de piedra (z=-4)...")
particulas_piedra = []
for x in range(max_x):
    for y in range(max_y):
        particulas_piedra.append((
            dimension_id, x, y, -4,
            piedra_id, solido_id, 1.0, 15.0, 0.0, False,
            None, False, '{}'
        ))

await conn.executemany("""
    INSERT INTO juego_dioses.particulas 
    (dimension_id, celda_x, celda_y, celda_z, tipo_particula_id, estado_materia_id,
     cantidad, temperatura, energia, extraida, agrupacion_id, es_nucleo, propiedades)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13::jsonb)
    ON CONFLICT (dimension_id, celda_x, celda_y, celda_z) DO NOTHING
""", particulas_piedra)
print(f"Capa de piedra creada: {len(particulas_piedra)} partículas")

# Paso 2: Crear capas de tierra (z=-3, z=-2, z=-1)
print("Creando capas de tierra (z=-3 a z=-1)...")
particulas_tierra = []
batch_size = 10000

for x in range(max_x):
    for y in range(max_y):
        for z in range(-3, 0):  # z=-3, z=-2, z=-1
            particulas_tierra.append((
                dimension_id, x, y, z,
                tierra_id, solido_id, 1.0, 18.0, 0.0, False,
                None, False, '{}'
            ))
            
            # Insertar en batches para mejor rendimiento
            if len(particulas_tierra) >= batch_size:
                await conn.executemany("""
                    INSERT INTO juego_dioses.particulas 
                    (dimension_id, celda_x, celda_y, celda_z, tipo_particula_id, estado_materia_id,
                     cantidad, temperatura, energia, extraida, agrupacion_id, es_nucleo, propiedades)
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13::jsonb)
                    ON CONFLICT (dimension_id, celda_x, celda_y, celda_z) DO NOTHING
                """, particulas_tierra)
                print(f"  Insertadas {len(particulas_tierra)} partículas de tierra...")
                particulas_tierra = []

# Insertar resto
if particulas_tierra:
    await conn.executemany("""
        INSERT INTO juego_dioses.particulas 
        (dimension_id, celda_x, celda_y, celda_z, tipo_particula_id, estado_materia_id,
         cantidad, temperatura, energia, extraida, agrupacion_id, es_nucleo, propiedades)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13::jsonb)
        ON CONFLICT (dimension_id, celda_x, celda_y, celda_z) DO NOTHING
    """, particulas_tierra)

total_tierra = (max_x * max_y * 3)
print(f"Capas de tierra creadas: {total_tierra} partículas")
```

**Notas:**
- Usar batches para insertar grandes cantidades de partículas
- Temperatura de piedra: 15°C, tierra: 18°C
- Usar `ON CONFLICT DO NOTHING` para evitar errores si se ejecuta múltiples veces

---

### Paso 5: Crear Superficie de Hierba

**Descripción:**
Crear la superficie de hierba en z=0 cubriendo todo el área del terreno (el lago se creará después y reemplazará la hierba en esa área).

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Paso 3: Crear superficie de hierba (z=0)
print("Creando superficie de hierba (z=0)...")
particulas_hierba = []
for x in range(max_x):
    for y in range(max_y):
        particulas_hierba.append((
            dimension_id, x, y, 0,
            hierba_id, solido_id, 1.0, 20.0, 0.0, False,
            None, False, '{}'
        ))

await conn.executemany("""
    INSERT INTO juego_dioses.particulas 
    (dimension_id, celda_x, celda_y, celda_z, tipo_particula_id, estado_materia_id,
     cantidad, temperatura, energia, extraida, agrupacion_id, es_nucleo, propiedades)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13::jsonb)
    ON CONFLICT (dimension_id, celda_x, celda_y, celda_z) DO NOTHING
""", particulas_hierba)
print(f"Superficie de hierba creada: {len(particulas_hierba)} partículas")
```

**Notas:**
- Temperatura de hierba: 20°C
- La hierba se creará primero, luego el lago la reemplazará en su área

---

### Paso 6: Definir y Crear el Lago

**Descripción:**
Definir la posición y tamaño del lago (8x8 metros, aproximadamente 80x80 celdas) y crear partículas de agua en z=0 y z=1 en esa área. El lago se ubicará en una posición específica (ej: centro del terreno o esquina).

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Paso 4: Crear lago de agua
print("Creando lago de agua...")

# Definir posición y tamaño del lago
# Lago de 8x8 metros = 80x80 celdas (con celda de 0.1m)
lago_tamano_celdas = 80  # 8 metros / 0.1m = 80 celdas
lago_centro_x = max_x // 2  # Centro del terreno en X
lago_centro_y = max_y // 2  # Centro del terreno en Y
lago_inicio_x = lago_centro_x - lago_tamano_celdas // 2
lago_fin_x = lago_centro_x + lago_tamano_celdas // 2
lago_inicio_y = lago_centro_y - lago_tamano_celdas // 2
lago_fin_y = lago_centro_y + lago_tamano_celdas // 2

print(f"Lago: {lago_tamano_celdas}x{lago_tamano_celdas} celdas (8x8 metros)")
print(f"Posición: ({lago_inicio_x}, {lago_inicio_y}) a ({lago_fin_x}, {lago_fin_y})")

# Crear partículas de agua en z=0 y z=1
particulas_agua = []
for x in range(lago_inicio_x, lago_fin_x):
    for y in range(lago_inicio_y, lago_fin_y):
        # Verificar límites
        if 0 <= x < max_x and 0 <= y < max_y:
            # Agua en z=0 (reemplaza hierba)
            particulas_agua.append((
                dimension_id, x, y, 0,
                agua_id, liquido_id, 1.0, 15.0, 0.0, False,
                None, False, '{}'
            ))
            # Agua en z=1 (profundidad del lago)
            particulas_agua.append((
                dimension_id, x, y, 1,
                agua_id, liquido_id, 1.0, 15.0, 0.0, False,
                None, False, '{}'
            ))

await conn.executemany("""
    INSERT INTO juego_dioses.particulas 
    (dimension_id, celda_x, celda_y, celda_z, tipo_particula_id, estado_materia_id,
     cantidad, temperatura, energia, extraida, agrupacion_id, es_nucleo, propiedades)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13::jsonb)
    ON CONFLICT (dimension_id, celda_x, celda_y, celda_z) DO UPDATE
    SET tipo_particula_id = EXCLUDED.tipo_particula_id,
        estado_materia_id = EXCLUDED.estado_materia_id,
        temperatura = EXCLUDED.temperatura
""", particulas_agua)
print(f"Lago creado: {len(particulas_agua)} partículas de agua")
```

**Notas:**
- Lago centrado en el terreno para fácil acceso
- Usar `ON CONFLICT DO UPDATE` para reemplazar hierba con agua
- Temperatura del agua: 15°C
- Profundidad: 2 niveles (z=0 y z=1) para que sea visible

---

### Paso 7: Crear Montaña Pequeña

**Descripción:**
Crear una montaña pequeña hecha con tierra y piedra en algún lugar del terreno. La montaña debe tener una forma cónica simple y estar ubicada lejos del lago para no interferir.

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Paso 5: Crear montaña pequeña
print("Creando montaña pequeña...")

# Definir posición y tamaño de la montaña
# Montaña de aproximadamente 4x4 metros en la base, altura de 3-4 niveles
montana_tamano_base = 40  # 4 metros = 40 celdas
montana_altura = 4  # 4 niveles de altura (z=1 a z=4)
montana_centro_x = max_x - 100  # Esquina superior derecha, lejos del lago
montana_centro_y = max_y - 100
montana_inicio_x = montana_centro_x - montana_tamano_base // 2
montana_fin_x = montana_centro_x + montana_tamano_base // 2
montana_inicio_y = montana_centro_y - montana_tamano_base // 2
montana_fin_y = montana_centro_y + montana_tamano_base // 2

print(f"Montaña: base {montana_tamano_base}x{montana_tamano_base} celdas (4x4 metros)")
print(f"Posición: ({montana_inicio_x}, {montana_inicio_y}) a ({montana_fin_x}, {montana_fin_y})")
print(f"Altura: {montana_altura} niveles (z=1 a z={montana_altura})")

# Crear montaña con forma cónica
particulas_montana = []
for nivel in range(montana_altura):
    z = nivel + 1  # z=1, z=2, z=3, z=4
    # Reducir tamaño de la base en cada nivel (forma cónica)
    factor_reduccion = 1.0 - (nivel * 0.2)  # Reducir 20% por nivel
    tamano_nivel = int(montana_tamano_base * factor_reduccion)
    if tamano_nivel < 10:  # Mínimo 1 metro
        tamano_nivel = 10
    
    offset = (montana_tamano_base - tamano_nivel) // 2
    
    for x in range(montana_inicio_x + offset, montana_inicio_x + offset + tamano_nivel):
        for y in range(montana_inicio_y + offset, montana_inicio_y + offset + tamano_nivel):
            # Verificar límites
            if 0 <= x < max_x and 0 <= y < max_y:
                # Base de la montaña (z=1): mezcla de tierra y piedra
                if z == 1:
                    # 70% tierra, 30% piedra en la base
                    tipo = tierra_id if random.random() < 0.7 else piedra_id
                else:
                    # Niveles superiores: más piedra (50% tierra, 50% piedra)
                    tipo = tierra_id if random.random() < 0.5 else piedra_id
                
                particulas_montana.append((
                    dimension_id, x, y, z,
                    tipo, solido_id, 1.0, 15.0, 0.0, False,
                    None, False, '{}'
                ))

await conn.executemany("""
    INSERT INTO juego_dioses.particulas 
    (dimension_id, celda_x, celda_y, celda_z, tipo_particula_id, estado_materia_id,
     cantidad, temperatura, energia, extraida, agrupacion_id, es_nucleo, propiedades)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13::jsonb)
    ON CONFLICT (dimension_id, celda_x, celda_y, celda_z) DO UPDATE
    SET tipo_particula_id = EXCLUDED.tipo_particula_id,
        temperatura = EXCLUDED.temperatura
""", particulas_montana)
print(f"Montaña creada: {len(particulas_montana)} partículas")
```

**Notas:**
- Montaña ubicada en esquina superior derecha, lejos del lago (centro)
- Forma cónica: base más ancha, se reduce en altura
- Base: 4x4 metros (40x40 celdas)
- Altura: 4 niveles (z=1 a z=4)
- Mezcla de tierra y piedra: más tierra en la base, más piedra en la cima
- Temperatura: 15°C (similar a piedra)
- Reemplaza hierba en el área de la montaña

---

### Paso 8: Generar Posiciones de los 10 Árboles

**Descripción:**
Crear un algoritmo para generar exactamente 10 posiciones de árboles distribuidas estratégicamente en el terreno, evitando el área del lago y con espaciado mínimo entre árboles.

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Paso 5: Generar posiciones de 10 árboles
print("Generando posiciones de 10 árboles...")

# Definir áreas a evitar (lago y montaña)
lago_area = set()
for x in range(lago_inicio_x - 5, lago_fin_x + 5):  # Margen de 5 celdas alrededor del lago
    for y in range(lago_inicio_y - 5, lago_fin_y + 5):
        if 0 <= x < max_x and 0 <= y < max_y:
            lago_area.add((x, y))

montana_area = set()
for x in range(montana_inicio_x - 5, montana_fin_x + 5):  # Margen de 5 celdas alrededor de la montaña
    for y in range(montana_inicio_y - 5, montana_fin_y + 5):
        if 0 <= x < max_x and 0 <= y < max_y:
            montana_area.add((x, y))

# Áreas prohibidas = lago + montaña
areas_prohibidas = lago_area | montana_area

# Generar posiciones de árboles
posiciones_arboles = []
espaciado_minimo = 40  # 4 metros mínimo entre árboles (40 celdas)
random.seed(42)  # Semilla para reproducibilidad

intentos_maximos = 1000
intentos = 0

while len(posiciones_arboles) < 10 and intentos < intentos_maximos:
    intentos += 1
    
    # Generar posición aleatoria
    x = random.randint(20, max_x - 20)  # Margen de 2 metros desde los bordes
    y = random.randint(20, max_y - 20)
    
    # Verificar que no esté en áreas prohibidas (lago o montaña)
    if (x, y) in areas_prohibidas:
        continue
    
    # Verificar espaciado mínimo con otros árboles
    muy_cerca = False
    for (ax, ay) in posiciones_arboles:
        distancia = ((x - ax) ** 2 + (y - ay) ** 2) ** 0.5
        if distancia < espaciado_minimo:
            muy_cerca = True
            break
    
    if not muy_cerca:
        posiciones_arboles.append((x, y))
        print(f"  Árbol {len(posiciones_arboles)}: posición ({x}, {y})")

if len(posiciones_arboles) < 10:
    print(f"Advertencia: Solo se generaron {len(posiciones_arboles)} posiciones de árboles")
else:
    print(f"Posiciones de árboles generadas: {len(posiciones_arboles)} árboles")
```

**Notas:**
- Usar semilla fija (42) para reproducibilidad
- Espaciado mínimo: 4 metros (40 celdas)
- Evitar área del lago y montaña con margen de seguridad
- Evitar bordes del terreno (margen de 2 metros)

---

### Paso 9: Crear los 10 Árboles usando EntityCreator

**Descripción:**
Usar `EntityCreator` y plantillas de árboles existentes para crear los 10 árboles en las posiciones generadas.

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Paso 6: Crear árboles usando EntityCreator
print("Creando árboles con plantillas...")

# Crear EntityCreator
creator = EntityCreator(conn, dimension_id)

# Seleccionar plantillas para los árboles
templates_arboles = []
for i in range(10):
    template = get_random_tree_template()
    templates_arboles.append(template)

total_particulas_arboles = 0
stats_templates = {}

for idx, ((arbol_x, arbol_y), template) in enumerate(zip(posiciones_arboles, templates_arboles), 1):
    # Actualizar estadísticas
    if template.nombre not in stats_templates:
        stats_templates[template.nombre] = 0
    stats_templates[template.nombre] += 1
    
    # Crear árbol usando EntityCreator
    particulas_creadas = await creator.create_entity(template, arbol_x, arbol_y, 0)
    total_particulas_arboles += particulas_creadas
    
    print(f"  Árbol {idx}/{len(posiciones_arboles)} ({template.nombre}) en ({arbol_x}, {arbol_y}): {particulas_creadas} partículas")

print(f"\nÁrboles creados: {len(posiciones_arboles)} árboles, {total_particulas_arboles} partículas")
print("Distribución por tipo de árbol:")
for tipo, cantidad in stats_templates.items():
    print(f"  - {tipo}: {cantidad} árboles")
```

**Notas:**
- Usar `EntityCreator` para simplificar la creación
- Usar plantillas aleatorias para variedad
- Registrar estadísticas de creación

---

### Paso 10: Agregar Verificación y Estadísticas Finales

**Descripción:**
Agregar código para verificar la creación del terreno, contar partículas por tipo y mostrar estadísticas finales.

**Archivos a modificar/crear:**
- `backend/src/database/seed_human_test.py`

**Detalles de implementación:**
```python
# Paso 7: Verificar y mostrar estadísticas
print("\n" + "="*60)
print("Verificando creación del terreno...")

# Contar total de partículas
total_particulas = await conn.fetchval("""
    SELECT COUNT(*) FROM juego_dioses.particulas
    WHERE dimension_id = $1 AND extraida = false
""", dimension_id)

# Estadísticas por tipo
stats = await conn.fetch("""
    SELECT tp.nombre, COUNT(*) as cantidad
    FROM juego_dioses.particulas p
    JOIN juego_dioses.tipos_particulas tp ON p.tipo_particula_id = tp.id
    WHERE p.dimension_id = $1 AND p.extraida = false
    GROUP BY tp.nombre
    ORDER BY cantidad DESC
""", dimension_id)

print("\n" + "="*60)
print("Seed de terreno de prueba completado exitosamente!")
print(f"Dimensión ID: {dimension_id}")
print(f"Tamaño: {max_x}x{max_y} celdas (40m x 40m)")
print(f"Total partículas: {total_particulas}")
print(f"Árboles creados: {len(posiciones_arboles)}")
print(f"Lago: {lago_tamano_celdas}x{lago_tamano_celdas} celdas (8m x 8m)")
print(f"Montaña: base {montana_tamano_base}x{montana_tamano_base} celdas (4m x 4m), altura {montana_altura} niveles")
print("\nDistribución por tipo:")
for stat in stats:
    print(f"  - {stat['nombre']}: {stat['cantidad']} partículas")
print("="*60)
```

**Notas:**
- Mostrar estadísticas claras y completas
- Verificar que todos los elementos se crearon correctamente

---

### Paso 11: Probar el Script y Verificar en Base de Datos

**Descripción:**
Ejecutar el script de seed y verificar que se crea correctamente el terreno en la base de datos.

**Archivos a modificar/crear:**
- Ninguno (solo ejecución)

**Detalles de implementación:**
```bash
# Desde el directorio del proyecto
cd backend
python -m src.database.seed_human_test
```

**Verificaciones:**
1. Verificar que el script se ejecuta sin errores
2. Verificar en PostgreSQL que se creó la dimensión:
   ```sql
   SELECT id, nombre, ancho_metros, alto_metros 
   FROM juego_dioses.dimensiones 
   WHERE nombre = 'Terreno de Prueba - Primer Humano';
   ```
3. Verificar que se crearon las partículas:
   ```sql
   SELECT tp.nombre, COUNT(*) as cantidad
   FROM juego_dioses.particulas p
   JOIN juego_dioses.tipos_particulas tp ON p.tipo_particula_id = tp.id
   WHERE p.dimension_id = (SELECT id FROM juego_dioses.dimensiones WHERE nombre = 'Terreno de Prueba - Primer Humano')
   GROUP BY tp.nombre
   ORDER BY cantidad DESC;
   ```
4. Verificar que hay exactamente 10 árboles (contar agrupaciones de tipo árbol)
5. Verificar que el lago tiene agua en z=0 y z=1
6. Verificar que la montaña tiene tierra y piedra en z=1 a z=4

**Notas:**
- Ejecutar desde el contenedor Docker si es necesario
- Verificar logs del script para errores
- Ajustar posiciones o tamaños si es necesario

---

### Paso 12: Verificar Renderizado en Frontend

**Descripción:**
Cargar el terreno desde el frontend y verificar que se renderiza correctamente: terreno plano, lago visible, árboles distribuidos.

**Archivos a modificar/crear:**
- Ninguno (solo verificación)

**Detalles de implementación:**
1. Modificar temporalmente el frontend para cargar la nueva dimensión (o agregar endpoint para seleccionarla)
2. Cargar el terreno en el navegador
3. Verificar visualmente:
   - Terreno tiene una montaña pequeña visible
   - Lago es visible y tiene agua
   - 10 árboles están distribuidos y no están en el lago ni en la montaña
   - Superficie tiene hierba excepto donde está el lago y la montaña

**Notas:**
- Puede requerir modificar temporalmente `app.js` para cargar la nueva dimensión
- Verificar que no hay errores en la consola del navegador
- Verificar que el terreno se carga completamente

---

### Paso 13: Documentar el Terreno

**Descripción:**
Crear documentación sobre el terreno de prueba: cómo ejecutarlo, qué contiene, cómo usarlo.

**Archivos a modificar/crear:**
- `backend/src/database/README.md` (actualizar)
- `instructions/examples/terrenos/terreno-prueba-humano.md` (nuevo, opcional)

**Detalles de implementación:**
```markdown
# Terreno de Prueba - Primer Humano

## Descripción
Terreno simple de 40x40 metros diseñado para facilitar la creación del primer humano del juego.

## Características
- Tamaño: 40x40 metros (400x400 celdas con celda de 0.1m)
- Terreno plano con una montaña pequeña
- Capa base de piedra (z=-4)
- Capas de tierra (z=-3 a z=-1)
- Superficie de hierba (z=0)
- Un lago de agua (8x8 metros) en el centro
- Una montaña pequeña (4x4 metros base, 4 niveles de altura) hecha con tierra y piedra
- 10 árboles distribuidos estratégicamente

## Cómo Ejecutar
```bash
cd backend
python -m src.database.seed_human_test
```

## Nombre de la Dimensión
"Terreno de Prueba - Primer Humano"

## Recursos Disponibles
- Agua: En el lago (8x8 metros)
- Madera: En los 10 árboles
- Hierba: En toda la superficie (excepto lago y montaña)
- Tierra: En el subsuelo y en la montaña
- Piedra: En la capa base y en la montaña
```

**Notas:**
- Actualizar README del módulo database si es necesario
- Documentar cómo cargar el terreno desde el frontend

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-009_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Usar batches para insertar grandes cantidades de partículas (10,000 partículas por batch)
- El terreno es simple y tiene menos partículas que el demo actual (sin acuífero)
- Optimizado para carga rápida

### Seguridad
- Consultas SQL parametrizadas (prevención SQL injection)
- Validación de límites antes de crear partículas
- Manejo de errores apropiado

### Casos Edge
- Terreno ya existe: Se elimina y recrea
- Árboles muy cerca del lago o montaña: Se verifica espaciado con margen de seguridad
- Árboles en los bordes: Se evita con margen de 2 metros
- Montaña muy grande o muy pequeña: Verificar tamaño y altura
- Script ejecutado múltiples veces: Idempotente con `ON CONFLICT`

### Compatibilidad
- Compatible con sistema de renderizado del frontend existente
- Usa tipos de partículas y estados de materia existentes
- Compatible con sistema de builders y creators

## Patrones de Código a Usar

- **Backend (Python)**: 
  - async/await para operaciones I/O
  - Manejo de errores con try/except
  - Logging estructurado con print
  - Docstrings en formato Google
  - Type hints donde sea posible

- **Base de Datos**: 
  - asyncpg para conexiones asíncronas
  - Consultas parametrizadas
  - Batches para mejor rendimiento
  - `ON CONFLICT` para idempotencia

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna (usa dependencias existentes)

### Variables de Entorno (si aplica)
- `POSTGRES_HOST`, `POSTGRES_PORT`, `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB`: Configuración PostgreSQL (ya existentes)

## Archivos Principales Involucrados

1. `backend/src/database/seed_human_test.py` - Script principal de seed (nuevo)
2. `backend/src/database/seed_demo.py` - Script de referencia
3. `backend/src/database/terrain_builder.py` - Para crear capa límite
4. `backend/src/database/creators/entity_creator.py` - Para crear árboles
5. `backend/src/database/templates/trees/registry.py` - Para obtener plantillas de árboles

## Testing

### Tests a Crear/Modificar
Ninguno (testing manual según escenarios del ticket)

### Escenarios de Prueba
1. Ejecutar script y verificar creación en BD
2. Cargar terreno desde frontend y verificar renderizado
3. Verificar distribución de elementos (lago, montaña, árboles)
4. Verificar recursos disponibles (agua, madera, hierba, tierra, piedra)
5. Verificar que la montaña es visible y tiene forma cónica
6. Ejecutar script múltiples veces (idempotencia)

## Deployment

### Orden de Deployment
1. Backend: No requiere rebuild (solo nuevo script)
2. Base de datos: Ejecutar script de seed cuando sea necesario
3. Frontend: No requiere cambios

### Verificación Post-Deployment
- [ ] Verificar que el script se ejecuta correctamente
- [ ] Verificar creación de dimensión en PostgreSQL
- [ ] Verificar que se crearon todas las partículas
- [ ] Verificar renderizado en frontend
- [ ] Verificar que el terreno tiene la montaña, lago y todos los elementos

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

