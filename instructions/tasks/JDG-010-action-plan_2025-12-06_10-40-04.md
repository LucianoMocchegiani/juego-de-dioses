# JDG-010 - Primer Personaje Jugable (Humano) - Action Plan

## Descripción de la Tarea

Implementar el primer personaje jugable del juego: un humano que pueda ser controlado por el jugador con las siguientes acciones básicas:
- **Agacharse**: Reducir altura del personaje para pasar por espacios bajos
- **Caminar**: Movimiento básico en todas las direcciones
- **Correr**: Movimiento rápido (más rápido que caminar)
- **Saltar**: Salto vertical para superar obstáculos o terrenos elevados
- **Golpear**: Acción de ataque/impacto con las manos o herramientas
- **Agarrar**: Interacción para tomar objetos o partículas del mundo

**Comportamiento actual:**
Actualmente el juego solo permite visualizar el terreno y las partículas desde una cámara orbital (OrbitControls). No existe ningún sistema de personajes jugables, controles de jugador, física de movimiento, ni interacciones con el mundo.

**Comportamiento esperado:**
- Personaje humano renderizado en Three.js (modelo 3D básico o primitivo)
- Posición del personaje sincronizada con el terreno (coordenadas x, y, z en celdas)
- Personaje visible en la escena y controlable por el jugador
- Cámara que sigue al personaje (tercera persona o primera persona)
- Controles: WASD/Flechas (movimiento), Shift (correr), Espacio (saltar), Ctrl/C (agacharse), Click Izquierdo (golpear), Click Derecho/E (agarrar)
- Física: gravedad, colisiones con partículas sólidas, detección de suelo
- Animaciones básicas: idle, caminar, correr, saltar, agacharse

## Criterios de Aceptación

1. ❌ El personaje se renderiza correctamente en la escena 3D del terreno de prueba
2. ❌ El personaje puede moverse en 4 direcciones usando WASD o flechas
3. ❌ El personaje puede correr manteniendo Shift + dirección de movimiento
4. ❌ El personaje puede saltar presionando Espacio (solo si está en el suelo)
5. ❌ El personaje puede agacharse manteniendo Ctrl o C
6. ❌ El personaje no atraviesa partículas sólidas del terreno
7. ❌ El personaje tiene gravedad y cae si no hay suelo debajo
8. ❌ El personaje puede golpear con click izquierdo (visual y funcional)
9. ❌ El personaje puede agarrar/interactuar con click derecho o E
10. ❌ La cámara sigue al personaje (tercera persona o primera persona)
11. ❌ El personaje se orienta según la dirección de movimiento
12. ❌ Las animaciones básicas funcionan (idle, caminar, correr, saltar, agacharse)
13. ❌ El sistema de colisiones detecta correctamente las partículas sólidas
14. ❌ El personaje puede interactuar con el terreno de prueba (JDG-009)

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js) - Sistema completo de personaje jugable
- [ ] Backend (FastAPI) - Posiblemente para guardar posición del jugador (futuro)
- [ ] Base de Datos (PostgreSQL) - Posiblemente para persistir estado del jugador (futuro)

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js
- Sistema ECS: Entity Component System implementado desde cero
- Física: Sistema de física simple sin motor externo (gravedad, velocidad, aceleración)
- Colisiones: Detección de colisiones con partículas del viewport
- Animaciones: Three.js AnimationMixer (futuro) o animaciones simples (escalado, rotación)

## Pasos de Implementación

### Paso 1: Crear Estructura Base del Sistema ECS

**Descripción:**
Crear la estructura base del sistema ECS (Entity Component System) que será el núcleo del sistema de entidades. Esto incluye el ECSManager y la clase base System.

**Archivos a crear:**
- `frontend/src/ecs/manager.js` - ECSManager (núcleo del sistema)
- `frontend/src/ecs/system.js` - Clase base System
- `frontend/src/ecs/index.js` - Exportaciones principales
- `frontend/src/ecs/README.md` - Documentación del módulo ECS

**Detalles de implementación:**
```javascript
// frontend/src/ecs/manager.js
export class ECSManager {
    constructor() {
        this.nextEntityId = 1;
        this.components = new Map(); // Map<ComponentType, Map<EntityId, ComponentData>>
        this.entities = new Map(); // Map<EntityId, Set<ComponentType>>
        this.systems = [];
        this.queryCache = new Map();
    }
    
    createEntity() { /* ... */ }
    destroyEntity(entityId) { /* ... */ }
    addComponent(entityId, componentType, componentData) { /* ... */ }
    getComponent(entityId, componentType) { /* ... */ }
    hasComponent(entityId, componentType) { /* ... */ }
    removeComponent(entityId, componentType) { /* ... */ }
    query(...componentTypes) { /* ... */ }
    registerSystem(system) { /* ... */ }
    update(deltaTime) { /* ... */ }
}

// frontend/src/ecs/system.js
export class System {
    constructor() {
        this.ecs = null;
        this.enabled = true;
        this.priority = 0;
        this.requiredComponents = [];
    }
    
    setECSManager(ecs) { /* ... */ }
    getEntities() { /* ... */ }
    update(deltaTime) { /* ... */ }
}
```

**Notas:**
- El ECSManager debe gestionar entidades, componentes y sistemas
- Implementar sistema de queries con cache para optimización
- Los sistemas deben poder registrarse y actualizarse automáticamente
- **⚠️ READMEs:** Crear `frontend/src/ecs/README.md` explicando el sistema ECS, conceptos, y uso básico

**Recursos útiles:**
- Ver análisis de arquitectura: `instructions/analysis/JDG-010-architecture-analysis_2025-12-06_10-18-44.md`

---

### Paso 2: Crear Componentes Base

**Descripción:**
Crear los componentes base que representarán las características de las entidades: Position, Physics, Render, e Input.

**Archivos a crear:**
- `frontend/src/ecs/components/position.js` - Componente de posición
- `frontend/src/ecs/components/physics.js` - Componente de física
- `frontend/src/ecs/components/render.js` - Componente de renderizado
- `frontend/src/ecs/components/input.js` - Componente de input
- `frontend/src/ecs/components/index.js` - Exportaciones de componentes

**Detalles de implementación:**
```javascript
// frontend/src/ecs/components/position.js
export class PositionComponent {
    constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}

// frontend/src/ecs/components/physics.js
export class PhysicsComponent {
    constructor(options = {}) {
        this.velocity = options.velocity || { x: 0, y: 0, z: 0 };
        this.acceleration = options.acceleration || { x: 0, y: 0, z: 0 };
        this.mass = options.mass || 1;
        this.useGravity = options.useGravity !== undefined ? options.useGravity : true;
        this.isGrounded = options.isGrounded !== undefined ? options.isGrounded : false;
        this.groundFriction = options.groundFriction || 0.8;
        this.airFriction = options.airFriction || 0.95;
        this.maxVelocity = options.maxVelocity || { x: Infinity, y: Infinity, z: Infinity };
    }
}

// frontend/src/ecs/components/render.js
export class RenderComponent {
    constructor(options = {}) {
        this.mesh = options.mesh || null;
        this.visible = options.visible !== undefined ? options.visible : true;
        this.castShadow = options.castShadow || false;
        this.receiveShadow = options.receiveShadow || false;
    }
}

// frontend/src/ecs/components/input.js
export class InputComponent {
    constructor() {
        this.keysPressed = new Set();
        this.keysDown = new Set();
        this.keysUp = new Set();
        this.moveDirection = { x: 0, y: 0, z: 0 };
        this.isRunning = false;
        this.wantsToJump = false;
        this.wantsToCrouch = false;
        this.wantsToAttack = false;
        this.wantsToGrab = false;
    }
}
```

**Notas:**
- Los componentes solo almacenan datos, no lógica
- PositionComponent usa coordenadas en celdas (no metros)
- PhysicsComponent incluye todas las propiedades necesarias para física
- RenderComponent almacena referencia al mesh de Three.js
- InputComponent almacena estado de input del jugador

---

### Paso 3: Crear InputManager

**Descripción:**
Crear el InputManager que captura eventos de teclado y mouse y proporciona una interfaz única para los sistemas.

**Archivos a crear:**
- `frontend/src/systems/input-manager.js` - Gestor centralizado de input
- `frontend/src/systems/README.md` - Documentación del módulo systems (si no existe)

**Detalles de implementación:**
```javascript
// frontend/src/systems/input-manager.js
export class InputManager {
    constructor() {
        this.keysPressed = new Set();
        this.keysDown = new Set();
        this.keysUp = new Set();
        this.mouseButtonsPressed = new Set();
        this.mouseButtonsDown = new Set();
        this.mousePosition = { x: 0, y: 0 };
        this.mouseDelta = { x: 0, y: 0 };
        
        // Bind y attach listeners
        this.attachListeners();
    }
    
    attachListeners() {
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
        document.addEventListener('mousedown', this.handleMouseDown.bind(this));
        document.addEventListener('mouseup', this.handleMouseUp.bind(this));
        document.addEventListener('mousemove', this.handleMouseMove.bind(this));
    }
    
    clearFrame() {
        // Limpiar estados de frame (keysDown, keysUp, etc.)
    }
}
```

**Notas:**
- El InputManager debe capturar todos los eventos de teclado y mouse
- Implementar métodos para verificar teclas presionadas, down, up
- Implementar clearFrame() para limpiar estados de frame al final de cada frame
- Prevenir comportamiento por defecto para teclas de juego (WASD, Space, Shift, etc.)
- **⚠️ READMEs:** Actualizar `frontend/src/systems/README.md` si existe, o crear uno nuevo

---

### Paso 4: Crear Sistemas Base (InputSystem, PhysicsSystem, RenderSystem)

**Descripción:**
Crear los sistemas que procesan los componentes: InputSystem (procesa input), PhysicsSystem (aplica física), y RenderSystem (actualiza renderizado).

**Archivos a crear:**
- `frontend/src/ecs/systems/input-system.js` - Sistema de input
- `frontend/src/ecs/systems/physics-system.js` - Sistema de física
- `frontend/src/ecs/systems/render-system.js` - Sistema de renderizado
- `frontend/src/ecs/systems/index.js` - Exportaciones de sistemas

**Detalles de implementación:**
```javascript
// frontend/src/ecs/systems/input-system.js
import { System } from '../system.js';

export class InputSystem extends System {
    constructor(inputManager) {
        super();
        this.inputManager = inputManager;
        this.requiredComponents = ['Input'];
    }
    
    update(deltaTime) {
        const entities = this.getEntities();
        for (const entityId of entities) {
            const input = this.ecs.getComponent(entityId, 'Input');
            // Actualizar input desde InputManager
            // Calcular moveDirection desde teclas presionadas
            // Detectar acciones (jump, crouch, attack, grab)
        }
    }
}

// frontend/src/ecs/systems/physics-system.js
import { System } from '../system.js';

export class PhysicsSystem extends System {
    constructor(options = {}) {
        super();
        this.requiredComponents = ['Physics', 'Position'];
        this.gravity = options.gravity || -9.8;
        this.fixedTimestep = options.fixedTimestep || 1/60;
        this.accumulator = 0;
    }
    
    update(deltaTime) {
        this.accumulator += deltaTime;
        while (this.accumulator >= this.fixedTimestep) {
            this.updatePhysics(this.fixedTimestep);
            this.accumulator -= this.fixedTimestep;
        }
    }
    
    updatePhysics(timestep) {
        // Aplicar gravedad
        // Actualizar velocidad con aceleración
        // Aplicar fricción
        // Actualizar posición con velocidad
    }
}

// frontend/src/ecs/systems/render-system.js
import { System } from '../system.js';

export class RenderSystem extends System {
    constructor(cellSize) {
        super();
        this.requiredComponents = ['Render', 'Position'];
        this.cellSize = cellSize;
    }
    
    update(deltaTime) {
        const entities = this.getEntities();
        for (const entityId of entities) {
            const render = this.ecs.getComponent(entityId, 'Render');
            const position = this.ecs.getComponent(entityId, 'Position');
            // Actualizar posición del mesh (convertir de celdas a metros)
            render.mesh.position.set(
                position.x * this.cellSize,
                position.z * this.cellSize,
                position.y * this.cellSize
            );
        }
    }
}
```

**Notas:**
- InputSystem debe procesar input del InputManager y actualizar InputComponent
- PhysicsSystem debe usar timestep fijo para física estable
- RenderSystem debe convertir coordenadas de celdas a metros para Three.js
- Los sistemas deben usar queries para obtener entidades con componentes requeridos

---

### Paso 5: Crear Factory para Entidad de Jugador

**Descripción:**
Crear una factory que crea una entidad de jugador completa con todos los componentes necesarios y el mesh de Three.js.

**Archivos a crear:**
- `frontend/src/ecs/factories/player-factory.js` - Factory para crear jugador
- `frontend/src/ecs/factories/README.md` - Documentación de factories (si aplica)

**Detalles de implementación:**
```javascript
// frontend/src/ecs/factories/player-factory.js
import * as THREE from 'three';
import { PositionComponent, PhysicsComponent, RenderComponent, InputComponent } from '../components/index.js';

export class PlayerFactory {
    static createPlayer(options) {
        const { ecs, scene, x = 80, y = 80, z = 1, cellSize = 0.25 } = options;
        
        // Crear entidad
        const playerId = ecs.createEntity();
        
        // Crear mesh del jugador (primitivo simple)
        const group = new THREE.Group();
        
        // Cuerpo (cilindro)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.0, 8);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.5;
        body.castShadow = true;
        group.add(body);
        
        // Cabeza (esfera)
        const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
        const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 1.25;
        head.castShadow = true;
        group.add(head);
        
        // Escalar según tamaño de celda
        group.scale.set(cellSize, cellSize, cellSize);
        scene.add(group);
        
        // Agregar componentes
        ecs.addComponent(playerId, 'Position', new PositionComponent(x, y, z));
        ecs.addComponent(playerId, 'Physics', new PhysicsComponent({
            mass: 70,
            useGravity: true,
            isGrounded: false,
            maxVelocity: { x: 5, y: 10, z: 5 }
        }));
        ecs.addComponent(playerId, 'Render', new RenderComponent({ mesh: group }));
        ecs.addComponent(playerId, 'Input', new InputComponent());
        
        return playerId;
    }
}
```

**Notas:**
- El mesh del jugador debe ser simple (primitivos Three.js) para MVP
- El mesh debe escalarse según cellSize
- Todos los componentes necesarios deben agregarse a la entidad
- La factory debe retornar el ID de la entidad creada

---

### Paso 6: Integrar ECS en app.js y Crear Jugador

**Descripción:**
Integrar el sistema ECS en la aplicación principal, crear el jugador, y registrar los sistemas en el loop de animación.

**Archivos a modificar:**
- `frontend/src/app.js` - Integrar ECS y crear jugador

**Detalles de implementación:**
```javascript
// frontend/src/app.js
import { ECSManager } from './ecs/index.js';
import { InputSystem, PhysicsSystem, RenderSystem } from './ecs/systems/index.js';
import { PlayerFactory } from './ecs/factories/player-factory.js';
import { InputManager } from './systems/input-manager.js';

export class App {
    constructor(container) {
        // ... código existente ...
        
        // Inicializar ECS
        this.ecs = new ECSManager();
        
        // Inicializar InputManager
        this.inputManager = new InputManager();
        
        // Inicializar sistemas
        this.inputSystem = new InputSystem(this.inputManager);
        this.physicsSystem = new PhysicsSystem({ gravity: -9.8 });
        this.renderSystem = new RenderSystem(0.25); // cellSize = 0.25m
        
        // Registrar sistemas
        this.ecs.registerSystem(this.inputSystem);
        this.ecs.registerSystem(this.physicsSystem);
        this.ecs.registerSystem(this.renderSystem);
        
        // Jugador se creará después de cargar la dimensión
        this.playerId = null;
    }
    
    async loadDemo() {
        // ... código existente para cargar dimensión ...
        
        // Crear jugador después de cargar dimensión
        if (!this.playerId) {
            this.playerId = PlayerFactory.createPlayer({
                ecs: this.ecs,
                scene: this.scene.scene,
                x: 80,
                y: 80,
                z: 1,
                cellSize: demoDimension.tamano_celda
            });
        }
        
        // ... resto del código ...
    }
    
    // Modificar animate para actualizar ECS
    animate() {
        requestAnimationFrame(() => this.animate());
        
        // Calcular deltaTime
        const currentTime = performance.now();
        const deltaTime = (currentTime - (this.lastTime || currentTime)) / 1000;
        this.lastTime = currentTime;
        
        // Limpiar frame de InputManager
        this.inputManager.clearFrame();
        
        // Actualizar sistemas ECS
        this.ecs.update(deltaTime);
        
        // Actualizar controles y renderizar
        this.scene.controls.update();
        this.scene.renderer.render(this.scene.scene, this.scene.camera.camera);
    }
}
```

**Notas:**
- El ECS debe inicializarse en el constructor
- Los sistemas deben registrarse antes de crear entidades
- El jugador debe crearse después de cargar la dimensión (para tener cellSize)
- El loop de animación debe actualizar el ECS con deltaTime
- InputManager.clearFrame() debe llamarse al inicio de cada frame

---

### Paso 7: Implementar Movimiento Básico del Jugador

**Descripción:**
Implementar el movimiento básico del jugador basado en input. El jugador debe moverse en la dirección indicada por las teclas WASD.

**Archivos a modificar:**
- `frontend/src/ecs/systems/input-system.js` - Mejorar procesamiento de input
- `frontend/src/ecs/systems/physics-system.js` - Aplicar movimiento basado en input

**Detalles de implementación:**
```javascript
// frontend/src/ecs/systems/input-system.js
update(deltaTime) {
    const entities = this.getEntities();
    
    for (const entityId of entities) {
        const input = this.ecs.getComponent(entityId, 'Input');
        const physics = this.ecs.getComponent(entityId, 'Physics');
        
        if (!input || !physics) continue;
        
        // Calcular dirección de movimiento
        input.moveDirection.x = 0;
        input.moveDirection.z = 0;
        
        if (input.isKeyPressed('KeyW') || input.isKeyPressed('ArrowUp')) {
            input.moveDirection.z -= 1; // Adelante
        }
        if (input.isKeyPressed('KeyS') || input.isKeyPressed('ArrowDown')) {
            input.moveDirection.z += 1; // Atrás
        }
        if (input.isKeyPressed('KeyA') || input.isKeyPressed('ArrowLeft')) {
            input.moveDirection.x -= 1; // Izquierda
        }
        if (input.isKeyPressed('KeyD') || input.isKeyPressed('ArrowRight')) {
            input.moveDirection.x += 1; // Derecha
        }
        
        // Normalizar dirección
        const length = Math.sqrt(input.moveDirection.x ** 2 + input.moveDirection.z ** 2);
        if (length > 0) {
            input.moveDirection.x /= length;
            input.moveDirection.z /= length;
        }
        
        // Aplicar movimiento a física
        const speed = input.isRunning ? 3 : 1.5; // celdas por segundo
        physics.acceleration.x = input.moveDirection.x * speed;
        physics.acceleration.z = input.moveDirection.z * speed;
    }
}

// frontend/src/ecs/systems/physics-system.js
// Ya implementado en Paso 4, pero asegurar que aplica aceleración correctamente
```

**Notas:**
- El movimiento debe ser en el plano XZ (horizontal)
- La velocidad debe ser en celdas por segundo
- Correr debe ser más rápido que caminar (2x velocidad)
- El movimiento debe aplicarse como aceleración en PhysicsSystem

---

### Paso 8: Implementar Sistema de Colisiones

**Descripción:**
Crear un sistema de detección de colisiones que verifica si hay partículas sólidas en las posiciones adyacentes al jugador.

**Archivos a crear:**
- `frontend/src/systems/collision-detector.js` - Detector de colisiones
- `frontend/src/ecs/systems/collision-system.js` - Sistema de colisiones ECS

**Detalles de implementación:**
```javascript
// frontend/src/systems/collision-detector.js
export class CollisionDetector {
    constructor(particlesApi, cellSize) {
        this.particlesApi = particlesApi;
        this.cellSize = cellSize;
        this.collisionCache = new Map();
    }
    
    async checkCollision(position, radius = 2, dimensionId) {
        // Calcular área de colisión
        const xMin = Math.floor(position.x - radius);
        const xMax = Math.floor(position.x + radius);
        const yMin = Math.floor(position.y - radius);
        const yMax = Math.floor(position.y + radius);
        const zMin = Math.floor(position.z - radius);
        const zMax = Math.floor(position.z + radius);
        
        // Verificar cache
        const cacheKey = `${dimensionId}-${xMin}-${xMax}-${yMin}-${yMax}-${zMin}-${zMax}`;
        if (this.collisionCache.has(cacheKey)) {
            return this.collisionCache.get(cacheKey);
        }
        
        // Consultar partículas en área pequeña
        const particles = await this.particlesApi.getParticles(
            dimensionId,
            { x_min: xMin, x_max: xMax, y_min: yMin, y_max: yMax, z_min: zMin, z_max: zMax }
        );
        
        // Filtrar solo partículas sólidas
        const solidParticles = particles.particles.filter(p => p.estado_nombre === 'solido');
        
        // Crear mapa de posiciones ocupadas
        const occupiedCells = new Set();
        for (const particle of solidParticles) {
            const key = `${particle.celda_x},${particle.celda_y},${particle.celda_z}`;
            occupiedCells.add(key);
        }
        
        // Cachear resultado
        this.collisionCache.set(cacheKey, occupiedCells);
        
        return occupiedCells;
    }
    
    isCellOccupied(occupiedCells, x, y, z) {
        const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
        return occupiedCells.has(key);
    }
}

// frontend/src/ecs/systems/collision-system.js
import { System } from '../system.js';

export class CollisionSystem extends System {
    constructor(collisionDetector, dimensionId) {
        super();
        this.requiredComponents = ['Position', 'Physics'];
        this.collisionDetector = collisionDetector;
        this.dimensionId = dimensionId;
    }
    
    async update(deltaTime) {
        const entities = this.getEntities();
        
        for (const entityId of entities) {
            const position = this.ecs.getComponent(entityId, 'Position');
            const physics = this.ecs.getComponent(entityId, 'Physics');
            
            if (!position || !physics) continue;
            
            // Obtener partículas sólidas cercanas
            const occupiedCells = await this.collisionDetector.checkCollision(
                position, 2, this.dimensionId
            );
            
            // Verificar colisión en dirección de movimiento
            const nextX = position.x + physics.velocity.x * deltaTime;
            const nextY = position.y + physics.velocity.y * deltaTime;
            const nextZ = position.z + physics.velocity.z * deltaTime;
            
            // Verificar colisión lateral
            if (this.collisionDetector.isCellOccupied(occupiedCells, nextX, position.y, position.z)) {
                physics.velocity.x = 0;
            }
            if (this.collisionDetector.isCellOccupied(occupiedCells, position.x, position.y, nextZ)) {
                physics.velocity.z = 0;
            }
            
            // Verificar suelo (debajo)
            const groundY = position.y - 1;
            if (this.collisionDetector.isCellOccupied(occupiedCells, position.x, groundY, position.z)) {
                physics.isGrounded = true;
                if (physics.velocity.y < 0) {
                    physics.velocity.y = 0;
                    position.y = Math.floor(position.y) + 1; // Ajustar a superficie
                }
            } else {
                physics.isGrounded = false;
            }
        }
    }
}
```

**Notas:**
- El CollisionDetector debe consultar solo partículas en área pequeña (radio de 2-3 celdas)
- Implementar cache para evitar consultas repetidas
- El CollisionSystem debe verificar colisiones laterales y suelo
- Las colisiones deben ajustar velocidad y posición

---

### Paso 9: Implementar Sistema de Saltos

**Descripción:**
Implementar el sistema de saltos que permite al jugador saltar cuando presiona Espacio y está en el suelo.

**Archivos a modificar:**
- `frontend/src/ecs/systems/input-system.js` - Detectar input de salto
- `frontend/src/ecs/systems/physics-system.js` - Aplicar fuerza de salto

**Detalles de implementación:**
```javascript
// frontend/src/ecs/systems/input-system.js
update(deltaTime) {
    // ... código existente ...
    
    // Saltar
    if (input.isKeyDown('Space') && physics.isGrounded) {
        input.wantsToJump = true;
    }
}

// frontend/src/ecs/systems/physics-system.js
updatePhysics(timestep) {
    const entities = this.getEntities();
    
    for (const entityId of entities) {
        const physics = this.ecs.getComponent(entityId, 'Physics');
        const position = this.ecs.getComponent(entityId, 'Position');
        const input = this.ecs.getComponent(entityId, 'Input');
        
        if (!physics || !position) continue;
        
        // Aplicar salto
        if (input && input.wantsToJump && physics.isGrounded) {
            physics.velocity.y = 5; // Velocidad de salto en celdas/segundo
            physics.isGrounded = false;
            input.wantsToJump = false; // Resetear
        }
        
        // ... resto del código de física ...
    }
}
```

**Notas:**
- El salto solo debe funcionar si el jugador está en el suelo
- La velocidad de salto debe ser suficiente para saltar sobre obstáculos
- El salto debe resetear wantsToJump después de aplicarse

---

### Paso 10: Implementar Acciones Avanzadas (Correr, Agacharse, Golpear, Agarrar)

**Descripción:**
Implementar las acciones avanzadas: correr (Shift), agacharse (Ctrl/C), golpear (click izquierdo), y agarrar (click derecho/E).

**Archivos a modificar:**
- `frontend/src/ecs/systems/input-system.js` - Detectar todas las acciones
- `frontend/src/ecs/components/render.js` - Agregar estado de agachado
- `frontend/src/ecs/systems/render-system.js` - Aplicar agacharse visualmente

**Detalles de implementación:**
```javascript
// frontend/src/ecs/systems/input-system.js
update(deltaTime) {
    // ... código existente ...
    
    // Correr
    input.isRunning = input.isKeyPressed('ShiftLeft') || input.isKeyPressed('ShiftRight');
    
    // Agacharse
    input.wantsToCrouch = input.isKeyPressed('ControlLeft') || 
                         input.isKeyPressed('ControlRight') ||
                         input.isKeyPressed('KeyC');
    
    // Golpear
    if (this.inputManager.isMouseButtonDown(0)) { // Click izquierdo
        input.wantsToAttack = true;
    }
    
    // Agarrar
    if (this.inputManager.isMouseButtonDown(2) || input.isKeyDown('KeyE')) { // Click derecho o E
        input.wantsToGrab = true;
    }
}

// frontend/src/ecs/components/render.js
// Agregar propiedad isCrouching
constructor(options = {}) {
    // ... código existente ...
    this.isCrouching = false;
    this.normalScale = { x: 1, y: 1, z: 1 };
    this.crouchScale = { x: 1, y: 0.6, z: 1 }; // Reducir altura al 60%
}

// frontend/src/ecs/systems/render-system.js
update(deltaTime) {
    const entities = this.getEntities();
    
    for (const entityId of entities) {
        const render = this.ecs.getComponent(entityId, 'Render');
        const position = this.ecs.getComponent(entityId, 'Position');
        const input = this.ecs.getComponent(entityId, 'Input');
        
        if (!render || !position || !render.mesh) continue;
        
        // Actualizar posición
        render.mesh.position.set(
            position.x * this.cellSize,
            position.z * this.cellSize,
            position.y * this.cellSize
        );
        
        // Aplicar agacharse
        if (input && input.wantsToCrouch) {
            render.isCrouching = true;
            render.mesh.scale.set(
                render.crouchScale.x,
                render.crouchScale.y,
                render.crouchScale.z
            );
        } else {
            render.isCrouching = false;
            render.mesh.scale.set(
                render.normalScale.x,
                render.normalScale.y,
                render.normalScale.z
            );
        }
        
        // Orientación según dirección de movimiento
        if (input && (input.moveDirection.x !== 0 || input.moveDirection.z !== 0)) {
            const angle = Math.atan2(input.moveDirection.x, input.moveDirection.z);
            render.mesh.rotation.y = angle;
        }
    }
}
```

**Notas:**
- Correr debe aumentar la velocidad de movimiento (ya implementado en Paso 7)
- Agacharse debe reducir la altura del mesh visualmente
- Golpear y agarrar deben detectarse pero la funcionalidad completa se implementará después
- La orientación del personaje debe seguir la dirección de movimiento

---

### Paso 11: Implementar Sistema de Cámara que Sigue al Jugador

**Descripción:**
Crear un sistema de cámara que sigue al jugador en modo tercera persona, deshabilitando OrbitControls cuando el jugador está activo.

**Archivos a crear:**
- `frontend/src/systems/camera-controller.js` - Controlador de cámara
- `frontend/src/ecs/systems/camera-system.js` - Sistema de cámara ECS

**Archivos a modificar:**
- `frontend/src/core/controls.js` - Agregar método para habilitar/deshabilitar
- `frontend/src/app.js` - Integrar camera controller

**Detalles de implementación:**
```javascript
// frontend/src/systems/camera-controller.js
export class CameraController {
    constructor(camera, scene) {
        this.camera = camera;
        this.scene = scene;
        this.mode = 'third-person'; // 'first-person' | 'third-person'
        this.targetEntityId = null;
        this.offset = { x: 0, y: 5, z: 5 }; // Offset para tercera persona
        this.smoothing = 0.1; // Suavizado de movimiento
    }
    
    setTarget(entityId) {
        this.targetEntityId = entityId;
    }
    
    setMode(mode) {
        this.mode = mode;
    }
    
    update(ecs) {
        if (!this.targetEntityId) return;
        
        const position = ecs.getComponent(this.targetEntityId, 'Position');
        if (!position) return;
        
        const targetX = position.x * 0.25; // Convertir a metros
        const targetY = position.z * 0.25;
        const targetZ = position.y * 0.25;
        
        if (this.mode === 'third-person') {
            // Cámara detrás y arriba del jugador
            const cameraX = targetX + this.offset.x;
            const cameraY = targetY + this.offset.y;
            const cameraZ = targetZ + this.offset.z;
            
            // Suavizado
            this.camera.camera.position.lerp(
                new THREE.Vector3(cameraX, cameraY, cameraZ),
                this.smoothing
            );
            
            // Mirar al jugador
            this.camera.camera.lookAt(targetX, targetY, targetZ);
        }
    }
}

// frontend/src/core/controls.js
// Agregar método para habilitar/deshabilitar
setEnabled(enabled) {
    this.controls.enabled = enabled;
}

// frontend/src/app.js
// En constructor
this.cameraController = new CameraController(this.scene.camera, this.scene);

// En loadDemo, después de crear jugador
this.cameraController.setTarget(this.playerId);
this.scene.controls.setEnabled(false); // Deshabilitar OrbitControls

// En animate
this.cameraController.update(this.ecs);
```

**Notas:**
- La cámara debe seguir al jugador suavemente
- OrbitControls debe deshabilitarse cuando el jugador está activo
- El modo tercera persona debe posicionar la cámara detrás y arriba del jugador
- Implementar suavizado para movimiento fluido de cámara

---

### Paso 12: Implementar Animaciones Básicas

**Descripción:**
Implementar animaciones básicas del personaje según su estado (idle, caminar, correr, saltar, agacharse). Inicialmente usar animaciones simples (escalado, rotación).

**Archivos a crear:**
- `frontend/src/ecs/components/animation.js` - Componente de animación
- `frontend/src/ecs/systems/animation-system.js` - Sistema de animaciones

**Archivos a modificar:**
- `frontend/src/ecs/systems/render-system.js` - Integrar animaciones

**Detalles de implementación:**
```javascript
// frontend/src/ecs/components/animation.js
export class AnimationComponent {
    constructor() {
        this.currentState = 'idle'; // 'idle', 'walk', 'run', 'jump', 'crouch'
        this.animationSpeed = 1.0;
    }
}

// frontend/src/ecs/systems/animation-system.js
import { System } from '../system.js';

export class AnimationSystem extends System {
    constructor() {
        super();
        this.requiredComponents = ['Animation', 'Input', 'Physics'];
    }
    
    update(deltaTime) {
        const entities = this.getEntities();
        
        for (const entityId of entities) {
            const animation = this.ecs.getComponent(entityId, 'Animation');
            const input = this.ecs.getComponent(entityId, 'Input');
            const physics = this.ecs.getComponent(entityId, 'Physics');
            
            if (!animation || !input || !physics) continue;
            
            // Determinar estado de animación
            if (physics.velocity.y > 0.1) {
                animation.currentState = 'jump';
            } else if (input.wantsToCrouch) {
                animation.currentState = 'crouch';
            } else if (input.isRunning && (input.moveDirection.x !== 0 || input.moveDirection.z !== 0)) {
                animation.currentState = 'run';
            } else if (input.moveDirection.x !== 0 || input.moveDirection.z !== 0) {
                animation.currentState = 'walk';
            } else {
                animation.currentState = 'idle';
            }
        }
    }
}

// frontend/src/ecs/systems/render-system.js
// Agregar animaciones visuales simples
update(deltaTime) {
    // ... código existente ...
    
    // Animación simple: balanceo al caminar/correr
    if (animation) {
        if (animation.currentState === 'walk' || animation.currentState === 'run') {
            const speed = animation.currentState === 'run' ? 10 : 5;
            render.mesh.rotation.z = Math.sin(Date.now() * 0.001 * speed) * 0.1;
        } else {
            render.mesh.rotation.z = 0;
        }
    }
}
```

**Notas:**
- Las animaciones iniciales pueden ser simples (rotación, escalado)
- El estado de animación debe determinarse según input y física
- Futuras mejoras pueden usar Three.js AnimationMixer con modelos 3D

---

### Paso 13: Optimización y Refinamiento

**Descripción:**
Optimizar el sistema de colisiones, ajustar parámetros de física, y agregar límites del terreno para prevenir caída infinita.

**Archivos a modificar:**
- `frontend/src/systems/collision-detector.js` - Optimizar cache y consultas
- `frontend/src/ecs/systems/physics-system.js` - Ajustar parámetros
- `frontend/src/ecs/systems/collision-system.js` - Agregar límites del terreno

**Detalles de implementación:**
```javascript
// frontend/src/ecs/systems/collision-system.js
// Agregar límites del terreno
update(deltaTime) {
    // ... código existente ...
    
    // Límites del terreno (prevenir caída infinita)
    const dimension = this.dimension; // Obtener de algún lugar
    if (dimension) {
        const maxX = dimension.ancho_metros / dimension.tamano_celda;
        const maxY = dimension.alto_metros / dimension.tamano_celda;
        const minZ = dimension.profundidad_maxima || -10;
        const maxZ = dimension.altura_maxima || 40;
        
        // Limitar posición
        position.x = Math.max(0, Math.min(maxX - 1, position.x));
        position.y = Math.max(0, Math.min(maxY - 1, position.y));
        position.z = Math.max(minZ, Math.min(maxZ, position.z));
        
        // Si cae fuera del terreno, teleportar a superficie
        if (position.z < minZ) {
            position.z = 1;
            position.x = 80;
            position.y = 80;
            physics.velocity = { x: 0, y: 0, z: 0 };
        }
    }
}

// Optimizar cache de colisiones
// Limitar tamaño del cache
if (this.collisionCache.size > 100) {
    const firstKey = this.collisionCache.keys().next().value;
    this.collisionCache.delete(firstKey);
}
```

**Notas:**
- El cache de colisiones debe tener un límite de tamaño
- Los límites del terreno deben prevenir caída infinita
- Si el jugador cae fuera, debe teleportarse a una posición segura
- Ajustar velocidades, gravedad, y fricción según pruebas

---

### Paso 14: Actualizar Documentación

**Descripción:**
Actualizar todos los READMEs relevantes para documentar el nuevo sistema ECS y el personaje jugable.

**Archivos a modificar/crear:**
- `frontend/src/ecs/README.md` - Documentación completa del ECS (ya creado en Paso 1)
- `frontend/src/systems/README.md` - Documentar InputManager y CollisionDetector
- `frontend/src/README.md` - Actualizar con información del sistema ECS

**Notas:**
- **⚠️ READMEs:** Asegurar que todos los módulos nuevos tengan documentación
- Documentar cómo usar el sistema ECS
- Documentar cómo crear nuevas entidades y sistemas
- Incluir ejemplos de uso

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-010_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance

- **Colisiones:** Solo verificar partículas en área pequeña (radio de 2-3 celdas) alrededor del personaje
- **Cache:** Cachear resultados de consultas de partículas para colisiones (límite de 100 entradas)
- **Física:** Usar timestep fijo (1/60) para física estable independiente del FPS
- **Queries ECS:** Cachear queries para evitar recalcular entidades con componentes específicos
- **Renderizado:** El personaje debe renderizarse eficientemente (primitivos simples inicialmente)

### Seguridad

- **Input:** Validar y sanitizar eventos de teclado y mouse
- **Colisiones:** Validar que las posiciones estén dentro de los límites de la dimensión
- **Física:** Limitar velocidades máximas para prevenir bugs

### Casos Edge

- **Personaje fuera del terreno:** Teleportar a posición segura si cae fuera
- **Colisiones múltiples:** Resolver colisiones en orden correcto (suelo primero, luego laterales)
- **Input simultáneo:** Manejar múltiples teclas presionadas correctamente
- **Cámara:** Prevenir que la cámara atraviese objetos
- **Viewport dinámico:** Actualizar viewport cuando el personaje se mueve (futuro)

### Compatibilidad

- **OrbitControls:** Deshabilitar cuando el jugador está activo, pero mantener disponible para modo editor
- **Sistemas existentes:** El ECS no debe interferir con el renderizado de partículas existente
- **API:** Preparar para futuros endpoints de backend (guardar posición, etc.)

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Clases ES6 para organización
  - Sistema ECS para entidades
  - Event listeners para input
  - Timestep fijo para física
  - Cache para optimización

- **Sistema ECS**:
  - Componentes: Solo datos (sin lógica)
  - Sistemas: Solo lógica (operan sobre componentes)
  - Queries: Para obtener entidades con componentes específicos
  - Factory Pattern: Para crear entidades

## Dependencias

### Nuevas Dependencias (si aplica)
No se requieren nuevas dependencias. Todo se implementa con Three.js y JavaScript nativo.

### Variables de Entorno (si aplica)
No se requieren nuevas variables de entorno.

## Archivos Principales Involucrados

1. `frontend/src/ecs/manager.js` - ECSManager (núcleo del sistema ECS)
2. `frontend/src/ecs/system.js` - Clase base System
3. `frontend/src/ecs/components/` - Componentes (Position, Physics, Render, Input, Animation)
4. `frontend/src/ecs/systems/` - Sistemas (InputSystem, PhysicsSystem, RenderSystem, CollisionSystem, AnimationSystem, CameraSystem)
5. `frontend/src/ecs/factories/player-factory.js` - Factory para crear jugador
6. `frontend/src/systems/input-manager.js` - Gestor de input
7. `frontend/src/systems/collision-detector.js` - Detector de colisiones
8. `frontend/src/systems/camera-controller.js` - Controlador de cámara
9. `frontend/src/app.js` - Integración del ECS en la aplicación

## Testing

### Tests a Crear/Modificar
- Unit tests: `tests/frontend/test-ecs-manager.js` (futuro)
- Unit tests: `tests/frontend/test-input-manager.js` (futuro)
- Integration tests: `tests/frontend/test-player-movement.js` (futuro)

### Escenarios de Prueba

1. **Movimiento básico:**
   - Presionar W: personaje se mueve hacia adelante
   - Presionar S: personaje se mueve hacia atrás
   - Presionar A: personaje se mueve hacia la izquierda
   - Presionar D: personaje se mueve hacia la derecha
   - Presionar Shift + W: personaje corre hacia adelante (más rápido)

2. **Física y colisiones:**
   - Personaje cae si no hay suelo debajo
   - Personaje no atraviesa partículas sólidas (tierra, piedra)
   - Personaje puede caminar sobre partículas sólidas
   - Personaje no puede caminar a través de partículas sólidas

3. **Saltos:**
   - Presionar Espacio en el suelo: personaje salta
   - Presionar Espacio en el aire: no salta (solo una vez)
   - Personaje cae después del salto

4. **Agacharse:**
   - Presionar Ctrl/C: personaje se agacha (altura reducida)
   - Soltar Ctrl/C: personaje vuelve a altura normal
   - Personaje puede moverse mientras está agachado

5. **Acciones:**
   - Click izquierdo: personaje ejecuta acción de golpear
   - Click derecho/E: personaje ejecuta acción de agarrar
   - Acciones funcionan en dirección que mira el personaje

6. **Cámara:**
   - Cámara sigue al personaje cuando se mueve
   - Cámara rota con el personaje o independientemente
   - Cámara no atraviesa objetos

7. **Orientación:**
   - Personaje se orienta hacia la dirección de movimiento
   - Personaje mantiene orientación al detenerse

8. **Animaciones:**
   - Animación idle cuando está quieto
   - Animación caminar cuando se mueve
   - Animación correr cuando corre
   - Animación saltar cuando salta
   - Animación agacharse cuando está agachado

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos (no requiere rebuild de Docker)
2. Verificar en ambiente local con Docker Compose
3. Verificar que el jugador se crea y funciona correctamente

### Verificación Post-Deployment
- [ ] Verificar que el jugador se renderiza en la escena
- [ ] Verificar que el jugador responde a input (WASD)
- [ ] Verificar que el jugador tiene física (gravedad, colisiones)
- [ ] Verificar que el jugador puede saltar
- [ ] Verificar que el jugador puede agacharse
- [ ] Verificar que la cámara sigue al jugador
- [ ] Verificar que no hay errores en consola
- [ ] Verificar que el FPS se mantiene estable (60 FPS)

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

