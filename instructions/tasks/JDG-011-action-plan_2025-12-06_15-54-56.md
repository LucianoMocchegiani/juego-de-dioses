# JDG-011 - Sistema de Personajes desde Base de Datos usando Templates/Builders/Creators

## Descripción de la Tarea

Implementar sistema de personajes (bípedos) que se definan y creen desde la base de datos usando el sistema de templates/builders/creators, similar a como se crean los árboles. Esto permitirá definir diferentes tipos de personajes/razas desde la BD, usar el sistema de geometría de agrupaciones para definir formas complejas, y centralizar la definición de personajes en el backend.

**Comportamiento actual:**
- El personaje se crea en `frontend/src/ecs/factories/player-factory.js` usando primitivos Three.js hardcodeados (cilindro + esfera)
- No hay integración con el sistema de templates/builders/creators del backend
- No se usa la tabla `agrupaciones` ni `geometria_agrupacion` para definir la forma del personaje
- El personaje no existe como partículas en la base de datos

**Comportamiento esperado:**
- Sistema de templates para bípedos en `backend/src/database/templates/bipedos/`
- Builder para bípedos que convierte templates en partículas
- Endpoints de API para obtener información de personajes desde la BD
- `PlayerFactory` carga la forma del personaje desde la API
- El personaje se crea como agrupación en la BD con `geometria_agrupacion` definiendo sus partes
- El frontend renderiza el personaje usando la geometría definida en la BD

## Criterios de Aceptación

1. ❌ Existe sistema de templates para bípedos en `backend/src/database/templates/bipedos/`
2. ❌ Existe `BipedTemplate` como clase base que extiende `BaseTemplate`
3. ❌ Existe template `HumanoTemplate` con estructura básica (cabeza, torso, brazos, piernas)
4. ❌ Existe `BipedBuilder` que convierte templates en partículas para la BD
5. ❌ `EntityCreator` puede crear bípedos usando `create_entity()` con template de bípedo
6. ❌ Los bípedos se crean como agrupaciones en la BD con `geometria_agrupacion` definida
7. ❌ Existe endpoint de API `/api/dimensions/{dimension_id}/characters/{character_id}` para obtener información de personaje
8. ❌ El frontend puede cargar la forma del personaje desde la API
9. ❌ `PlayerFactory` crea el mesh del personaje basándose en `geometria_agrupacion` de la BD
10. ❌ El personaje renderizado coincide con la definición en la BD
11. ❌ El sistema ECS funciona correctamente con personajes creados desde BD
12. ❌ Se puede crear un personaje usando `EntityCreator` desde un script de seed

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Frontend: HTML5, JavaScript ES6+, Three.js
- Base de datos: PostgreSQL 16
- Sistema ECS (frontend)
- Sistema de Templates/Builders/Creators (backend)

## Pasos de Implementación

### Fase 1: Crear Infraestructura de Templates y Builders

#### Paso 1.1: Crear estructura base de templates de bípedos

**Descripción:**
Crear la carpeta y archivos base para el sistema de templates de bípedos, siguiendo el mismo patrón que los árboles.

**Archivos a crear:**
- `backend/src/database/templates/bipedos/__init__.py`
- `backend/src/database/templates/bipedos/base.py`
- `backend/src/database/templates/bipedos/README.md`

**Detalles de implementación:**
```python
# bipedos/base.py
from typing import List, Tuple, Dict, Any
from src.database.templates.base import BaseTemplate

class BipedTemplate(BaseTemplate):
    """Clase base para templates de bípedos (personajes)"""
    
    def __init__(
        self,
        nombre: str,
        altura_cabeza: int,
        altura_torso: int,
        altura_piernas: int,
        ancho_hombros: int,
        ancho_cadera: int
    ):
        super().__init__(nombre, 'biped')
        self.altura_cabeza = altura_cabeza
        self.altura_torso = altura_torso
        self.altura_piernas = altura_piernas
        self.ancho_hombros = ancho_hombros
        self.ancho_cadera = ancho_cadera
    
    def get_posiciones(self, x_centro: int, y_centro: int, z_base: int) -> List[Tuple[int, int, int]]:
        """Obtener todas las posiciones que forman el bípedo"""
        # Implementar lógica para cabeza, torso, brazos, piernas
        pass
    
    def get_propiedades_particula(self, parte: str) -> Dict[str, Any]:
        """Obtener propiedades de partícula por parte del cuerpo"""
        return {'parte_entidad': parte}
```

**Notas:**
- Seguir el mismo patrón que `TreeTemplate`
- Los métodos abstractos deben ser implementados por templates específicos
- **⚠️ READMEs:** Crear `README.md` en `bipedos/` explicando la estructura y cómo agregar nuevos templates

---

#### Paso 1.2: Crear template de humano

**Descripción:**
Crear el template específico para humanos con estructura básica (cabeza, torso, 2 brazos, 2 piernas).

**Archivos a crear:**
- `backend/src/database/templates/bipedos/humano.py`

**Detalles de implementación:**
```python
# bipedos/humano.py
from src.database.templates.bipedos.base import BipedTemplate

class HumanoTemplate(BipedTemplate):
    """Template para humano"""
    
    def __init__(self):
        super().__init__(
            nombre='Humano',
            altura_cabeza=1,      # 1 nivel de altura para cabeza
            altura_torso=4,       # 4 niveles de altura para torso
            altura_piernas=4,     # 4 niveles de altura para piernas
            ancho_hombros=2,      # 2 celdas de ancho en hombros
            ancho_cadera=2        # 2 celdas de ancho en cadera
        )
    
    def get_posiciones(self, x_centro: int, y_centro: int, z_base: int) -> List[Tuple[int, int, int]]:
        """Obtener posiciones del humano"""
        posiciones = []
        
        # Cabeza (esfera en z_base + altura_torso + altura_piernas)
        z_cabeza = z_base + self.altura_torso + self.altura_piernas
        posiciones.append((x_centro, y_centro, z_cabeza))
        
        # Torso (cilindro desde z_base + altura_piernas hasta z_base + altura_piernas + altura_torso)
        for z in range(z_base + self.altura_piernas, z_base + self.altura_piernas + self.altura_torso):
            posiciones.append((x_centro, y_centro, z))
        
        # Brazos (izquierdo y derecho)
        # Brazo izquierdo
        for z in range(z_base + self.altura_piernas + 1, z_base + self.altura_piernas + self.altura_torso):
            posiciones.append((x_centro - 1, y_centro, z))
        
        # Brazo derecho
        for z in range(z_base + self.altura_piernas + 1, z_base + self.altura_piernas + self.altura_torso):
            posiciones.append((x_centro + 1, y_centro, z))
        
        # Piernas (izquierda y derecha)
        # Pierna izquierda
        for z in range(z_base, z_base + self.altura_piernas):
            posiciones.append((x_centro - 1, y_centro, z))
        
        # Pierna derecha
        for z in range(z_base, z_base + self.altura_piernas):
            posiciones.append((x_centro + 1, y_centro, z))
        
        return posiciones
    
    def get_propiedades_particula(self, parte: str) -> Dict[str, Any]:
        """Obtener propiedades por parte del cuerpo"""
        return {
            'parte_entidad': parte,
            'raza': 'humano'
        }
```

**Notas:**
- La estructura debe ser simple pero funcional
- Cada parte debe tener su identificador único ('cabeza', 'torso', 'brazo_izquierdo', etc.)

---

#### Paso 1.3: Crear registry de bípedos

**Descripción:**
Crear el registry pattern para descubrir y usar templates de bípedos dinámicamente.

**Archivos a crear:**
- `backend/src/database/templates/bipedos/registry.py`

**Detalles de implementación:**
```python
# bipedos/registry.py
from typing import Dict, Optional, List
from src.database.templates.bipedos.base import BipedTemplate
from src.database.templates.bipedos.humano import HumanoTemplate

# Registry de todos los templates de bípedos
BIPED_TEMPLATES: Dict[str, BipedTemplate] = {
    'humano': HumanoTemplate(),
}

def get_biped_template(template_id: str) -> Optional[BipedTemplate]:
    """Obtener un template de bípedo por ID"""
    return BIPED_TEMPLATES.get(template_id)

def get_all_biped_templates() -> Dict[str, BipedTemplate]:
    """Obtener todos los templates de bípedos"""
    return BIPED_TEMPLATES.copy()

def list_biped_template_ids() -> List[str]:
    """Listar todos los IDs de templates de bípedos disponibles"""
    return list(BIPED_TEMPLATES.keys())
```

**Notas:**
- Seguir el mismo patrón que `trees/registry.py`
- Fácil agregar nuevos templates en el futuro

---

#### Paso 1.4: Crear BipedBuilder

**Descripción:**
Crear el builder que convierte templates de bípedos en partículas para la base de datos, incluyendo la creación de agrupaciones con `geometria_agrupacion`.

**Archivos a crear:**
- `backend/src/database/builders/biped_builder.py`

**Detalles de implementación:**
```python
# builders/biped_builder.py
from typing import List, Tuple, Dict, Optional, Any
from uuid import UUID
import asyncpg
import json
from src.database.builders.base import BaseBuilder
from src.database.templates.bipedos.base import BipedTemplate

class BipedBuilder(BaseBuilder):
    """Builder para crear bípedos usando BipedTemplate"""
    
    def __init__(self, template: BipedTemplate):
        if not isinstance(template, BipedTemplate):
            raise ValueError(f"BipedBuilder requiere BipedTemplate, recibió {type(template)}")
        super().__init__(template)
        self.template: BipedTemplate = template
    
    async def create_at_position(
        self,
        conn: asyncpg.Connection,
        dimension_id: UUID,
        x: int,
        y: int,
        z: int,
        cuerpo_id: str = None,
        solido_id: str = None,
        agrupacion_id: Optional[UUID] = None,
        **kwargs
    ) -> List[Tuple]:
        """Crear bípedo en posición específica"""
        if not all([cuerpo_id, solido_id]):
            raise ValueError("Faltan IDs de tipos de partículas o estados de materia")
        
        particles = []
        posiciones = self.template.get_posiciones(x, y, z)
        
        # Crear partículas para cada posición
        for px, py, pz in posiciones:
            # Determinar parte del cuerpo según posición
            parte = self._determinar_parte(px, py, pz, x, y, z)
            
            particles.append((
                dimension_id, px, py, pz,
                cuerpo_id, solido_id, 1.0, 37.0, 0.0, False,
                agrupacion_id, False, json.dumps(self.template.get_propiedades_particula(parte))
            ))
        
        return particles
    
    def _determinar_parte(self, px: int, py: int, pz: int, x_centro: int, y_centro: int, z_base: int) -> str:
        """Determinar qué parte del cuerpo es según posición"""
        z_relativo = pz - z_base
        
        # Cabeza (más arriba)
        if z_relativo >= self.template.altura_torso + self.template.altura_piernas:
            return 'cabeza'
        
        # Torso
        elif z_relativo >= self.template.altura_piernas:
            if px == x_centro and py == y_centro:
                return 'torso'
            elif px < x_centro:
                return 'brazo_izquierdo'
            elif px > x_centro:
                return 'brazo_derecho'
        
        # Piernas
        else:
            if px < x_centro:
                return 'pierna_izquierda'
            elif px > x_centro:
                return 'pierna_derecha'
        
        return 'torso'  # Default
    
    def get_particle_type_ids(self) -> Dict[str, str]:
        """Obtener nombres de tipos de partículas necesarios"""
        return {
            'cuerpo': 'carne'  # O usar tipo genérico existente
        }
    
    async def create_agrupacion(
        self,
        conn: asyncpg.Connection,
        dimension_id: UUID,
        x: int,
        y: int,
        z: int
    ) -> Optional[UUID]:
        """Crear agrupación con geometria_agrupacion"""
        metadata = self.get_agrupacion_metadata()
        
        # Construir geometria_agrupacion
        geometria = self._build_geometria_agrupacion()
        
        agrupacion_id = await conn.fetchval("""
            INSERT INTO juego_dioses.agrupaciones
            (dimension_id, nombre, tipo, especie, geometria_agrupacion)
            VALUES ($1, $2, $3, $4, $5::jsonb)
            RETURNING id
        """, dimension_id, metadata['nombre'], metadata['tipo'], metadata['especie'], json.dumps(geometria))
        
        return agrupacion_id
    
    def _build_geometria_agrupacion(self) -> Dict[str, Any]:
        """Construir estructura de geometria_agrupacion"""
        cell_size = 0.25  # Tamaño de celda en metros (ajustar según dimensión)
        
        return {
            "tipo": "biped",
            "partes": {
                "cabeza": {
                    "geometria": {
                        "tipo": "sphere",
                        "parametros": {"radius": 0.25, "segments": 8}
                    },
                    "offset": {"x": 0, "y": 0, "z": (self.template.altura_torso + self.template.altura_piernas) * cell_size}
                },
                "torso": {
                    "geometria": {
                        "tipo": "cylinder",
                        "parametros": {"radiusTop": 0.3, "radiusBottom": 0.3, "height": self.template.altura_torso * cell_size}
                    },
                    "offset": {"x": 0, "y": 0, "z": (self.template.altura_piernas + self.template.altura_torso / 2) * cell_size}
                },
                "brazo_izquierdo": {
                    "geometria": {
                        "tipo": "cylinder",
                        "parametros": {"radiusTop": 0.1, "radiusBottom": 0.1, "height": (self.template.altura_torso - 1) * cell_size}
                    },
                    "offset": {"x": -0.4, "y": 0, "z": (self.template.altura_piernas + self.template.altura_torso / 2) * cell_size},
                    "rotacion": {"x": 0, "y": 0, "z": 90}
                },
                "brazo_derecho": {
                    "geometria": {
                        "tipo": "cylinder",
                        "parametros": {"radiusTop": 0.1, "radiusBottom": 0.1, "height": (self.template.altura_torso - 1) * cell_size}
                    },
                    "offset": {"x": 0.4, "y": 0, "z": (self.template.altura_piernas + self.template.altura_torso / 2) * cell_size},
                    "rotacion": {"x": 0, "y": 0, "z": 90}
                },
                "pierna_izquierda": {
                    "geometria": {
                        "tipo": "cylinder",
                        "parametros": {"radiusTop": 0.15, "radiusBottom": 0.15, "height": self.template.altura_piernas * cell_size}
                    },
                    "offset": {"x": -0.25, "y": 0, "z": (self.template.altura_piernas / 2) * cell_size}
                },
                "pierna_derecha": {
                    "geometria": {
                        "tipo": "cylinder",
                        "parametros": {"radiusTop": 0.15, "radiusBottom": 0.15, "height": self.template.altura_piernas * cell_size}
                    },
                    "offset": {"x": 0.25, "y": 0, "z": (self.template.altura_piernas / 2) * cell_size}
                }
            }
        }
```

**Notas:**
- El builder debe crear partículas y agrupación con `geometria_agrupacion`
- Los parámetros de geometría son relativos a `tamano_celda` de la dimensión
- Verificar que el tipo de partícula 'carne' existe en BD, o usar uno genérico

---

#### Paso 1.5: Actualizar EntityCreator para soportar bípedos

**Descripción:**
Actualizar `EntityCreator` para que pueda crear bípedos usando el `BipedBuilder`.

**Archivos a modificar:**
- `backend/src/database/creators/entity_creator.py`

**Detalles de implementación:**
```python
# En entity_creator.py, actualizar método _get_builder()
from src.database.builders.biped_builder import BipedBuilder

def _get_builder(self, template: BaseTemplate) -> BaseBuilder:
    """Obtener builder apropiado según el template"""
    if template.categoria == 'tree':
        return TreeBuilder(template)
    elif template.categoria == 'biped':
        return BipedBuilder(template)
    else:
        raise ValueError(f"No hay builder para categoría '{template.categoria}'")
```

**Notas:**
- Mantener compatibilidad con árboles existentes
- No romper funcionalidad existente

---

#### Paso 1.6: Commit Fase 1

**Descripción:**
Hacer commit de todos los cambios de la Fase 1.

**Comando a ejecutar:**
```bash
git add backend/src/database/templates/bipedos/
git add backend/src/database/builders/biped_builder.py
git add backend/src/database/creators/entity_creator.py
git commit -m "feat(JDG-011): Crear infraestructura de templates y builders para bípedos

- Crear BipedTemplate como clase base para templates de bípedos
- Crear HumanoTemplate con estructura básica (cabeza, torso, brazos, piernas)
- Crear registry de bípedos para descubrimiento dinámico
- Crear BipedBuilder que convierte templates en partículas
- BipedBuilder crea agrupaciones con geometria_agrupacion
- Actualizar EntityCreator para soportar categoría 'biped'
- Agregar README.md en templates/bipedos/

Fase 1 completada: Infraestructura de templates y builders lista"
```

---

### Fase 2: Crear Endpoints de API

#### Paso 2.1: Crear schemas Pydantic para personajes

**Descripción:**
Crear los modelos Pydantic para validar y estructurar las respuestas de API de personajes.

**Archivos a modificar:**
- `backend/src/models/schemas.py`

**Detalles de implementación:**
```python
# Agregar al final de schemas.py
from typing import Optional, Dict, Any
from pydantic import BaseModel

class BipedGeometryPart(BaseModel):
    """Schema para una parte de la geometría de un bípedo"""
    geometria: Dict[str, Any]
    offset: Dict[str, float]
    rotacion: Optional[Dict[str, float]] = None

class BipedGeometry(BaseModel):
    """Schema para geometría completa de un bípedo"""
    tipo: str
    partes: Dict[str, BipedGeometryPart]

class CharacterResponse(BaseModel):
    """Respuesta con información completa de un personaje"""
    id: str
    dimension_id: str
    nombre: str
    tipo: str
    especie: str
    posicion: Dict[str, int]  # {x, y, z}
    geometria_agrupacion: Optional[BipedGeometry] = None
    particulas_count: int

class CharacterCreate(BaseModel):
    """Request para crear un personaje"""
    template_id: str  # ID del template (ej: 'humano')
    x: int
    y: int
    z: int
```

**Notas:**
- Usar tipos apropiados (UUID como str en JSON)
- Validar estructura de geometría

---

#### Paso 2.2: Crear endpoints de API para personajes

**Descripción:**
Crear los endpoints REST para obtener, listar y crear personajes.

**Archivos a crear:**
- `backend/src/api/routes/characters.py`

**Detalles de implementación:**
```python
# api/routes/characters.py
from fastapi import APIRouter, HTTPException, Path
from typing import List
from uuid import UUID
import asyncpg
from src.models.schemas import CharacterResponse, CharacterCreate, BipedGeometry
from src.database.connection import get_connection
from src.database.templates.bipedos.registry import get_biped_template
from src.database.creators.entity_creator import EntityCreator
import json

router = APIRouter(prefix="/api/dimensions/{dimension_id}/characters", tags=["characters"])

@router.get("/{character_id}", response_model=CharacterResponse)
async def get_character(
    dimension_id: UUID = Path(..., description="ID de la dimensión"),
    character_id: UUID = Path(..., description="ID del personaje (agrupación)")
):
    """Obtener información de un personaje"""
    conn = await get_connection()
    
    try:
        # Obtener agrupación
        agrupacion = await conn.fetchrow("""
            SELECT id, nombre, tipo, especie, geometria_agrupacion
            FROM juego_dioses.agrupaciones
            WHERE id = $1 AND dimension_id = $2
        """, character_id, dimension_id)
        
        if not agrupacion:
            raise HTTPException(status_code=404, detail="Personaje no encontrado")
        
        # Obtener posición (primera partícula del personaje)
        particula = await conn.fetchrow("""
            SELECT celda_x, celda_y, celda_z
            FROM juego_dioses.particulas
            WHERE agrupacion_id = $1 AND dimension_id = $2
            ORDER BY celda_z ASC, celda_x ASC, celda_y ASC
            LIMIT 1
        """, character_id, dimension_id)
        
        # Contar partículas
        count = await conn.fetchval("""
            SELECT COUNT(*)
            FROM juego_dioses.particulas
            WHERE agrupacion_id = $1 AND dimension_id = $2
        """, character_id, dimension_id)
        
        # Parsear geometria_agrupacion
        geometria = None
        if agrupacion['geometria_agrupacion']:
            geometria = BipedGeometry(**agrupacion['geometria_agrupacion'])
        
        return CharacterResponse(
            id=str(agrupacion['id']),
            dimension_id=str(dimension_id),
            nombre=agrupacion['nombre'],
            tipo=agrupacion['tipo'],
            especie=agrupacion['especie'],
            posicion={
                'x': particula['celda_x'] if particula else 0,
                'y': particula['celda_y'] if particula else 0,
                'z': particula['celda_z'] if particula else 0
            },
            geometria_agrupacion=geometria,
            particulas_count=count or 0
        )
    finally:
        await conn.close()

@router.get("", response_model=List[CharacterResponse])
async def list_characters(
    dimension_id: UUID = Path(..., description="ID de la dimensión")
):
    """Listar todos los personajes en una dimensión"""
    conn = await get_connection()
    
    try:
        # Obtener todas las agrupaciones de tipo 'biped'
        agrupaciones = await conn.fetch("""
            SELECT id, nombre, tipo, especie, geometria_agrupacion
            FROM juego_dioses.agrupaciones
            WHERE dimension_id = $1 AND tipo = 'biped'
            ORDER BY nombre
        """, dimension_id)
        
        characters = []
        for agrupacion in agrupaciones:
            # Obtener posición y count para cada una
            particula = await conn.fetchrow("""
                SELECT celda_x, celda_y, celda_z
                FROM juego_dioses.particulas
                WHERE agrupacion_id = $1 AND dimension_id = $2
                ORDER BY celda_z ASC, celda_x ASC, celda_y ASC
                LIMIT 1
            """, agrupacion['id'], dimension_id)
            
            count = await conn.fetchval("""
                SELECT COUNT(*)
                FROM juego_dioses.particulas
                WHERE agrupacion_id = $1 AND dimension_id = $2
            """, agrupacion['id'], dimension_id)
            
            geometria = None
            if agrupacion['geometria_agrupacion']:
                geometria = BipedGeometry(**agrupacion['geometria_agrupacion'])
            
            characters.append(CharacterResponse(
                id=str(agrupacion['id']),
                dimension_id=str(dimension_id),
                nombre=agrupacion['nombre'],
                tipo=agrupacion['tipo'],
                especie=agrupacion['especie'],
                posicion={
                    'x': particula['celda_x'] if particula else 0,
                    'y': particula['celda_y'] if particula else 0,
                    'z': particula['celda_z'] if particula else 0
                },
                geometria_agrupacion=geometria,
                particulas_count=count or 0
            ))
        
        return characters
    finally:
        await conn.close()

@router.post("", response_model=CharacterResponse, status_code=201)
async def create_character(
    character_data: CharacterCreate,
    dimension_id: UUID = Path(..., description="ID de la dimensión")
):
    """Crear un personaje desde un template"""
    conn = await get_connection()
    
    try:
        # Obtener template
        template = get_biped_template(character_data.template_id)
        if not template:
            raise HTTPException(status_code=404, detail=f"Template '{character_data.template_id}' no encontrado")
        
        # Crear personaje usando EntityCreator
        creator = EntityCreator(conn, dimension_id)
        particulas_count = await creator.create_entity(
            template,
            character_data.x,
            character_data.y,
            character_data.z,
            create_agrupacion=True
        )
        
        # Obtener la agrupación creada (última creada en esta dimensión)
        agrupacion = await conn.fetchrow("""
            SELECT id, nombre, tipo, especie, geometria_agrupacion
            FROM juego_dioses.agrupaciones
            WHERE dimension_id = $1 AND tipo = 'biped'
            ORDER BY created_at DESC
            LIMIT 1
        """, dimension_id)
        
        if not agrupacion:
            raise HTTPException(status_code=500, detail="Error al crear personaje")
        
        # Obtener posición y count
        particula = await conn.fetchrow("""
            SELECT celda_x, celda_y, celda_z
            FROM juego_dioses.particulas
            WHERE agrupacion_id = $1 AND dimension_id = $2
            ORDER BY celda_z ASC, celda_x ASC, celda_y ASC
            LIMIT 1
        """, agrupacion['id'], dimension_id)
        
        geometria = None
        if agrupacion['geometria_agrupacion']:
            geometria = BipedGeometry(**agrupacion['geometria_agrupacion'])
        
        return CharacterResponse(
            id=str(agrupacion['id']),
            dimension_id=str(dimension_id),
            nombre=agrupacion['nombre'],
            tipo=agrupacion['tipo'],
            especie=agrupacion['especie'],
            posicion={
                'x': particula['celda_x'] if particula else character_data.x,
                'y': particula['celda_y'] if particula else character_data.y,
                'z': particula['celda_z'] if particula else character_data.z
            },
            geometria_agrupacion=geometria,
            particulas_count=particulas_count
        )
    finally:
        await conn.close()
```

**Notas:**
- Usar `get_connection()` del módulo de conexión existente
- Manejar errores apropiadamente con HTTPException
- Validar que el template existe antes de crear

---

#### Paso 2.3: Registrar rutas en la aplicación

**Descripción:**
Registrar las rutas de personajes en la aplicación FastAPI.

**Archivos a modificar:**
- `backend/src/api/__init__.py` o `backend/src/api/routes/__init__.py`
- `backend/src/main.py` (si es necesario)

**Detalles de implementación:**
```python
# En api/__init__.py o api/routes/__init__.py
from fastapi import APIRouter
from src.api.routes import dimensions, particles, agrupaciones, characters

api_router = APIRouter()
api_router.include_router(dimensions.router)
api_router.include_router(particles.router)
api_router.include_router(agrupaciones.router)
api_router.include_router(characters.router)  # Agregar esta línea
```

**Notas:**
- Verificar la estructura actual de registro de rutas
- Asegurar que el orden de registro no cause conflictos

---

#### Paso 2.4: Commit Fase 2

**Descripción:**
Hacer commit de todos los cambios de la Fase 2.

**Comando a ejecutar:**
```bash
git add backend/src/models/schemas.py
git add backend/src/api/routes/characters.py
git add backend/src/api/__init__.py
git commit -m "feat(JDG-011): Crear endpoints de API para personajes

- Agregar schemas Pydantic: CharacterResponse, CharacterCreate, BipedGeometry
- Crear endpoints GET /characters/{character_id} para obtener personaje
- Crear endpoint GET /characters para listar personajes en dimensión
- Crear endpoint POST /characters para crear personaje desde template
- Registrar rutas en aplicación FastAPI

Fase 2 completada: Endpoints de API listos"
```

---

### Fase 3: Integración Frontend - Cliente API

#### Paso 3.1: Crear cliente API para personajes

**Descripción:**
Crear el cliente JavaScript para consumir los endpoints de personajes desde el frontend.

**Archivos a crear:**
- `frontend/src/api/endpoints/characters.js`

**Detalles de implementación:**
```javascript
// api/endpoints/characters.js
import { apiClient } from '../client.js';

/**
 * Obtener información de un personaje
 * @param {string} dimensionId - ID de la dimensión
 * @param {string} characterId - ID del personaje
 * @returns {Promise<Object>} Información del personaje
 */
export async function getCharacter(dimensionId, characterId) {
    try {
        const response = await apiClient.get(
            `/api/dimensions/${dimensionId}/characters/${characterId}`
        );
        return response.data;
    } catch (error) {
        console.error('Error al obtener personaje:', error);
        throw error;
    }
}

/**
 * Listar todos los personajes en una dimensión
 * @param {string} dimensionId - ID de la dimensión
 * @returns {Promise<Array>} Lista de personajes
 */
export async function listCharacters(dimensionId) {
    try {
        const response = await apiClient.get(
            `/api/dimensions/${dimensionId}/characters`
        );
        return response.data;
    } catch (error) {
        console.error('Error al listar personajes:', error);
        throw error;
    }
}

/**
 * Crear un personaje desde un template
 * @param {string} dimensionId - ID de la dimensión
 * @param {string} templateId - ID del template (ej: 'humano')
 * @param {number} x - Posición X
 * @param {number} y - Posición Y
 * @param {number} z - Posición Z
 * @returns {Promise<Object>} Información del personaje creado
 */
export async function createCharacter(dimensionId, templateId, x, y, z) {
    try {
        const response = await apiClient.post(
            `/api/dimensions/${dimensionId}/characters`,
            {
                template_id: templateId,
                x,
                y,
                z
            }
        );
        return response.data;
    } catch (error) {
        console.error('Error al crear personaje:', error);
        throw error;
    }
}
```

**Notas:**
- Verificar que `apiClient` existe y tiene los métodos `get` y `post`
- Manejar errores apropiadamente
- Exportar funciones para uso en otros módulos

---

#### Paso 3.2: Commit Fase 3

**Descripción:**
Hacer commit de todos los cambios de la Fase 3.

**Comando a ejecutar:**
```bash
git add frontend/src/api/endpoints/characters.js
git commit -m "feat(JDG-011): Crear cliente API para personajes en frontend

- Crear funciones getCharacter, listCharacters, createCharacter
- Integrar con cliente API existente
- Manejar errores apropiadamente

Fase 3 completada: Cliente API listo"
```

---

### Fase 4: Modificar PlayerFactory para Usar BD

#### Paso 4.1: Crear función helper para construir mesh desde geometría

**Descripción:**
Crear función helper que construye un mesh Three.js desde `geometria_agrupacion`.

**Archivos a modificar:**
- `frontend/src/ecs/factories/player-factory.js`

**Detalles de implementación:**
```javascript
// Agregar función helper en player-factory.js
import * as THREE from 'three';
import { GeometryRegistry } from '../../renderers/geometries/registry.js';

/**
 * Construir mesh Three.js desde geometria_agrupacion
 * @param {Object} geometria_agrupacion - Geometría de agrupación desde BD
 * @param {number} cellSize - Tamaño de celda en metros
 * @returns {THREE.Group} Grupo con todas las partes del personaje
 */
function buildMeshFromGeometry(geometria_agrupacion, cellSize) {
    const group = new THREE.Group();
    const geometryRegistry = new GeometryRegistry();
    
    if (!geometria_agrupacion || !geometria_agrupacion.partes) {
        // Fallback a mesh simple si no hay geometría
        return createDefaultMesh(cellSize);
    }
    
    // Iterar sobre cada parte
    for (const [parteNombre, parteDef] of Object.entries(geometria_agrupacion.partes)) {
        const { geometria, offset, rotacion } = parteDef;
        
        // Crear geometría Three.js
        const geometry = geometryRegistry.create(
            geometria.tipo,
            geometria.parametros,
            cellSize
        );
        
        // Crear material (temporal, puede mejorarse)
        const material = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Color temporal
            metalness: 0.1,
            roughness: 0.8
        });
        
        // Crear mesh
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        // Aplicar offset (escalado por cellSize)
        if (offset) {
            mesh.position.set(
                (offset.x || 0) * cellSize,
                (offset.y || 0) * cellSize,
                (offset.z || 0) * cellSize
            );
        }
        
        // Aplicar rotación
        if (rotacion) {
            mesh.rotation.set(
                (rotacion.x || 0) * Math.PI / 180,
                (rotacion.y || 0) * Math.PI / 180,
                (rotacion.z || 0) * Math.PI / 180
            );
        }
        
        group.add(mesh);
    }
    
    return group;
}

/**
 * Crear mesh por defecto (fallback)
 */
function createDefaultMesh(cellSize) {
    const group = new THREE.Group();
    
    // Cuerpo (cilindro)
    const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.0, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 0.5;
    body.castShadow = true;
    body.receiveShadow = true;
    group.add(body);
    
    // Cabeza (esfera)
    const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
    const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3 });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 1.25;
    head.castShadow = true;
    head.receiveShadow = true;
    group.add(head);
    
    group.scale.set(cellSize, cellSize, cellSize);
    return group;
}
```

**Notas:**
- Usar `GeometryRegistry` existente para crear geometrías
- Los offsets y rotaciones deben aplicarse correctamente
- Mantener fallback a mesh simple

---

#### Paso 4.2: Modificar PlayerFactory para cargar desde API

**Descripción:**
Modificar `PlayerFactory.createPlayer()` para cargar la forma del personaje desde la API en lugar de hardcodear.

**Archivos a modificar:**
- `frontend/src/ecs/factories/player-factory.js`

**Detalles de implementación:**
```javascript
// Modificar createPlayer() en player-factory.js
import { getCharacter, createCharacter } from '../../api/endpoints/characters.js';

static async createPlayer(options) {
    const { 
        ecs, 
        scene, 
        x = 80, 
        y = 80, 
        z = 1, 
        cellSize = 0.25,
        characterId = null,
        templateId = null,
        dimensionId = null
    } = options;
    
    // Crear entidad
    const playerId = ecs.createEntity();
    
    let character = null;
    let mesh = null;
    
    try {
        // Si hay characterId, cargar desde API
        if (characterId && dimensionId) {
            character = await getCharacter(dimensionId, characterId);
            mesh = buildMeshFromGeometry(character.geometria_agrupacion, cellSize);
        }
        // Si hay templateId, crear personaje primero
        else if (templateId && dimensionId) {
            character = await createCharacter(dimensionId, templateId, x, y, z);
            mesh = buildMeshFromGeometry(character.geometria_agrupacion, cellSize);
        }
        // Fallback a mesh hardcodeado
        else {
            mesh = createDefaultMesh(cellSize);
        }
    } catch (error) {
        console.warn('Error al cargar personaje desde BD, usando fallback:', error);
        mesh = createDefaultMesh(cellSize);
    }
    
    // Agregar a la escena
    scene.add(mesh);
    
    // Usar posición del personaje si está disponible
    const finalX = character?.posicion?.x ?? x;
    const finalY = character?.posicion?.y ?? y;
    const finalZ = character?.posicion?.z ?? z;
    
    // Agregar componentes
    ecs.addComponent(playerId, 'Position', new PositionComponent(finalX, finalY, finalZ));
    
    ecs.addComponent(playerId, 'Physics', new PhysicsComponent({
        velocity: { x: 0, y: 0, z: 0 },
        mass: 70,
        useGravity: true,
        isGrounded: false,
        groundFriction: 0.8,
        airFriction: 0.95,
        maxVelocity: { x: 5, y: 10, z: 5 }
    }));
    
    ecs.addComponent(playerId, 'Render', new RenderComponent({
        mesh: mesh,
        visible: true,
        castShadow: true,
        receiveShadow: true
    }));
    
    ecs.addComponent(playerId, 'Input', new InputComponent());
    
    ecs.addComponent(playerId, 'Animation', new AnimationComponent({
        currentState: 'idle',
        animationSpeed: 1.0
    }));
    
    return playerId;
}
```

**Notas:**
- Hacer `createPlayer` async para poder cargar desde API
- Mantener compatibilidad con código existente (parámetros opcionales)
- Manejar errores y fallback apropiadamente
- Actualizar llamadas a `createPlayer` para usar `await` si es necesario

---

#### Paso 4.3: Actualizar llamadas a PlayerFactory

**Descripción:**
Actualizar las llamadas a `PlayerFactory.createPlayer()` para usar `await` y pasar `dimensionId` si es necesario.

**Archivos a modificar:**
- `frontend/src/app.js` (o donde se llame a `PlayerFactory.createPlayer()`)

**Detalles de implementación:**
```javascript
// En app.js, actualizar llamada a createPlayer
const playerId = await PlayerFactory.createPlayer({
    ecs: this.ecs,
    scene: this.scene,
    x: 45,
    y: 45,
    z: 1,
    cellSize: this.cellSize,
    templateId: 'humano',  // Opcional: crear desde template
    dimensionId: this.dimensionId  // Necesario si se usa templateId o characterId
});
```

**Notas:**
- Verificar que `app.js` tiene acceso a `dimensionId`
- Asegurar que la función que llama a `createPlayer` es async

---

#### Paso 4.4: Commit Fase 4

**Descripción:**
Hacer commit de todos los cambios de la Fase 4.

**Comando a ejecutar:**
```bash
git add frontend/src/ecs/factories/player-factory.js
git add frontend/src/app.js
git commit -m "feat(JDG-011): Modificar PlayerFactory para usar BD

- Crear función buildMeshFromGeometry para construir mesh desde geometria_agrupacion
- Modificar createPlayer para cargar personaje desde API
- Soporte para characterId y templateId
- Mantener fallback a mesh hardcodeado si API falla
- Actualizar llamadas a createPlayer para usar await

Fase 4 completada: PlayerFactory integrado con BD"
```

---

### Fase 5: Testing y Refinamiento

#### Paso 5.1: Crear script de seed para personaje de prueba

**Descripción:**
Crear un script de seed que cree un personaje humano en una dimensión de prueba para verificar que todo funciona.

**Archivos a crear:**
- `backend/src/database/seed_character_test.py`

**Detalles de implementación:**
```python
# seed_character_test.py
"""
Script de seed para crear personaje de prueba
"""
import asyncio
import asyncpg
import os
from dotenv import load_dotenv
from uuid import UUID
from src.database.templates.bipedos.registry import get_biped_template
from src.database.creators.entity_creator import EntityCreator

load_dotenv()

POSTGRES_HOST = os.getenv("POSTGRES_HOST", "postgres")
POSTGRES_PORT = int(os.getenv("POSTGRES_PORT", 5432))
POSTGRES_USER = os.getenv("POSTGRES_USER", "juegodioses")
POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "juegodioses123")
POSTGRES_DB = os.getenv("POSTGRES_DB", "juego_dioses")

async def seed_character_test():
    """Crear personaje humano de prueba"""
    conn = await asyncpg.connect(
        host=POSTGRES_HOST,
        port=POSTGRES_PORT,
        user=POSTGRES_USER,
        password=POSTGRES_PASSWORD,
        database=POSTGRES_DB
    )
    
    try:
        # Obtener dimensión de prueba (asumir que existe)
        dimension_id = await conn.fetchval("""
            SELECT id FROM juego_dioses.dimensiones
            WHERE nombre = 'Terreno de Prueba - Primer Humano'
            LIMIT 1
        """)
        
        if not dimension_id:
            print("Error: Dimensión de prueba no encontrada")
            return
        
        print(f"Creando personaje en dimensión {dimension_id}...")
        
        # Obtener template
        template = get_biped_template('humano')
        if not template:
            print("Error: Template 'humano' no encontrado")
            return
        
        # Crear personaje
        creator = EntityCreator(conn, dimension_id)
        particulas_count = await creator.create_entity(
            template,
            x=45,
            y=45,
            z=1,
            create_agrupacion=True
        )
        
        print(f"Personaje creado: {particulas_count} partículas")
        
    finally:
        await conn.close()

if __name__ == "__main__":
    asyncio.run(seed_character_test())
```

**Notas:**
- Usar dimensión de prueba existente o crear una nueva
- Verificar que el tipo de partícula necesario existe en BD

---

#### Paso 5.2: Probar flujo completo

**Descripción:**
Probar el flujo completo: crear personaje, cargar desde API, renderizar en frontend.

**Pasos manuales:**
1. Ejecutar script de seed: `docker-compose exec backend python -m src.database.seed_character_test`
2. Verificar en BD que se creó la agrupación y partículas
3. Probar endpoint GET `/api/dimensions/{dimension_id}/characters/{character_id}`
4. Probar endpoint GET `/api/dimensions/{dimension_id}/characters`
5. Iniciar frontend y verificar que el personaje se renderiza correctamente
6. Verificar que el mesh coincide con `geometria_agrupacion`

**Notas:**
- Documentar cualquier problema encontrado
- Ajustar código según sea necesario

---

#### Paso 5.3: Probar casos edge

**Descripción:**
Probar casos edge y manejo de errores.

**Casos a probar:**
1. Personaje sin `geometria_agrupacion` (debe usar fallback)
2. API no disponible (debe usar fallback)
3. Geometría inválida (debe validar y manejar error)
4. Template no encontrado (debe retornar error 404)
5. Personaje no encontrado (debe retornar error 404)

**Notas:**
- Asegurar que todos los casos edge están manejados
- Agregar validaciones si es necesario

---

#### Paso 5.4: Actualizar documentación

**Descripción:**
Actualizar READMEs y documentación del proyecto.

**Archivos a actualizar:**
- `backend/src/database/templates/bipedos/README.md` (si no existe, crearlo)
- `backend/src/database/README.md` (actualizar para mencionar bípedos)
- `backend/src/database/templates/README.md` (actualizar para mencionar bípedos)
- `frontend/src/api/endpoints/README.md` (si existe, actualizar)

**Contenido sugerido para `bipedos/README.md`:**
```markdown
# Templates de Bípedos

Este módulo contiene templates para crear personajes bípedos (humanos, elfos, enanos, etc.).

## Estructura

- `base.py`: Clase base `BipedTemplate`
- `humano.py`: Template para humanos
- `registry.py`: Registry para descubrir templates

## Uso

```python
from src.database.templates.bipedos.registry import get_biped_template
from src.database.creators.entity_creator import EntityCreator

template = get_biped_template('humano')
creator = EntityCreator(conn, dimension_id)
await creator.create_entity(template, x=45, y=45, z=1)
```

## Agregar Nuevo Template

1. Crear archivo `nuevo_template.py`
2. Extender `BipedTemplate`
3. Implementar métodos abstractos
4. Registrar en `registry.py`
```

**Notas:**
- **⚠️ READMEs:** Actualizar todos los READMEs relevantes
- Mantener documentación sincronizada con código

---

#### Paso 5.5: Commit Fase 5

**Descripción:**
Hacer commit de todos los cambios de la Fase 5.

**Comando a ejecutar:**
```bash
git add backend/src/database/seed_character_test.py
git add backend/src/database/templates/bipedos/README.md
git add backend/src/database/README.md
git add backend/src/database/templates/README.md
git commit -m "feat(JDG-011): Testing, refinamiento y documentación

- Crear script de seed para personaje de prueba
- Probar flujo completo de creación y renderizado
- Probar casos edge y manejo de errores
- Actualizar documentación (READMEs)
- Verificar que todo funciona correctamente

Fase 5 completada: Sistema listo para producción"
```

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-011_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Cachear información de personajes cuando sea posible
- Optimizar consultas de BD para agrupaciones
- Reutilizar geometrías Three.js cuando hay múltiples personajes del mismo tipo

### Seguridad
- Validar que las geometrías definidas en BD sean válidas
- Prevenir inyección SQL en consultas de agrupaciones
- Validar permisos para crear personajes (futuro)

### Casos Edge
- Personaje sin `geometria_agrupacion` definida (fallback a forma default)
- Partículas del personaje fuera de los límites de la dimensión
- Personaje con geometría inválida (parámetros negativos, etc.)
- Personaje creado pero agrupación no encontrada en BD
- API no disponible (fallback a personaje hardcodeado)
- Múltiples personajes en la misma posición

### Compatibilidad
- Mantener compatibilidad con personajes existentes (hardcodeados) durante transición
- El sistema debe funcionar con el ECS existente
- No romper funcionalidad de otros templates (árboles, etc.)

## Patrones de Código a Usar

- **Backend (FastAPI)**: 
  - Routers modulares con APIRouter
  - Modelos Pydantic para validación
  - async/await para operaciones I/O
  - Manejo de errores con HTTPException

- **Base de Datos**: 
  - asyncpg para conexiones asíncronas
  - Consultas parametrizadas (prevención SQL injection)
  - Transacciones para operaciones atómicas

- **Frontend (Three.js)**: 
  - Clases ES6 para organización
  - async/await para llamadas API
  - Reutilización de GeometryRegistry existente

## Dependencias

### Nuevas Dependencias
Ninguna nueva dependencia requerida. Se usa infraestructura existente.

### Variables de Entorno
No se requieren nuevas variables de entorno.

## Archivos Principales Involucrados

1. `backend/src/database/templates/bipedos/` - Templates de bípedos
2. `backend/src/database/builders/biped_builder.py` - Builder para bípedos
3. `backend/src/database/creators/entity_creator.py` - Creator actualizado
4. `backend/src/api/routes/characters.py` - Endpoints de API
5. `backend/src/models/schemas.py` - Schemas Pydantic
6. `frontend/src/api/endpoints/characters.js` - Cliente API
7. `frontend/src/ecs/factories/player-factory.js` - Factory actualizado

## Testing

### Tests a Crear/Modificar
- Unit tests: `tests/test_biped_template.py`
- Unit tests: `tests/test_biped_builder.py`
- Integration tests: `tests/integration/test_character_api.py`

### Escenarios de Prueba
1. Crear template de humano y verificar estructura
2. Crear bípedo desde template usando EntityCreator
3. Verificar que se crea agrupación con geometria_agrupacion
4. Probar endpoints de API (GET, POST)
5. Cargar personaje desde API en frontend
6. Verificar que mesh renderizado coincide con definición

## Deployment

### Orden de Deployment
1. Backend: Rebuild Docker image y restart container
2. Frontend: Actualizar archivos estáticos
3. Base de datos: No requiere migraciones (usa estructura existente)
4. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar endpoints con curl/Postman
- [ ] Verificar frontend en navegador
- [ ] Verificar logs de Docker
- [ ] Crear personaje de prueba usando seed script
- [ ] Verificar que personaje se renderiza correctamente

---

**Nota Final:** Este plan debe ejecutarse fase por fase, haciendo commit al final de cada fase. Verificar cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

