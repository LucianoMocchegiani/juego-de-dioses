# JDG-012 - Sistema de Modelos 3D para Personajes

## Descripción de la Tarea

Implementar un sistema completo para almacenar, cargar y renderizar modelos 3D (GLTF/GLB) para personajes. El sistema debe usar almacenamiento local en el backend (preparado para migrar a S3), servir modelos a través de API, y renderizarlos en el frontend usando Three.js. El sistema debe mantener compatibilidad con el sistema actual de primitivas como fallback.

**Comportamiento actual:**
- Los personajes se renderizan usando primitivas Three.js (SphereGeometry, CylinderGeometry)
- La geometría se define en `geometria_agrupacion` como JSON con tipos y parámetros
- No hay soporte para modelos 3D complejos con texturas, materiales, animaciones
- No existe infraestructura para almacenar o servir archivos de modelos

**Comportamiento esperado:**
- Los modelos 3D se almacenan en el backend (sistema de archivos local, preparado para S3)
- Cada personaje puede tener un modelo 3D asociado en su agrupación
- El frontend carga el modelo desde la API al inicializar el personaje
- El modelo se renderiza usando Three.js GLTFLoader
- El sistema mantiene compatibilidad con primitivas (fallback si no hay modelo)
- Los modelos se cachean en el frontend para evitar recargas

## Criterios de Aceptación

1. ❌ Existe sistema para almacenar modelos 3D en el backend (sistema de archivos local)
2. ❌ Los modelos se pueden asociar a personajes en la agrupación (campo `modelo_3d` JSONB)
3. ❌ Existe endpoint de API para obtener modelo 3D de un personaje
4. ❌ Existe endpoint de API para servir archivos estáticos de modelos
5. ❌ El frontend puede cargar modelos GLTF/GLB desde la API
6. ❌ El modelo se renderiza correctamente en Three.js
7. ❌ El sistema mantiene compatibilidad con primitivas (fallback si no hay modelo)
8. ❌ Los modelos pueden tener texturas y materiales
9. ❌ El sistema maneja errores correctamente (modelo no encontrado, formato no soportado, etc.)
10. ❌ Los modelos se cachean en el frontend para evitar recargas innecesarias
11. ❌ La posición, escala y rotación del modelo se respetan según configuración
12. ❌ Sistema de almacenamiento preparado para migrar a S3 (Strategy pattern)

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Frontend: HTML5, JavaScript ES6+, Three.js, GLTFLoader
- Base de datos: PostgreSQL 16 (JSONB para modelo_3d)
- Sistema de archivos: Local (preparado para S3 con Strategy pattern)
- Three.js Loaders: GLTFLoader, opcionalmente OBJLoader

## Pasos de Implementación

### Fase 1: Infraestructura Base de Almacenamiento

#### Paso 1.1: Crear sistema de almacenamiento con Strategy pattern

**Descripción:**
Crear la infraestructura base para almacenamiento de modelos usando Strategy pattern, permitiendo cambiar fácilmente de almacenamiento local a S3 en el futuro.

**Archivos a crear:**
- `backend/src/storage/__init__.py`
- `backend/src/storage/storage_interface.py`
- `backend/src/storage/local_file_storage.py`
- `backend/src/storage/README.md`

**Detalles de implementación:**
```python
# storage/storage_interface.py
from abc import ABC, abstractmethod
from typing import Optional, BinaryIO

class BaseStorage(ABC):
    """Interface para sistemas de almacenamiento de modelos 3D"""
    
    @abstractmethod
    async def save_model(self, file_content: bytes, file_path: str) -> str:
        """
        Guardar modelo en almacenamiento
        
        Args:
            file_content: Contenido del archivo en bytes
            file_path: Ruta relativa donde guardar (ej: 'characters/humano.glb')
        
        Returns:
            Ruta completa del archivo guardado
        """
        pass
    
    @abstractmethod
    async def get_model_url(self, file_path: str) -> str:
        """
        Obtener URL para acceder al modelo
        
        Args:
            file_path: Ruta relativa del archivo
        
        Returns:
            URL completa para acceder al modelo
        """
        pass
    
    @abstractmethod
    async def model_exists(self, file_path: str) -> bool:
        """Verificar si un modelo existe"""
        pass
    
    @abstractmethod
    async def delete_model(self, file_path: str) -> bool:
        """Eliminar un modelo"""
        pass

# storage/local_file_storage.py
import os
from pathlib import Path
from typing import Optional
from .storage_interface import BaseStorage

class LocalFileStorage(BaseStorage):
    """Almacenamiento local en sistema de archivos"""
    
    def __init__(self, base_path: str = "static/models"):
        self.base_path = Path(base_path)
        self.base_path.mkdir(parents=True, exist_ok=True)
    
    async def save_model(self, file_content: bytes, file_path: str) -> str:
        full_path = self.base_path / file_path
        full_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(full_path, 'wb') as f:
            f.write(file_content)
        
        return str(full_path.relative_to(self.base_path))
    
    async def get_model_url(self, file_path: str) -> str:
        # URL relativa para servir desde FastAPI
        return f"/static/models/{file_path}"
    
    async def model_exists(self, file_path: str) -> bool:
        full_path = self.base_path / file_path
        return full_path.exists()
    
    async def delete_model(self, file_path: str) -> bool:
        full_path = self.base_path / file_path
        if full_path.exists():
            full_path.unlink()
            return True
        return False
```

**Notas:**
- El Strategy pattern permite cambiar fácilmente a S3 después
- La clase `S3Storage` se puede agregar después sin modificar código existente
- **⚠️ READMEs:** Crear `backend/src/storage/README.md` explicando el sistema de almacenamiento y cómo agregar nuevos backends

**Recursos útiles:**
- FastAPI Static Files: https://fastapi.tiangolo.com/tutorial/static-files/

---

#### Paso 1.2: Configurar FastAPI para servir archivos estáticos

**Descripción:**
Configurar FastAPI para servir archivos de modelos desde el directorio `static/models/`.

**Archivos a modificar:**
- `backend/src/main.py`

**Detalles de implementación:**
```python
# main.py
from fastapi.staticfiles import StaticFiles
from pathlib import Path

# Después de crear la app FastAPI
static_path = Path("static/models")
static_path.mkdir(parents=True, exist_ok=True)

app.mount("/static/models", StaticFiles(directory=str(static_path)), name="models")
```

**Notas:**
- Los archivos se servirán en `/static/models/{ruta}`
- Validar que el directorio existe antes de montarlo
- Considerar seguridad: validar rutas para prevenir path traversal

---

#### Paso 1.3: Crear estructura de carpetas para modelos

**Descripción:**
Crear la estructura de carpetas donde se almacenarán los modelos 3D.

**Archivos/carpetas a crear:**
- `backend/static/models/characters/` (directorio)
- `backend/static/models/.gitkeep` (para mantener en git)

**Notas:**
- Crear estructura: `static/models/characters/` para modelos de personajes
- Agregar `.gitkeep` para mantener estructura en git (sin modelos reales inicialmente)
- Documentar estructura en `backend/src/storage/README.md`

---

### Fase 2: Backend - Base de Datos y Schemas

#### Paso 2.1: Agregar campo modelo_3d a agrupaciones

**Descripción:**
Agregar campo JSONB `modelo_3d` a la tabla `agrupaciones` para almacenar referencias a modelos 3D.

**Archivos a crear:**
- `database/migrations/add_modelo_3d_to_agrupaciones.sql` (opcional, o hacer directo en BD)

**Detalles de implementación:**
```sql
-- Agregar campo modelo_3d a agrupaciones
ALTER TABLE juego_dioses.agrupaciones
ADD COLUMN modelo_3d JSONB;

-- Crear índice GIN para búsquedas rápidas
CREATE INDEX idx_agrupaciones_modelo_3d ON juego_dioses.agrupaciones USING GIN (modelo_3d);

-- Ejemplo de contenido:
-- {
--   "tipo": "gltf",
--   "ruta": "characters/humano.glb",
--   "escala": 1.0,
--   "offset": {"x": 0, "y": 0, "z": 0},
--   "rotacion": {"x": 0, "y": 0, "z": 0}
-- }
```

**Notas:**
- El campo es opcional (NULL si no hay modelo)
- Usar JSONB para flexibilidad y búsquedas rápidas
- Índice GIN para búsquedas eficientes en JSONB

---

#### Paso 2.2: Crear schemas Pydantic para modelos 3D

**Descripción:**
Agregar schemas Pydantic para validar datos de modelos 3D.

**Archivos a modificar:**
- `backend/src/models/schemas.py`

**Detalles de implementación:**
```python
# schemas.py
from pydantic import BaseModel, Field
from typing import Optional, Dict, Literal

class Model3DOffset(BaseModel):
    """Offset del modelo 3D"""
    x: float = Field(default=0.0, description="Offset X en metros")
    y: float = Field(default=0.0, description="Offset Y en metros")
    z: float = Field(default=0.0, description="Offset Z en metros")

class Model3DRotation(BaseModel):
    """Rotación del modelo 3D en grados"""
    x: float = Field(default=0.0, ge=0, le=360, description="Rotación X en grados")
    y: float = Field(default=0.0, ge=0, le=360, description="Rotación Y en grados")
    z: float = Field(default=0.0, ge=0, le=360, description="Rotación Z en grados")

class Model3D(BaseModel):
    """Modelo 3D asociado a una agrupación"""
    tipo: Literal["gltf", "glb", "obj"] = Field(..., description="Tipo de modelo")
    ruta: str = Field(..., description="Ruta relativa del modelo (ej: 'characters/humano.glb')")
    escala: float = Field(default=1.0, gt=0, description="Escala del modelo")
    offset: Optional[Model3DOffset] = Field(default=None, description="Offset del modelo")
    rotacion: Optional[Model3DRotation] = Field(default=None, description="Rotación del modelo")
```

**Notas:**
- Validar que `ruta` no contenga `..` para prevenir path traversal
- Validar que `tipo` sea uno de los formatos soportados
- `escala` debe ser mayor que 0

---

### Fase 3: Backend - Modificar Builders y Endpoints

#### Paso 3.1: Modificar BipedBuilder para soportar modelo_3d

**Descripción:**
Modificar `BipedBuilder` para que pueda incluir `modelo_3d` al crear agrupaciones.

**Archivos a modificar:**
- `backend/src/database/builders/biped_builder.py`

**Detalles de implementación:**
```python
# biped_builder.py
from src.models.schemas import Model3D
from typing import Optional

class BipedBuilder(BaseBuilder):
    def __init__(self, template: BipedTemplate, modelo_3d: Optional[Model3D] = None):
        super().__init__(template)
        self.template: BipedTemplate = template
        self.modelo_3d: Optional[Model3D] = modelo_3d
    
    async def create_agrupacion(
        self,
        conn: asyncpg.Connection,
        dimension_id: UUID,
        x: int,
        y: int,
        z: int
    ) -> Optional[UUID]:
        metadata = self.get_agrupacion_metadata()
        tamano_celda = await self._get_tamano_celda(conn, dimension_id)
        geometria = self._build_geometria_agrupacion(tamano_celda)
        
        # Incluir modelo_3d si está disponible
        modelo_3d_json = None
        if self.modelo_3d:
            modelo_3d_json = json.dumps(self.modelo_3d.dict())
        
        agrupacion_id = await conn.fetchval("""
            INSERT INTO juego_dioses.agrupaciones
            (dimension_id, nombre, tipo, especie, geometria_agrupacion, modelo_3d, posicion_x, posicion_y, posicion_z)
            VALUES ($1, $2, $3, $4, $5::jsonb, $6::jsonb, $7, $8, $9)
            RETURNING id
        """, dimension_id, metadata['nombre'], metadata['tipo'], metadata['especie'], 
            json.dumps(geometria), modelo_3d_json, x, y, z)
        
        return agrupacion_id
```

**Notas:**
- `modelo_3d` es opcional, si no se proporciona, se usa `None`
- Mantener compatibilidad: si no hay `modelo_3d`, usar primitivas
- Validar que la ruta del modelo existe antes de crear agrupación

---

#### Paso 3.2: Actualizar CharacterResponse schema

**Descripción:**
Agregar campo `modelo_3d` al schema `CharacterResponse`.

**Archivos a modificar:**
- `backend/src/models/schemas.py`

**Detalles de implementación:**
```python
# schemas.py
class CharacterResponse(BaseModel):
    """Respuesta con información completa de un personaje"""
    id: str
    dimension_id: str
    nombre: str
    tipo: str
    especie: str
    posicion: Dict[str, int]
    geometria_agrupacion: Optional[BipedGeometry] = None
    modelo_3d: Optional[Model3D] = None  # Nuevo campo
    particulas_count: int
```

**Notas:**
- El campo es opcional (puede ser None si no hay modelo)
- Parsear desde JSONB usando `parse_jsonb_field()`

---

#### Paso 3.3: Actualizar endpoints de characters para incluir modelo_3d

**Descripción:**
Modificar los endpoints `get_character`, `list_characters` y `create_character` para incluir `modelo_3d` en las respuestas.

**Archivos a modificar:**
- `backend/src/api/routes/characters.py`

**Detalles de implementación:**
```python
# characters.py
# En get_character():
agrupacion = await conn.fetchrow("""
    SELECT id, nombre, tipo, especie, geometria_agrupacion, modelo_3d, posicion_x, posicion_y, posicion_z
    FROM juego_dioses.agrupaciones
    WHERE id = $1 AND dimension_id = $2
""", character_id, dimension_id)

# Parsear modelo_3d
modelo_3d = None
if agrupacion['modelo_3d']:
    modelo_3d_data = parse_jsonb_field(agrupacion['modelo_3d'])
    if modelo_3d_data:
        try:
            modelo_3d = Model3D(**modelo_3d_data)
        except Exception as e:
            print(f"Error parseando modelo_3d: {e}")

return CharacterResponse(
    # ... otros campos ...
    modelo_3d=modelo_3d
)
```

**Notas:**
- Aplicar mismo patrón en `list_characters()` y `create_character()`
- Manejar errores de parsing sin fallar completamente

---

#### Paso 3.4: Crear endpoint para obtener URL del modelo

**Descripción:**
Crear endpoint que retorne la URL del modelo 3D de un personaje.

**Archivos a modificar:**
- `backend/src/api/routes/characters.py`

**Detalles de implementación:**
```python
# characters.py
@router.get("/{character_id}/model")
async def get_character_model(
    dimension_id: UUID = Path(..., description="ID de la dimensión"),
    character_id: UUID = Path(..., description="ID del personaje")
):
    """
    Obtener URL y metadatos del modelo 3D de un personaje
    """
    async with get_connection() as conn:
        agrupacion = await conn.fetchrow("""
            SELECT modelo_3d
            FROM juego_dioses.agrupaciones
            WHERE id = $1 AND dimension_id = $2 AND tipo = 'biped'
        """, character_id, dimension_id)
        
        if not agrupacion or not agrupacion['modelo_3d']:
            raise HTTPException(status_code=404, detail="Personaje no tiene modelo 3D")
        
        modelo_3d_data = parse_jsonb_field(agrupacion['modelo_3d'])
        modelo_3d = Model3D(**modelo_3d_data)
        
        # Construir URL completa
        model_url = f"/static/models/{modelo_3d.ruta}"
        
        return {
            "model_url": model_url,
            "metadata": modelo_3d.dict()
        }
```

**Notas:**
- Validar que el personaje existe y es tipo 'biped'
- Retornar 404 si no tiene modelo 3D
- La URL debe ser relativa para que el frontend la use directamente

---

### Fase 4: Frontend - Sistema de Carga de Modelos

#### Paso 4.1: Crear ModelLoader con Factory pattern

**Descripción:**
Crear sistema de loaders de modelos 3D usando Factory pattern para soportar múltiples formatos.

**Archivos a crear:**
- `frontend/src/renderers/models/__init__.js`
- `frontend/src/renderers/models/model-loader.js`
- `frontend/src/renderers/models/gltf-loader.js`
- `frontend/src/renderers/models/README.md`

**Detalles de implementación:**
```javascript
// renderers/models/model-loader.js
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
// import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js'; // Opcional

export class ModelLoader {
    constructor() {
        this.loaders = new Map();
        this.loaders.set('gltf', new GLTFLoader());
        this.loaders.set('glb', new GLTFLoader()); // GLB usa GLTFLoader
        // this.loaders.set('obj', new OBJLoader()); // Opcional
    }
    
    /**
     * Cargar modelo 3D según tipo
     * @param {string} url - URL del modelo
     * @param {string} tipo - Tipo de modelo ('gltf', 'glb', 'obj')
     * @returns {Promise<THREE.Group>} Grupo Three.js con el modelo
     */
    async loadModel(url, tipo) {
        const loader = this.loaders.get(tipo.toLowerCase());
        if (!loader) {
            throw new Error(`Tipo de modelo no soportado: ${tipo}`);
        }
        
        if (tipo === 'gltf' || tipo === 'glb') {
            const gltf = await loader.loadAsync(url);
            return gltf.scene;
        }
        // Agregar otros tipos aquí si se implementan
    }
}
```

**Notas:**
- Usar Factory pattern para fácil extensión
- GLTFLoader puede cargar tanto .gltf como .glb
- **⚠️ READMEs:** Crear `frontend/src/renderers/models/README.md` explicando el sistema de loaders

**Recursos útiles:**
- Three.js GLTFLoader: https://threejs.org/docs/#examples/en/loaders/GLTFLoader

---

#### Paso 4.2: Crear ModelCache con Registry pattern

**Descripción:**
Crear sistema de cache para modelos cargados, evitando recargas innecesarias.

**Archivos a crear:**
- `frontend/src/renderers/models/model-cache.js`

**Detalles de implementación:**
```javascript
// renderers/models/model-cache.js
export class ModelCache {
    constructor() {
        this.cache = new Map(); // URL -> THREE.Group
    }
    
    /**
     * Obtener modelo del cache
     * @param {string} url - URL del modelo
     * @returns {THREE.Group|null} Modelo cacheado o null
     */
    get(url) {
        const cached = this.cache.get(url);
        if (cached) {
            // Clonar para evitar modificar el original
            return cached.clone();
        }
        return null;
    }
    
    /**
     * Verificar si modelo está en cache
     * @param {string} url - URL del modelo
     * @returns {boolean}
     */
    has(url) {
        return this.cache.has(url);
    }
    
    /**
     * Agregar modelo al cache
     * @param {string} url - URL del modelo
     * @param {THREE.Group} model - Modelo Three.js
     */
    set(url, model) {
        this.cache.set(url, model);
    }
    
    /**
     * Limpiar cache
     */
    clear() {
        this.cache.clear();
    }
    
    /**
     * Singleton instance
     */
    static getInstance() {
        if (!ModelCache.instance) {
            ModelCache.instance = new ModelCache();
        }
        return ModelCache.instance;
    }
}
```

**Notas:**
- Usar Singleton para un solo cache global
- Clonar modelos al retornar para evitar modificar el original
- Considerar límite de tamaño del cache (futuro)

---

#### Paso 4.3: Crear función para cargar modelo 3D con transformaciones

**Descripción:**
Crear función helper que carga modelo 3D y aplica escala, offset y rotación según configuración.

**Archivos a crear:**
- `frontend/src/renderers/models/model-utils.js`

**Detalles de implementación:**
```javascript
// renderers/models/model-utils.js
import { ModelLoader } from './model-loader.js';
import { ModelCache } from './model-cache.js';

const modelLoader = new ModelLoader();
const modelCache = ModelCache.getInstance();

/**
 * Cargar modelo 3D y aplicar transformaciones
 * @param {Object} modelo3d - Configuración del modelo desde BD
 * @param {number} cellSize - Tamaño de celda en metros
 * @returns {Promise<THREE.Group>} Grupo con modelo transformado
 */
export async function loadModel3D(modelo3d, cellSize) {
    const modelUrl = `/static/models/${modelo3d.ruta}`;
    
    // Verificar cache
    if (modelCache.has(modelUrl)) {
        const cached = modelCache.get(modelUrl);
        return applyTransformations(cached, modelo3d, cellSize);
    }
    
    // Cargar modelo
    const model = await modelLoader.loadModel(modelUrl, modelo3d.tipo);
    
    // Cachear modelo original (sin transformaciones)
    modelCache.set(modelUrl, model.clone());
    
    // Aplicar transformaciones
    return applyTransformations(model, modelo3d, cellSize);
}

/**
 * Aplicar transformaciones a un modelo
 * @param {THREE.Group} model - Modelo Three.js
 * @param {Object} modelo3d - Configuración del modelo
 * @param {number} cellSize - Tamaño de celda
 * @returns {THREE.Group} Modelo transformado
 */
function applyTransformations(model, modelo3d, cellSize) {
    // Aplicar escala
    const escala = (modelo3d.escala || 1.0) * cellSize;
    model.scale.set(escala, escala, escala);
    
    // Aplicar offset (en metros, convertir a coordenadas del juego)
    if (modelo3d.offset) {
        model.position.set(
            (modelo3d.offset.x || 0),
            (modelo3d.offset.z || 0), // Z del juego -> Y de Three.js
            (modelo3d.offset.y || 0)  // Y del juego -> Z de Three.js
        );
    }
    
    // Aplicar rotación (convertir grados a radianes)
    if (modelo3d.rotacion) {
        model.rotation.set(
            ((modelo3d.rotacion.x || 0) * Math.PI) / 180,
            ((modelo3d.rotacion.z || 0) * Math.PI) / 180, // Z del juego -> Y de Three.js
            ((modelo3d.rotacion.y || 0) * Math.PI) / 180  // Y del juego -> Z de Three.js
        );
    }
    
    return model;
}
```

**Notas:**
- Mapear coordenadas del juego (X, Y, Z) a Three.js (X, Z, Y)
- Aplicar escala relativa a `cellSize`
- Cachear modelo original antes de transformaciones

---

#### Paso 4.4: Modificar PlayerFactory para cargar modelos 3D

**Descripción:**
Modificar `PlayerFactory.createPlayer()` para detectar y cargar modelos 3D, con fallback a primitivas.

**Archivos a modificar:**
- `frontend/src/ecs/factories/player-factory.js`

**Detalles de implementación:**
```javascript
// player-factory.js
import { loadModel3D } from '../../renderers/models/model-utils.js';

export class PlayerFactory {
    static async createPlayer(options) {
        // ... código existente ...
        
        let character = null;
        let mesh = null;
        
        try {
            if (characterId && dimensionId) {
                character = await getCharacter(dimensionId, characterId);
            } else if (templateId && dimensionId) {
                character = await createCharacter(dimensionId, templateId, x, y, z);
            }
            
            // Prioridad: modelo_3d > geometria_agrupacion > default
            if (character?.modelo_3d) {
                try {
                    mesh = await loadModel3D(character.modelo_3d, cellSize);
                    console.log(`✓ Modelo 3D cargado: ${character.modelo_3d.ruta}`);
                } catch (error) {
                    console.warn('Error cargando modelo 3D, usando geometria_agrupacion:', error);
                    // Fallback a geometria_agrupacion
                    if (character?.geometria_agrupacion) {
                        mesh = buildMeshFromGeometry(character.geometria_agrupacion, cellSize);
                    } else {
                        mesh = createDefaultMesh(cellSize);
                    }
                }
            } else if (character?.geometria_agrupacion) {
                mesh = buildMeshFromGeometry(character.geometria_agrupacion, cellSize);
            } else {
                mesh = createDefaultMesh(cellSize);
            }
        } catch (error) {
            console.warn('Error al cargar personaje, usando fallback:', error);
            mesh = createDefaultMesh(cellSize);
        }
        
        // ... resto del código ...
    }
}
```

**Notas:**
- Prioridad: modelo_3d > geometria_agrupacion > default
- Manejar errores en cada nivel con fallback
- Logging para debugging

---

#### Paso 4.5: Agregar método getModelUrl en CharactersApi

**Descripción:**
Agregar método en el cliente API para obtener URL del modelo de un personaje.

**Archivos a modificar:**
- `frontend/src/api/endpoints/characters.js`

**Detalles de implementación:**
```javascript
// characters.js
export class CharactersApi {
    // ... métodos existentes ...
    
    /**
     * Obtener URL y metadatos del modelo 3D de un personaje
     * @param {string} dimensionId - ID de la dimensión
     * @param {string} characterId - ID del personaje
     * @returns {Promise<Object>} { model_url, metadata }
     */
    async getCharacterModel(dimensionId, characterId) {
        const response = await this.client.get(
            `/dimensions/${dimensionId}/characters/${characterId}/model`
        );
        return response.data;
    }
}

// Agregar función helper
export async function getCharacterModel(dimensionId, characterId) {
    if (!charactersApiInstance) initCharactersApi(apiClient);
    return charactersApiInstance.getCharacterModel(dimensionId, characterId);
}
```

**Notas:**
- Método opcional, puede usarse para verificar modelo antes de cargar
- Útil para debugging y validación

---

### Fase 5: Testing y Documentación

#### Paso 5.1: Crear script de seed con modelo de prueba

**Descripción:**
Crear script para probar el sistema completo con un modelo de prueba.

**Archivos a crear:**
- `backend/src/database/seed_character_with_model.py`

**Detalles de implementación:**
```python
# seed_character_with_model.py
"""
Script para crear personaje con modelo 3D de prueba
"""
import asyncio
from src.database.creators.entity_creator import EntityCreator
from src.database.templates.bipedos.registry import get_biped_template
from src.models.schemas import Model3D
from src.storage.local_file_storage import LocalFileStorage
# ... imports necesarios ...

async def main():
    # 1. Crear modelo de prueba (o usar uno existente)
    storage = LocalFileStorage()
    model_path = "characters/humano_test.glb"
    
    # Verificar que el modelo existe
    if not await storage.model_exists(model_path):
        print(f"⚠️ Modelo no encontrado: {model_path}")
        print("Coloca un modelo GLB en backend/static/models/characters/")
        return
    
    # 2. Crear modelo_3d
    modelo_3d = Model3D(
        tipo="glb",
        ruta=model_path,
        escala=1.0,
        offset={"x": 0, "y": 0, "z": 0},
        rotacion={"x": 0, "y": 0, "z": 0}
    )
    
    # 3. Crear personaje con modelo
    template = get_biped_template('humano')
    builder = BipedBuilder(template, modelo_3d=modelo_3d)
    
    # ... resto del código para crear personaje ...
```

**Notas:**
- Script de prueba para verificar funcionamiento end-to-end
- Requiere modelo GLB de prueba en `backend/static/models/characters/`

---

#### Paso 5.2: Actualizar documentación

**Descripción:**
Actualizar READMEs y documentación del sistema.

**Archivos a modificar:**
- `backend/src/storage/README.md` (crear)
- `backend/src/database/builders/README.md` (actualizar)
- `frontend/src/renderers/models/README.md` (crear)
- `backend/src/api/routes/README.md` (actualizar)

**Notas:**
- Documentar cómo agregar nuevos modelos
- Documentar estructura de `modelo_3d` JSONB
- Documentar cómo migrar a S3 en el futuro
- **⚠️ READMEs:** Actualizar todos los READMEs relevantes

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-012_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Cache de modelos en frontend evita recargas
- Lazy loading: cargar modelos solo cuando se necesitan
- Considerar instancing para múltiples personajes (futuro)
- Optimizar modelos antes de subir (reducir polígonos, comprimir)

### Seguridad
- Validar rutas de archivos para prevenir path traversal
- Validar tipos de archivo permitidos (gltf, glb, obj)
- Limitar tamaño de archivos (configurable)
- Sanitizar nombres de archivos
- Validar que rutas no contengan `..` o rutas absolutas

### Casos Edge
- Modelo no encontrado → fallback a primitivas
- Modelo corrupto o formato inválido → fallback a primitivas
- Modelo muy grande (>10MB) → considerar límite o compresión
- Múltiples personajes cargando simultáneamente → cache ayuda
- Modelo sin texturas → renderizar con materiales por defecto
- Conexión lenta → mostrar placeholder mientras carga (futuro)

### Compatibilidad
- Mantener sistema actual de primitivas como fallback
- Campo `modelo_3d` es opcional (NULL si no hay modelo)
- Personajes pueden tener modelo o primitivas (migración gradual)
- Backward compatible: personajes existentes siguen funcionando

## Patrones de Código a Usar

- **Backend (FastAPI)**: 
  - Strategy pattern para almacenamiento
  - Validación con Pydantic
  - async/await para operaciones I/O
  - Manejo de errores con HTTPException
  - Documentación automática con docstrings

- **Frontend (Three.js)**: 
  - Factory pattern para loaders
  - Registry pattern para cache
  - Singleton para ModelCache
  - Clases ES6 para organización
  - Manejo de errores con try-catch y fallbacks

- **Base de Datos**: 
  - JSONB para flexibilidad
  - Índices GIN para búsquedas rápidas
  - Campo opcional para compatibilidad

## Dependencias

### Nuevas Dependencias

**Frontend:**
```json
// package.json (si se usa npm, o agregar directamente)
{
  "dependencies": {
    "three": "^0.160.0"  // Ya existe, pero verificar versión
  }
}
```

**Nota:** GLTFLoader viene incluido en Three.js, no requiere dependencias adicionales.

### Variables de Entorno

**Backend:**
- `MODELS_STORAGE_PATH` (opcional): Ruta base para almacenar modelos (default: `static/models`)
- `MODELS_MAX_SIZE` (opcional): Tamaño máximo de modelo en bytes (default: 50MB)
- `MODELS_ALLOWED_TYPES` (opcional): Tipos permitidos separados por coma (default: `gltf,glb,obj`)

## Archivos Principales Involucrados

1. `backend/src/storage/storage_interface.py` - Interface para almacenamiento
2. `backend/src/storage/local_file_storage.py` - Implementación local
3. `backend/src/models/schemas.py` - Schemas para Model3D
4. `backend/src/database/builders/biped_builder.py` - Soporte para modelo_3d
5. `backend/src/api/routes/characters.py` - Endpoints actualizados
6. `backend/src/main.py` - Configuración de archivos estáticos
7. `frontend/src/renderers/models/model-loader.js` - Loader de modelos
8. `frontend/src/renderers/models/model-cache.js` - Cache de modelos
9. `frontend/src/renderers/models/model-utils.js` - Utilidades de carga
10. `frontend/src/ecs/factories/player-factory.js` - Integración con modelos

## Testing

### Tests a Crear/Modificar
- Unit tests: `tests/test_storage.py` (opcional)
- Integration tests: `tests/integration/test_character_models.py` (opcional)

### Escenarios de Prueba
1. **Cargar personaje con modelo GLTF**: Crear personaje con modelo, verificar que se carga y renderiza
2. **Cargar personaje sin modelo**: Verificar que usa fallback a primitivas
3. **Modelo no encontrado**: Intentar cargar modelo inexistente, verificar fallback
4. **Múltiples personajes con mismo modelo**: Verificar que se cachea correctamente
5. **Modelo con texturas**: Verificar que texturas se cargan correctamente
6. **Escala y posición**: Verificar que transformaciones se aplican correctamente
7. **Modelo corrupto**: Intentar cargar modelo inválido, verificar fallback
8. **Diferentes formatos**: Probar GLTF, GLB (OBJ opcional)

## Deployment

### Orden de Deployment
1. Backend: 
   - Crear directorio `static/models/characters/` en contenedor
   - Rebuild Docker image y restart container
   - Ejecutar migración SQL (agregar campo `modelo_3d`)
2. Frontend: 
   - Verificar que Three.js incluye GLTFLoader
   - No requiere cambios en Docker (solo código)
3. Base de datos: 
   - Ejecutar migración: `ALTER TABLE juego_dioses.agrupaciones ADD COLUMN modelo_3d JSONB;`
   - Crear índice: `CREATE INDEX idx_agrupaciones_modelo_3d ON juego_dioses.agrupaciones USING GIN (modelo_3d);`

### Verificación Post-Deployment
- [ ] Verificar que directorio `static/models/` existe y es accesible
- [ ] Verificar endpoint `/static/models/{ruta}` sirve archivos correctamente
- [ ] Verificar endpoint `/api/v1/dimensions/{id}/characters/{id}/model` funciona
- [ ] Crear personaje con modelo de prueba
- [ ] Verificar que modelo se carga en frontend
- [ ] Verificar que fallback funciona si modelo no existe
- [ ] Verificar logs de Docker para errores
- [ ] Verificar que cache funciona (múltiples personajes con mismo modelo)

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

