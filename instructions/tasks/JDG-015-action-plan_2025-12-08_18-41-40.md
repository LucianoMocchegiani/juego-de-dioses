# JDG-015 - Animaciones Básicas para Personaje Humano

## Descripción de la Tarea

Implementar sistema de animaciones para personajes usando animaciones pre-renderizadas en formato GLB. El sistema utiliza Three.js AnimationMixer para reproducir animaciones de caminar, correr, ataque y combat stance según el estado del personaje.

**Comportamiento actual:**
- El personaje se muestra en T-pose estático todo el tiempo
- El sistema de animaciones solo determina el estado (idle, walk, run, etc.) pero no reproduce animaciones visuales
- No hay movimiento de brazos, piernas u otras partes del cuerpo

**Comportamiento esperado:**
- Al caminar: se reproduce animación de caminar
- Al correr: se reproduce animación de correr
- Al estar idle: se reproduce animación de combat_stance
- Al atacar: se reproduce animación de ataque y luego vuelve a combat_stance
- Las animaciones son suaves y naturales
- Las transiciones entre animaciones son fluidas (fadeOut/fadeIn)

## Criterios de Aceptación

1. ✅ El sistema carga animaciones desde archivos GLB separados
2. ✅ Las animaciones se reproducen correctamente según el estado del personaje
3. ✅ Las animaciones de caminar y correr funcionan correctamente
4. ✅ La animación de combat_stance se muestra cuando el personaje está idle
5. ✅ La animación de ataque se reproduce cuando el usuario hace click izquierdo
6. ✅ Las transiciones entre animaciones son suaves (sin T-pose ni saltos bruscos)
7. ✅ El sistema maneja correctamente el ciclo de vida de las animaciones (inicio, loop, fin)
8. ✅ El sistema preserva las transformaciones del modelo original (posición, rotación, escala)
9. ✅ El sistema funciona con el modelo Character_output.glb y animaciones de Meshy
10. ✅ Las animaciones no afectan negativamente el rendimiento (mantener 60 FPS)

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js
- Three.js AnimationMixer: Para reproducir animaciones desde GLB
- Three.js GLTFLoader: Para cargar archivos GLB
- ECS (Entity Component System): AnimationSystem, AnimationMixerSystem
- Animaciones GLB: Archivos pre-renderizados generados con Meshy (IA)

## Pasos de Implementación

### Paso 1: Obtener Archivos de Animación GLB

**Descripción:**
Obtener archivos GLB con animaciones pre-renderizadas. Las animaciones fueron generadas usando Meshy (IA) e incluyen el modelo con animaciones de caminar, correr, ataque y combat stance.

**Archivos a agregar:**
- `backend/static/models/animations/Animation_Walking_withSkin.glb`
- `backend/static/models/animations/Animation_Running_withSkin.glb`
- `backend/static/models/animations/Animation_Combat_Stance_withSkin.glb`
- `backend/static/models/animations/Animation_Left_Slash_withSkin.glb`

**Detalles de implementación:**
1. Crear directorio `backend/static/models/animations/` si no existe
2. Copiar los archivos GLB de animación al directorio
3. Verificar que los archivos son accesibles desde el backend (ruta `/static/models/animations/`)

**Notas:**
- Las animaciones de Meshy incluyen el modelo completo con esqueleto
- Cada archivo GLB contiene una animación específica
- El modelo en cada archivo debe tener el mismo esqueleto para compatibilidad

---

### Paso 2: Crear AnimationMixerSystem

**Descripción:**
Crear sistema que utiliza Three.js AnimationMixer para cargar y reproducir animaciones desde archivos GLB.

**Archivos a crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// frontend/src/ecs/systems/animation-mixer-system.js
import { System } from '../system.js';
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { getBackendBaseUrl } from '../../utils/config.js';

const gltfLoader = new GLTFLoader();

// Mapeo de estados de animación a archivos de animación
const ANIMATION_FILES = {
    'walk': 'animations/Animation_Walking_withSkin.glb',
    'run': 'animations/Animation_Running_withSkin.glb',
    'combat_stance': 'animations/Animation_Combat_Stance_withSkin.glb',
    'attack': 'animations/Animation_Left_Slash_withSkin.glb'
};

export class AnimationMixerSystem extends System {
    constructor() {
        super();
        this.requiredComponents = ['Render', 'Animation'];
        this.priority = 2.5; // Entre AnimationSystem (2) y RenderSystem (3)
        
        // Cache de animaciones cargadas
        this.animationCache = new Map();
        
        // Prevenir múltiples inicializaciones simultáneas
        this.initializingMixers = new Set();
    }
    
    // Métodos: loadAnimation, initializeMixer, playAnimation, update
}
```

**Notas:**
- El sistema se ejecuta después de AnimationSystem (que determina el estado) y antes de RenderSystem
- Usa cache para evitar recargar animaciones múltiples veces
- Previne múltiples inicializaciones simultáneas del mismo mixer

---

### Paso 3: Implementar Carga de Animaciones

**Descripción:**
Implementar método para cargar animaciones desde archivos GLB con sistema de cache.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
async loadAnimation(animationFile) {
    // Verificar cache
    if (this.animationCache.has(animationFile)) {
        return this.animationCache.get(animationFile);
    }
    
    const backendBase = getBackendBaseUrl();
    const url = `${backendBase}/static/models/${animationFile}`;
    
    try {
        const gltf = await gltfLoader.loadAsync(url);
        
        if (gltf.animations && gltf.animations.length > 0) {
            this.animationCache.set(animationFile, gltf.animations);
            return gltf.animations;
        } else {
            return [];
        }
    } catch (error) {
        // Error cargando animación, retornar array vacío
        return [];
    }
}
```

**Notas:**
- Las animaciones se cachean para evitar recargas
- Si un archivo no tiene animaciones, retorna array vacío
- Maneja errores graciosamente sin romper el juego

---

### Paso 4: Implementar Inicialización de AnimationMixer

**Descripción:**
Implementar método para inicializar AnimationMixer para cada entidad. El mixer necesita el modelo con esqueleto correcto, por lo que se usa el modelo del archivo de animación como base.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
async initializeMixer(entityId, mesh) {
    // Verificar si ya tiene mixer
    if (mesh.userData.animationMixer) {
        return mesh.userData.animationMixer;
    }
    
    // Prevenir múltiples inicializaciones simultáneas
    if (this.initializingMixers.has(entityId)) {
        return null;
    }
    this.initializingMixers.add(entityId);
    
    try {
        // Las animaciones de Meshy requieren el modelo que viene con ellas
        const backendBase = getBackendBaseUrl();
        const baseModelFile = ANIMATION_FILES['walk'];
        const baseModelUrl = `${backendBase}/static/models/${baseModelFile}`;
        
        const gltf = await gltfLoader.loadAsync(baseModelUrl);
        const animatedModel = gltf.scene;
        
        // Buscar el SkinnedMesh en el modelo animado
        let skinnedMesh = null;
        animatedModel.traverse((child) => {
            if (child.isSkinnedMesh && child.skeleton) {
                skinnedMesh = child;
            }
        });
        
        if (!skinnedMesh) {
            this.initializingMixers.delete(entityId);
            return null;
        }
        
        // Reemplazar el mesh actual con el modelo animado, preservando transformaciones
        const parent = mesh.parent;
        const originalPosition = mesh.position.clone();
        const originalRotation = mesh.rotation.clone();
        const originalScale = mesh.scale.clone();
        const originalUserData = { ...mesh.userData };
        
        // Remover mesh antiguo
        if (parent) {
            parent.remove(mesh);
        }
        
        // Aplicar transformaciones al nuevo modelo
        animatedModel.position.copy(originalPosition);
        animatedModel.rotation.copy(originalRotation);
        animatedModel.scale.copy(originalScale);
        
        // Preservar userData importante
        animatedModel.userData.modelOffset = originalUserData.modelOffset || { x: 0, y: 0, z: 0 };
        animatedModel.userData.modelRotation = originalUserData.modelRotation || { x: 0, y: 0, z: 0 };
        
        // Agregar nuevo modelo a la escena
        if (parent) {
            parent.add(animatedModel);
        }
        
        // Actualizar referencia en Render component
        const render = this.ecs.getComponent(entityId, 'Render');
        if (render) {
            render.setMesh(animatedModel);
        }
        
        // Cargar todas las animaciones
        const animations = {};
        for (const [state, file] of Object.entries(ANIMATION_FILES)) {
            const clips = await this.loadAnimation(file);
            if (clips.length > 0) {
                animations[state] = clips[0];
            }
        }
        
        if (Object.keys(animations).length === 0) {
            this.initializingMixers.delete(entityId);
            return null;
        }
        
        // Crear AnimationMixer con el nuevo modelo que tiene el esqueleto correcto
        const mixer = new THREE.AnimationMixer(animatedModel);
        animatedModel.userData.animationMixer = mixer;
        animatedModel.userData.animationClips = animations;
        animatedModel.userData.currentAction = null;
        
        this.initializingMixers.delete(entityId);
        return mixer;
    } catch (error) {
        this.initializingMixers.delete(entityId);
        return null;
    }
}
```

**Notas:**
- Se reemplaza el mesh original con el modelo del archivo de animación para garantizar compatibilidad de esqueleto
- Se preservan todas las transformaciones y userData importantes
- Se actualiza la referencia en el Render component
- Se cargan todas las animaciones al inicializar

---

### Paso 5: Implementar Reproducción de Animaciones

**Descripción:**
Implementar método para reproducir animaciones según el estado, con sistema de transiciones suaves (fadeOut/fadeIn).

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
playAnimation(mixer, clips, state, mesh) {
    // Si el estado no tiene animación, no hacer nada
    if (!clips[state]) {
        return;
    }
    
    const clip = clips[state];
    const currentAction = mesh.userData.currentAction;
    const currentState = mesh.userData.currentAnimationState;
    
    // Si ya está reproduciendo esta misma animación, no hacer nada
    if (currentAction && currentState === state && currentAction.isRunning()) {
        return;
    }
    
    // combat_stance es la animación base y no debe interrumpir otras animaciones
    if (state === 'combat_stance' && currentAction && currentState !== 'combat_stance' && currentAction.isRunning()) {
        return;
    }
    
    // Detener animación actual si existe y es diferente
    if (currentAction && currentState !== state) {
        currentAction.fadeOut(0.2);
    }
    
    // Crear y reproducir nueva animación
    const action = mixer.clipAction(clip);
    action.reset();
    
    if (state === 'attack') {
        action.setLoop(THREE.LoopOnce);
        action.clampWhenFinished = false;
        mesh.userData.attackAction = action;
        mesh.userData.isAttacking = true;
    } else {
        // Todas las demás animaciones (combat_stance, walk, run) en loop
        action.setLoop(THREE.LoopRepeat);
    }
    
    action.fadeIn(0.2);
    action.play();
    
    // Guardar referencia a la acción y estado actual
    mesh.userData.currentAction = action;
    mesh.userData.currentAnimationState = state;
}
```

**Notas:**
- Las animaciones de ataque se reproducen una vez (LoopOnce)
- Las demás animaciones se reproducen en loop (LoopRepeat)
- Se usa fadeOut/fadeIn para transiciones suaves
- Se guarda el estado actual para evitar llamadas redundantes

---

### Paso 6: Implementar Mapeo de Estados y Actualización

**Descripción:**
Implementar método update que mapea estados del juego a animaciones y las reproduce.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
update(deltaTime) {
    const entities = this.getEntities();
    
    for (const entityId of entities) {
        const render = this.ecs.getComponent(entityId, 'Render');
        const animation = this.ecs.getComponent(entityId, 'Animation');
        
        if (!render || !render.mesh || !animation) continue;
        
        const mesh = render.mesh;
        
        // Guardar referencia a la entidad en el mesh
        mesh.userData.entityId = entityId;
        
        // Inicializar mixer si no existe
        if (!mesh.userData.animationMixer) {
            this.initializeMixer(entityId, mesh).then(() => {
                if (mesh.userData.animationMixer && mesh.userData.animationClips) {
                    this.playAnimation(
                        mesh.userData.animationMixer,
                        mesh.userData.animationClips,
                        animation.currentState,
                        mesh
                    );
                }
            });
            continue;
        }
        
        // Actualizar mixer
        const mixer = mesh.userData.animationMixer;
        mixer.update(deltaTime);
        
        // Verificar si la animación de ataque terminó y transicionar a combat_stance
        if (mesh.userData.attackAction) {
            const attackAction = mesh.userData.attackAction;
            const attackDuration = attackAction.getClip().duration;
            
            // Cuando el ataque esté cerca de terminar (último 15%), iniciar transición a combat_stance
            if (attackAction.isRunning() && attackAction.time >= attackDuration * 0.85) {
                const clips = mesh.userData.animationClips;
                if (clips && clips['combat_stance']) {
                    this.playAnimation(mixer, clips, 'combat_stance', mesh);
                }
            }
            
            // Cuando el ataque termine completamente, limpiar flags y cambiar estado
            if (!attackAction.isRunning() && attackAction.time >= attackDuration) {
                mesh.userData.isAttacking = false;
                mesh.userData.attackAction = null;
                
                const entityId = mesh.userData.entityId;
                if (entityId) {
                    const anim = this.ecs.getComponent(entityId, 'Animation');
                    if (anim) {
                        anim.currentState = 'idle';
                    }
                }
            }
        }
        
        // Reproducir animación según estado
        const clips = mesh.userData.animationClips;
        if (clips) {
            // Mapear estados del juego a estados de animación
            let animationState = animation.currentState;
            
            if (animationState === 'attack' && clips['attack']) {
                animationState = 'attack';
            } else if (animationState === 'run' && clips['run']) {
                animationState = 'run';
            } else if (animationState === 'walk' && clips['walk']) {
                animationState = 'walk';
            } else if (animationState === 'idle' && clips['combat_stance']) {
                animationState = 'combat_stance';
            } else if (clips['combat_stance']) {
                animationState = 'combat_stance';
            }
            
            this.playAnimation(mixer, clips, animationState, mesh);
        }
    }
}
```

**Notas:**
- Se actualiza el mixer cada frame con deltaTime
- Se maneja la transición de ataque a combat_stance automáticamente
- Se mapean los estados del juego a nombres de animaciones

---

### Paso 7: Agregar Soporte para Ataque en AnimationSystem

**Descripción:**
Modificar AnimationSystem para detectar cuando el usuario quiere atacar.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-system.js`
- `frontend/src/ecs/components/animation.js`

**Detalles de implementación:**
```javascript
// animation-system.js - Agregar detección de ataque
if (input.wantsToAttack) {
    animation.currentState = 'attack';
}
// ... resto de estados

// animation.js - Agregar flag para controlar estado de ataque
constructor(options = {}) {
    this.currentState = options.currentState || 'idle';
    this.animationSpeed = options.animationSpeed !== undefined ? options.animationSpeed : 1.0;
    this.isAttacking = false; // Nuevo flag para controlar el estado de ataque
}
```

**Notas:**
- El InputSystem ya detecta wantsToAttack cuando se hace click izquierdo
- El flag isAttacking se usa en AnimationMixerSystem para controlar transiciones

---

### Paso 8: Registrar Sistema en App y Probar

**Descripción:**
Registrar AnimationMixerSystem en la aplicación y probar las animaciones.

**Archivos a modificar:**
- `frontend/src/ecs/systems/index.js`
- `frontend/src/app.js`

**Detalles de implementación:**
```javascript
// frontend/src/ecs/systems/index.js
export { AnimationMixerSystem } from './animation-mixer-system.js';

// frontend/src/app.js
import { AnimationMixerSystem } from './ecs/systems/index.js';

// En constructor
this.animationMixerSystem = new AnimationMixerSystem();

// En setupSystems (o donde se registran sistemas)
this.ecs.registerSystem(this.animationMixerSystem);
```

**Verificación:**
1. Recargar el juego (F5)
2. Caminar con WASD → verificar animación de caminar
3. Correr con Shift + WASD → verificar animación de correr
4. Estar quieto → verificar animación de combat_stance
5. Hacer click izquierdo → verificar animación de ataque
6. Verificar que la transición de ataque a combat_stance es suave
7. Verificar que mantiene 60 FPS (abrir DevTools → Performance)

**Notas:**
- Verificar que las animaciones se cargan correctamente (Network tab)
- Verificar que no hay errores en consola
- Ajustar valores de fadeIn/fadeOut si las transiciones no son suaves

---

### Paso 9: Actualizar Player Factory para Usar Bones

**Descripción:**
Actualizar player-factory.js para usar bones en lugar de vertex groups, ya que las animaciones GLB requieren esqueleto.

**Archivos a modificar:**
- `frontend/src/ecs/factories/player-factory.js`

**Detalles de implementación:**
```javascript
// Reemplazar imports de vertex groups por bones
import { listBones, mapBonesToBodyParts, hasSkeleton } from '../../renderers/models/bones-utils.js';

// En la función de creación del player, usar bones
if (hasSkeleton(mesh)) {
    const bodyPartsMap = mapBonesToBodyParts(mesh);
    if (Object.keys(bodyPartsMap).length > 0) {
        mesh.userData.bodyPartsMap = bodyPartsMap;
    }
}
```

**Notas:**
- Los bones son más apropiados para animaciones que vertex groups
- El sistema de daño por partes también usa bones

---

### Paso 10: Limpieza y Optimización

**Descripción:**
Limpiar código, eliminar logs temporales y optimizar el sistema.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`
- `frontend/src/renderers/models/model-loader.js`

**Optimizaciones:**
1. Eliminar console.log temporales
2. Eliminar comentarios excesivos
3. Verificar que el cache funciona correctamente
4. Optimizar búsqueda de SkinnedMesh

**Limpieza:**
- Eliminar modelos no utilizados del directorio de characters
- Limpiar código comentado o deprecado

**Notas:**
- Priorizar que las animaciones funcionen correctamente antes de optimizar
- Documentar valores importantes (duraciones, fadeIn/fadeOut)

---

### Paso 11: Documentación y Finalización

**Descripción:**
Documentar el sistema de animaciones y finalizar la implementación.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js` (comentarios JSDoc)
- `frontend/src/renderers/models/README.md` (mencionar bones y animaciones)

**Notas:**
- Documentar cómo agregar nuevas animaciones en el futuro
- Explicar el sistema de cache
- Documentar el mapeo de estados a animaciones

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-015_pr-description_[FECHA-HORA].md` en `/instructions/prs/`
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git

---

## Consideraciones Técnicas

### Performance
- Las animaciones se cachean para evitar recargas
- El mixer se actualiza cada frame con deltaTime
- Solo se inicializa un mixer por entidad
- Se previenen múltiples inicializaciones simultáneas

### Compatibilidad
- El sistema reemplaza el modelo original con el modelo del archivo de animación
- Se preservan todas las transformaciones originales
- Se mantiene compatibilidad con el sistema de bones para daño por partes

### Animaciones
- Las animaciones de Meshy incluyen el modelo completo con esqueleto
- Cada archivo GLB contiene una animación específica
- El modelo en cada archivo debe tener el mismo esqueleto para compatibilidad
- Las animaciones de ataque se reproducen una vez y luego transicionan a combat_stance

### Transiciones
- Se usan fadeOut/fadeIn para transiciones suaves (0.2 segundos)
- La animación de ataque transiciona a combat_stance cuando está cerca de terminar (85% de duración)
- combat_stance no interrumpe otras animaciones activas

## Dependencias

### Nuevas Dependencias
Ninguna (usa Three.js que ya está incluido)

### Variables de Entorno
Ninguna nueva (usa configuración existente)

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/animation-mixer-system.js` - Sistema de animaciones con AnimationMixer (nuevo)
2. `frontend/src/ecs/systems/index.js` - Exportar nuevo sistema
3. `frontend/src/app.js` - Registrar nuevo sistema
4. `frontend/src/ecs/components/animation.js` - Agregado flag isAttacking
5. `frontend/src/ecs/systems/animation-system.js` - Agregada detección de ataque
6. `frontend/src/ecs/factories/player-factory.js` - Actualizado para usar bones
7. `frontend/src/renderers/models/bones-utils.js` - Utilidades para bones (nuevo)
8. `backend/static/models/animations/*.glb` - Archivos de animación (nuevos)

## Testing

### Tests a Realizar
- Verificación manual de animaciones en navegador
- Pruebas de rendimiento (60 FPS)
- Pruebas de transiciones entre estados
- Verificación de carga de animaciones

### Escenarios de Prueba
1. Caminar con WASD → verificar animación de caminar
2. Correr con Shift + WASD → verificar animación de correr
3. Estar quieto → verificar animación de combat_stance
4. Hacer click izquierdo → verificar animación de ataque
5. Verificar transición de ataque a combat_stance es suave
6. Verificar transiciones entre walk/run y combat_stance
7. Verificar que mantiene 60 FPS
8. Verificar que las animaciones se cargan correctamente (Network tab)

## Deployment

### Orden de Deployment
1. Frontend: Requiere rebuild (nuevo archivo JavaScript)
2. Backend: Requiere copiar archivos GLB a `backend/static/models/animations/`
3. Base de datos: No requiere migraciones
4. Verificar que los archivos estáticos se sirven correctamente

### Verificación Post-Deployment
- [ ] Verificar que las animaciones se cargan correctamente
- [ ] Verificar que el personaje muestra animaciones al moverse
- [ ] Verificar que la animación de ataque funciona correctamente
- [ ] Verificar logs de consola para errores
- [ ] Verificar que el modelo mantiene escala y posición correctas

---

**Nota Final:** Este plan refleja la implementación real realizada, que utilizó animaciones pre-renderizadas en formato GLB en lugar de animaciones procedurales como se había planeado inicialmente. El cambio de enfoque fue necesario para lograr mayor calidad y naturalidad en las animaciones.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
