# JDG-016 - Refactorizar Sistema de Animaciones para Escalabilidad

## Descripción de la Tarea

Refactorizar el sistema de animaciones para hacerlo escalable, utilizando una arquitectura basada en máquina de estados finita (FSM) con configuración declarativa. Esto permite agregar nuevas acciones de animación solo modificando configuración, sin tocar código.

**Comportamiento actual:**
- `AnimationSystem` utiliza cadenas de `if/else` hardcodeadas con prioridades fijas
- `AnimationMixerSystem` tiene mapeo manual de estados a animaciones
- Cada nueva acción requiere modificar múltiples archivos
- Prioridades y condiciones están acopladas al código

**Comportamiento esperado:**
- Sistema de configuración declarativo para estados, prioridades y condiciones
- Agregar nuevas acciones solo requiere modificar un archivo de configuración
- Prioridades dinámicas ordenadas automáticamente
- Separación clara entre lógica y configuración

## Criterios de Aceptación

1. ✅ Se puede agregar una nueva acción solo modificando un archivo de configuración
2. ✅ Las prioridades de estados están definidas como números y se ordenan automáticamente
3. ✅ El sistema de estados utiliza una máquina de estados finita (FSM) con configuración declarativa
4. ✅ El mapeo estado → animación está declarado en configuración, no hardcodeado
5. ✅ Agregar un nuevo estado requiere cambios mínimos (< 5 líneas) en código existente
6. ✅ Cambiar prioridades entre estados existentes solo requiere modificar configuración
7. ✅ El sistema mantiene compatibilidad con las animaciones y estados actuales
8. ✅ Las transiciones entre estados son explícitas y configurables
9. ✅ El código es más testeable (condiciones y prioridades independientes)
10. ✅ La documentación explica cómo agregar nuevas acciones y estados

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js) - Sistema ECS de animaciones
- [ ] Backend (FastAPI)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (AnimationMixer, AnimationAction)
- ECS (Entity Component System)
- Patrones de diseño: State Machine, Configuration, Strategy, Registry, Factory

## Pasos de Implementación

### Paso 1: Crear Estructura de Configuración

**Descripción:**
Crear el archivo de configuración declarativa que define estados, prioridades, condiciones y animaciones.

**Archivos a crear:**
- `frontend/src/ecs/animation/config/animation-config.js`

**Detalles de implementación:**
```javascript
// Configuración de estados con prioridades, condiciones y animaciones
export const ANIMATION_STATES = [
    {
        id: 'attack',
        priority: 10,
        conditions: [
            { type: 'input', property: 'wantsToAttack', operator: 'equals', value: true }
        ],
        animation: 'attack',
        canInterrupt: true,
        transitions: ['combat_stance']
    },
    // ... más estados
];

// Mapeo de estados a archivos GLB
export const ANIMATION_FILES = {
    'walk': 'animations/Animation_Walking_withSkin.glb',
    // ... más animaciones
};
```

**Notas:**
- La configuración separa datos de lógica
- Prioridades se ordenan automáticamente (mayor = más prioridad)
- Cada estado puede tener múltiples condiciones (AND lógico)

---

### Paso 2: Crear Sistema de Condiciones

**Descripción:**
Implementar clases base y especializadas para evaluar condiciones de activación de estados.

**Archivos a crear:**
- `frontend/src/ecs/animation/conditions/base-condition.js`
- `frontend/src/ecs/animation/conditions/input-condition.js`
- `frontend/src/ecs/animation/conditions/physics-condition.js`
- `frontend/src/ecs/animation/conditions/movement-condition.js`
- `frontend/src/ecs/animation/conditions/condition-factory.js`
- `frontend/src/ecs/animation/conditions/index.js`

**Detalles de implementación:**
```javascript
// base-condition.js - Clase base abstracta
export class BaseCondition {
    constructor(config) {
        this.config = config;
    }
    evaluate(context) {
        throw new Error('Must be implemented by subclass');
    }
}

// input-condition.js - Evalúa InputComponent
export class InputCondition extends BaseCondition {
    evaluate(context) {
        const { input } = context;
        const { property, operator, value } = this.config;
        // Evaluar según operador (equals, greaterThan, etc.)
    }
}

// condition-factory.js - Factory para crear condiciones
export class ConditionFactory {
    static create(conditionConfig) {
        switch (conditionConfig.type) {
            case 'input': return new InputCondition(conditionConfig);
            case 'physics': return new PhysicsCondition(conditionConfig);
            case 'movement': return new MovementCondition(conditionConfig);
        }
    }
}
```

**Notas:**
- Cada tipo de condición implementa su propia lógica de evaluación
- El factory desacopla la creación de condiciones de su uso
- Fácil agregar nuevos tipos de condiciones en el futuro

---

### Paso 3: Crear Sistema de Estados y Registry

**Descripción:**
Implementar el sistema de estados con registry que gestiona y determina el estado activo.

**Archivos a crear:**
- `frontend/src/ecs/animation/states/state-config.js`
- `frontend/src/ecs/animation/states/state-registry.js`
- `frontend/src/ecs/animation/states/index.js`

**Detalles de implementación:**
```javascript
// state-config.js - Configuración de un estado individual
export class StateConfig {
    constructor(config) {
        this.id = config.id;
        this.priority = config.priority;
        this.conditions = config.conditions || [];
        this.animation = config.animation;
        this.canInterrupt = config.canInterrupt || false;
        this.transitions = config.transitions || [];
    }
    
    canActivate(context, conditions) {
        if (this.conditions.length === 0) return true;
        return conditions.every(condition => condition.evaluate(context));
    }
}

// state-registry.js - Registry que gestiona todos los estados
export class StateRegistry {
    constructor(statesConfig) {
        this.states = new Map();
        this.conditionsCache = new Map();
        
        // Ordenar por prioridad (mayor a menor)
        const sortedStates = [...statesConfig].sort((a, b) => b.priority - a.priority);
        
        for (const stateConfig of sortedStates) {
            const state = new StateConfig(stateConfig);
            const conditions = ConditionFactory.createAll(stateConfig.conditions);
            this.conditionsCache.set(state.id, conditions);
            this.states.set(state.id, state);
        }
        
        this.priorityOrder = sortedStates.map(s => s.id);
    }
    
    determineActiveState(context) {
        // Iterar estados en orden de prioridad
        for (const stateId of this.priorityOrder) {
            const state = this.states.get(stateId);
            const conditions = this.getConditions(stateId);
            if (state.canActivate(context, conditions)) {
                return state;
            }
        }
        return this.states.get('idle') || null;
    }
}
```

**Notas:**
- El registry cachea condiciones para mejor performance
- Estados se ordenan automáticamente por prioridad
- Primero estado que cumpla condiciones se activa

---

### Paso 4: Crear AnimationStateSystem

**Descripción:**
Crear el nuevo sistema ECS que reemplaza al `AnimationSystem` antiguo, usando la máquina de estados.

**Archivos a crear:**
- `frontend/src/ecs/systems/animation-state-system.js`
- `frontend/src/ecs/animation/index.js` (exports)

**Detalles de implementación:**
```javascript
// animation-state-system.js
export class AnimationStateSystem extends System {
    constructor() {
        super();
        this.requiredComponents = ['Animation', 'Input', 'Physics'];
        this.priority = 2;
        
        this.stateRegistry = new StateRegistry(ANIMATION_STATES);
    }
    
    update(_deltaTime) {
        const entities = this.getEntities();
        
        for (const entityId of entities) {
            const animation = this.ecs.getComponent(entityId, 'Animation');
            const input = this.ecs.getComponent(entityId, 'Input');
            const physics = this.ecs.getComponent(entityId, 'Physics');
            
            if (!animation || !input || !physics) continue;
            
            const context = { input, physics };
            const activeState = this.stateRegistry.determineActiveState(context);
            
            if (activeState) {
                animation.currentState = activeState.id;
            }
        }
    }
}
```

**Notas:**
- Reemplaza completamente al `AnimationSystem` antiguo
- No necesita `deltaTime` ya que solo evalúa condiciones actuales
- Mantiene misma interfaz pública para compatibilidad

---

### Paso 5: Refactorizar AnimationMixerSystem para Usar Configuración

**Descripción:**
Modificar `AnimationMixerSystem` para usar la configuración declarativa en lugar de mapeos hardcodeados.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// Importar configuración
import { ANIMATION_FILES, ANIMATION_STATES } from '../animation/config/animation-config.js';

export class AnimationMixerSystem extends System {
    constructor() {
        super();
        // ...
        
        // Crear mapa de estado → nombre de animación desde configuración
        this.stateToAnimationMap = new Map();
        for (const stateConfig of ANIMATION_STATES) {
            this.stateToAnimationMap.set(stateConfig.id, stateConfig.animation);
        }
    }
    
    getAnimationNameForState(stateId) {
        const animationName = this.stateToAnimationMap.get(stateId);
        if (animationName) return animationName;
        
        // Fallback automático
        if (ANIMATION_FILES[stateId]) return stateId;
        return 'combat_stance';
    }
}
```

**Notas:**
- Elimina mapeos hardcodeados
- Usa configuración centralizada
- Mantiene fallback automático para estados sin animación

---

### Paso 6: Integrar en app.js y Eliminar Sistema Antiguo

**Descripción:**
Registrar el nuevo sistema en la aplicación y eliminar referencias al sistema antiguo.

**Archivos a modificar:**
- `frontend/src/app.js`
- `frontend/src/ecs/systems/index.js`

**Detalles de implementación:**
```javascript
// app.js
import { AnimationStateSystem, AnimationMixerSystem } from './ecs/systems/index.js';

// En constructor
this.animationStateSystem = new AnimationStateSystem();
this.animationMixerSystem = new AnimationMixerSystem();

// Registrar sistemas
this.ecs.registerSystem(this.animationStateSystem);
this.ecs.registerSystem(this.animationMixerSystem);
```

**Archivos a eliminar:**
- `frontend/src/ecs/systems/animation-system.js` (sistema antiguo eliminado)

**Notas:**
- El sistema antiguo ya no se usa, se eliminó completamente
- Nuevo sistema funciona de forma independiente

---

### Paso 7: Renombrar Sistemas para Consistencia

**Descripción:**
Renombrar sistemas para mantener consistencia en nomenclatura (todos terminan en "System").

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-state-machine.js` → `animation-state-system.js`
- Renombrar clase: `AnimationStateMachine` → `AnimationStateSystem`
- Actualizar todos los imports y referencias

**Detalles de implementación:**
```javascript
// Renombrar archivo y clase para consistencia con otros sistemas
// InputSystem, PhysicsSystem, AnimationStateSystem, AnimationMixerSystem, etc.
```

**Notas:**
- Mantiene consistencia con convención de nombres de sistemas ECS
- Todos los sistemas terminan en "System"

---

### Paso 8: Actualizar Documentación

**Descripción:**
Crear y actualizar READMEs para documentar el nuevo sistema de animaciones.

**Archivos a crear:**
- `frontend/src/ecs/animation/README.md`

**Archivos a modificar:**
- `frontend/src/ecs/README.md`

**Detalles de implementación:**
- Documentar estructura del módulo `animation/`
- Explicar cómo funcionan las condiciones y operadores
- Ejemplos de cómo agregar nuevos estados
- Referencias cruzadas entre módulos

**Notas:**
- **⚠️ READMEs:** Se creó README completo para `ecs/animation/` explicando todo el sistema
- Se actualizó `ecs/README.md` para reflejar cambios en sistemas

---

### Paso 9: Limpiar Código y Referencias

**Descripción:**
Eliminar código no usado, limpiar comentarios obsoletos y actualizar referencias en documentación.

**Archivos a modificar:**
- Eliminar `AnimationSystem` antiguo
- Actualizar comentarios en código
- Limpiar imports no usados
- Actualizar referencias en archivos de instrucciones

**Detalles de implementación:**
- Verificar que no queden referencias al sistema antiguo
- Eliminar código muerto
- Actualizar nombres en análisis y tickets

**Notas:**
- Se eliminaron todas las referencias a `AnimationSystem` antiguo
- Se actualizaron análisis y tickets con nombres correctos

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-016_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- El nuevo sistema mantiene el mismo rendimiento que el anterior
- Condiciones se cachean en `StateRegistry` para evitar recreación
- Evaluación de estados es O(n) donde n es número de estados (normalmente < 10)
- Prioridades ordenadas una vez al inicializar, no cada frame

### Seguridad
- Validación de configuración en tiempo de ejecución
- Fallback automático para estados sin animación definida
- Manejo de errores si condiciones o estados son inválidos

### Casos Edge
- Estados sin condiciones (estado por defecto - idle)
- Múltiples estados con misma prioridad (se evalúa primero en orden de configuración)
- Animación faltante para un estado (fallback a combat_stance)
- Transiciones entre animaciones (manejado por AnimationMixerSystem con fadeIn/fadeOut)

### Compatibilidad
- Mantiene compatibilidad total con `AnimationComponent` existente
- Misma interfaz pública (`currentState` se actualiza igual)
- No requiere cambios en otros sistemas
- `AnimationMixerSystem` sigue funcionando igual, solo cambia de dónde lee la configuración

## Patrones de Código Usados

### Frontend (JavaScript ES6+)
- **State Machine Pattern**: Para gestionar estados de animación
- **Configuration Pattern**: Separación de datos (config) de lógica (evaluación)
- **Strategy Pattern**: Diferentes tipos de condiciones (InputCondition, PhysicsCondition, etc.)
- **Registry Pattern**: StateRegistry centraliza gestión de estados
- **Factory Pattern**: ConditionFactory crea condiciones desde configuración
- **Clases ES6**: Organización modular y clara
- **Map/Set**: Para estructuras de datos eficientes

## Dependencias

### Dependencias Existentes (sin cambios)
- Three.js (AnimationMixer, AnimationAction)
- Sistema ECS existente

### Nuevas Dependencias
Ninguna - todo implementado con código nativo JavaScript

### Variables de Entorno
Ninguna nueva

## Archivos Principales Involucrados

### Archivos Creados
1. `frontend/src/ecs/animation/config/animation-config.js` - Configuración declarativa
2. `frontend/src/ecs/animation/conditions/base-condition.js` - Clase base para condiciones
3. `frontend/src/ecs/animation/conditions/input-condition.js` - Condiciones de input
4. `frontend/src/ecs/animation/conditions/physics-condition.js` - Condiciones de física
5. `frontend/src/ecs/animation/conditions/movement-condition.js` - Condiciones de movimiento
6. `frontend/src/ecs/animation/conditions/condition-factory.js` - Factory de condiciones
7. `frontend/src/ecs/animation/conditions/index.js` - Exports de condiciones
8. `frontend/src/ecs/animation/states/state-config.js` - Configuración de estado individual
9. `frontend/src/ecs/animation/states/state-registry.js` - Registry de estados
10. `frontend/src/ecs/animation/states/index.js` - Exports de estados
11. `frontend/src/ecs/animation/index.js` - Exports principales
12. `frontend/src/ecs/systems/animation-state-system.js` - Nuevo sistema de estados
13. `frontend/src/ecs/animation/README.md` - Documentación del módulo

### Archivos Modificados
1. `frontend/src/ecs/systems/animation-mixer-system.js` - Refactorizado para usar configuración
2. `frontend/src/app.js` - Integra nuevo sistema, elimina referencia al antiguo
3. `frontend/src/ecs/systems/index.js` - Actualiza exports
4. `frontend/src/ecs/README.md` - Actualiza documentación

### Archivos Eliminados
1. `frontend/src/ecs/systems/animation-system.js` - Sistema antiguo eliminado

## Testing

### Testing Manual Realizado
1. ✅ Todas las animaciones existentes funcionan correctamente (idle, walk, run, attack)
2. ✅ Transiciones entre estados son suaves
3. ✅ Prioridades funcionan correctamente (attack > jump > run > walk > idle)
4. ✅ Condiciones se evalúan correctamente (input, physics, movement)
5. ✅ Fallback automático funciona (estados sin animación usan combat_stance)
6. ✅ Sistema mantiene mismo rendimiento que anterior

### Escenarios de Prueba
1. **Agregar nueva acción**: ✅ Se puede agregar `block` solo modificando `animation-config.js`
2. **Cambiar prioridades**: ✅ Cambiar prioridad entre estados solo requiere modificar configuración
3. **Estado sin animación**: ✅ Estados sin animación definida usan fallback automático
4. **Compatibilidad**: ✅ Todas las animaciones actuales siguen funcionando
5. **Transiciones**: ✅ Transiciones entre estados son suaves y correctas

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos (solo JavaScript, sin cambios en HTML/CSS)
2. Verificar en ambiente local
3. No requiere cambios en backend o base de datos

### Verificación Post-Deployment
- ✅ Verificar que todas las animaciones funcionan en navegador
- ✅ Verificar transiciones suaves entre estados
- ✅ Verificar que agregar nuevo estado solo requiere modificar configuración
- ✅ Verificar rendimiento (no debe ser más lento que antes)

---

**Nota Final:** Este plan documenta la implementación completa del sistema escalable de animaciones. Todos los pasos fueron completados exitosamente. El sistema ahora permite agregar nuevas acciones solo modificando configuración, sin tocar código.

**⚠️ IMPORTANTE:** El último paso del plan debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc` para documentar todos los cambios en Git.

