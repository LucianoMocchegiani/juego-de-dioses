# JDG-020 - Animaciones en Loop No Se Detienen al Soltar Tecla de Movimiento

## Descripción de la Tarea

Corregir el bug donde las animaciones en loop (como caminar) no se detienen cuando el jugador suelta la tecla de movimiento. Actualmente, cuando el jugador presiona 'W' para caminar y luego suelta la tecla, el personaje deja de moverse físicamente pero la animación de caminar continúa reproduciéndose indefinidamente.

**Comportamiento actual:**
1. Jugador presiona 'W' → animación de caminar inicia y personaje se mueve ✓
2. Jugador suelta 'W' → personaje deja de moverse físicamente ✓
3. **PROBLEMA:** Animación de caminar continúa en loop indefinidamente ✗

**Comportamiento esperado:**
1. Jugador presiona 'W' → animación de caminar inicia y personaje se mueve ✓
2. Jugador suelta 'W' → personaje deja de moverse físicamente ✓
3. Animación de caminar se detiene y transiciona a 'idle' (combat_stance) inmediatamente ✓
4. Personaje visualmente refleja su estado real (quieto cuando no hay input) ✓

## Criterios de Aceptación

1. ❌ Cuando el jugador suelta todas las teclas de movimiento, la animación actual se detiene y transiciona a 'idle'
2. ❌ La transición entre animaciones es suave (fadeOut/fadeIn)
3. ❌ El estado visual del personaje siempre refleja su estado real
4. ❌ Las animaciones en loop se detienen correctamente cuando cambia el estado
5. ❌ No se producen animaciones "fantasma"
6. ❌ El comportamiento funciona para todas las animaciones en loop

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js (AnimationMixer, AnimationAction)
- ECS (Entity Component System): AnimationStateSystem, AnimationMixerSystem
- Sistema de estados de animación basado en configuración declarativa

## Pasos de Implementación

### Paso 1: Analizar el Problema en playAnimation()

**Descripción:**
Revisar y entender el problema en el método `playAnimation()` de `AnimationMixerSystem`. El problema está en la línea 212 donde se verifica si la animación ya está corriendo, pero no se verifica si el ESTADO cambió.

**Archivos a revisar:**
- `frontend/src/ecs/systems/animation-mixer-system.js` (líneas 201-251)

**Detalles de implementación:**
El código actual tiene esta lógica problemática:
```javascript
// Si ya está reproduciendo esta misma animación, no hacer nada
if (currentAction && currentState === state && currentAction.isRunning()) {
    return;
}
```

El problema es que cuando el estado cambia de 'walk' a 'idle', `currentState` es 'walk' pero `state` es 'combat_stance' (idle). Sin embargo, la verificación puede no estar capturando todos los casos correctamente.

**Notas:**
- Revisar cómo se guarda `currentState` en `mesh.userData.currentAnimationState`
- Verificar que el estado se está actualizando correctamente cuando cambia en el componente
- Entender el flujo completo: AnimationStateSystem → AnimationMixerSystem

---

### Paso 2: Corregir la Lógica de playAnimation()

**Descripción:**
Modificar el método `playAnimation()` para que siempre verifique si el estado cambió, y si cambió, detenga la animación anterior y inicie la nueva, incluso si la animación anterior estaba en loop.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
playAnimation(mixer, clips, state, mesh) {
    // Si el estado no tiene animación, no hacer nada
    if (!clips[state]) {
        return;
    }
    
    const clip = clips[state];
    const currentAction = mesh.userData.currentAction;
    const currentState = mesh.userData.currentAnimationState;
    
    // NUEVA LÓGICA: Verificar si el estado cambió
    // Si el estado cambió, SIEMPRE hacer la transición, incluso si la animación anterior está corriendo
    const stateChanged = currentState !== state;
    
    // Si ya está reproduciendo esta misma animación Y el estado no cambió, no hacer nada
    if (currentAction && !stateChanged && currentAction.isRunning()) {
        return;
    }
    
    // Si el estado cambió, detener animación actual (excepto casos especiales)
    if (stateChanged && currentAction) {
        // Manejar casos especiales:
        // - Si estamos en ataque y el nuevo estado es combat_stance, hacer fadeOut suave
        // - Si el nuevo estado es attack, permitir interrumpir (depende de canInterrupt)
        // - Para walk/run/idle, siempre permitir transición
        
        if (currentState === 'attack' && state === 'combat_stance') {
            // Ya manejado más abajo, pero mantener la lógica existente
            currentAction.fadeOut(0.2);
        } else if (state === 'combat_stance' && currentState !== 'combat_stance' && currentAction.isRunning()) {
            // Si se transiciona a combat_stance desde otra animación, hacer fadeOut suave
            currentAction.fadeOut(0.2);
        } else if (currentState !== 'attack' || state === 'attack') {
            // Para todas las demás transiciones (incluyendo walk→idle, run→idle), hacer fadeOut
            currentAction.fadeOut(0.2);
        }
    }
    
    // Crear y reproducir nueva animación
    const action = mixer.clipAction(clip);
    action.reset();
    
    if (state === 'attack') {
        action.setLoop(THREE.LoopOnce);
        action.clampWhenFinished = false;
        mesh.userData.attackAction = action;
        mesh.userData.isAttacking = true;
    } else {
        // Todas las demás animaciones (combat_stance, walk, run) en loop
        action.setLoop(THREE.LoopRepeat);
    }
    
    action.fadeIn(0.2);
    action.play();
    
    // Guardar referencia a la acción y estado actual
    mesh.userData.currentAction = action;
    mesh.userData.currentAnimationState = state;
}
```

**Notas:**
- La clave es verificar `stateChanged` ANTES de decidir si hacer return
- Asegurar que siempre se actualice `mesh.userData.currentAnimationState` cuando cambia el estado
- Mantener la lógica especial para 'attack' y 'combat_stance'

---

### Paso 3: Verificar Actualización de Estado en update()

**Descripción:**
Asegurar que el método `update()` de `AnimationMixerSystem` siempre llama a `playAnimation()` cuando el estado del componente cambia, incluso si la animación anterior estaba corriendo.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js` (método `update()`, líneas 257-335)

**Detalles de implementación:**
Verificar que en el método `update()`, la llamada a `playAnimation()` siempre use el estado actual del componente `Animation`, no el estado guardado en `mesh.userData.currentAnimationState`.

El código actual (líneas 320-333) ya hace esto correctamente:
```javascript
// Reproducir animación según estado
const clips = mesh.userData.animationClips;
if (clips) {
    // Obtener nombre de animación desde configuración
    const animationName = this.getAnimationNameForState(animation.currentState);
    
    // Si la animación existe en los clips cargados, reproducirla
    if (animationName && clips[animationName]) {
        this.playAnimation(mixer, clips, animationName, mesh);
    } else if (clips['combat_stance']) {
        // Fallback: usar combat_stance si no hay animación específica
        this.playAnimation(mixer, clips, 'combat_stance', mesh);
    }
}
```

Sin embargo, necesitamos asegurar que `playAnimation()` siempre detecte el cambio de estado. El cambio principal debe estar en `playAnimation()`.

**Notas:**
- El método `update()` ya está usando `animation.currentState` que es el estado actual del componente
- La corrección en `playAnimation()` debería ser suficiente

---

### Paso 4: Verificar Condición de Movimiento

**Descripción:**
Verificar que `MovementCondition` está evaluando correctamente cuando no hay movimiento (cuando se suelta la tecla).

**Archivos a revisar:**
- `frontend/src/ecs/animation/conditions/movement-condition.js`
- `frontend/src/ecs/systems/input-system.js` (líneas 99-101 donde se resetea moveDirection)

**Detalles de implementación:**
Verificar que cuando se suelta la tecla, `input.moveDirection` se resetea a (0, 0):

```javascript
// En input-system.js, líneas 99-101
if (length > 0.01) {
    input.moveDirection.x /= length;
    input.moveDirection.y /= length;
} else {
    input.moveDirection.x = 0;
    input.moveDirection.y = 0;
}
```

Esto debería funcionar correctamente. La condición `hasMovement` en `MovementCondition` verifica:
```javascript
return input.moveDirection.x !== 0 || input.moveDirection.y !== 0;
```

Cuando `moveDirection` es (0, 0), `hasMovement` retorna `false`, lo que debería hacer que el estado cambie a 'idle'.

**Notas:**
- Verificar que el reset de `moveDirection` funciona correctamente
- Verificar que `AnimationStateSystem` está detectando el cambio correctamente

---

### Paso 5: Probar y Verificar Transiciones

**Descripción:**
Probar manualmente todas las transiciones de animación para asegurar que funcionan correctamente después de los cambios.

**Archivos a probar:**
- N/A (testing manual)

**Detalles de implementación:**
Escenarios de prueba a verificar:

1. **Walk → Idle:**
   - Presionar 'W'
   - Verificar animación de walk
   - Soltar 'W'
   - Verificar que cambia a combat_stance (idle) inmediatamente
   - Verificar transición suave (fadeOut/fadeIn)

2. **Run → Idle:**
   - Presionar 'W' + 'Shift'
   - Verificar animación de run
   - Soltar ambas teclas
   - Verificar que cambia a combat_stance inmediatamente

3. **Walk → Run → Idle:**
   - Presionar 'W' (walk)
   - Presionar 'Shift' (run)
   - Soltar todas las teclas (idle)
   - Verificar todas las transiciones

4. **Attack → Idle:**
   - Hacer click (attack)
   - Esperar que termine
   - Verificar que va a combat_stance
   - Verificar que si se suelta tecla de movimiento durante ataque, no interrumpe

5. **Múltiples cambios rápidos:**
   - Presionar y soltar 'W' rápidamente múltiples veces
   - Verificar que no hay animaciones fantasma
   - Verificar que siempre refleja el estado correcto

**Notas:**
- Probar en el navegador con las herramientas de desarrollo abiertas
- Verificar que no hay errores en la consola
- Verificar que las transiciones son suaves (sin saltos visuales)

---

### Paso 6: Hacer el Sistema Escalable con interruptOnInputRelease

**Descripción:**
Reemplazar la lógica hardcodeada que verifica estados específicos ('walk', 'run') por una solución escalable basada en configuración. Esto permite agregar nuevas animaciones de movimiento continuo (swim, fly, etc.) sin modificar código.

**Archivos a modificar:**
- `frontend/src/ecs/animation/states/state-config.js` - Agregar propiedad `interruptOnInputRelease`
- `frontend/src/ecs/animation/config/animation-config.js` - Agregar `interruptOnInputRelease: true` a walk y run
- `frontend/src/ecs/systems/animation-mixer-system.js` - Usar la propiedad en lugar de hardcodear estados

**Detalles de implementación:**

1. **Agregar propiedad a StateConfig:**
```javascript
// state-config.js
constructor(config) {
    // ... propiedades existentes ...
    
    /**
     * Si es true, esta animación se interrumpe cuando se suelta la tecla/input que la activa.
     * Útil para animaciones de movimiento continuo como walk, run, swim, fly, etc.
     * 
     * @type {boolean}
     * @default false
     */
    this.interruptOnInputRelease = config.interruptOnInputRelease !== undefined 
        ? config.interruptOnInputRelease 
        : false;
}
```

2. **Agregar propiedad a configuración de estados:**
```javascript
// animation-config.js
{
    id: 'walk',
    priority: 4,
    conditions: [
        { type: 'movement', operator: 'hasMovement' }
    ],
    animation: 'walk',
    interruptOnInputRelease: true, // Se interrumpe al soltar tecla
    transitions: ['idle', 'run', 'attack']
},
{
    id: 'run',
    priority: 5,
    conditions: [
        { type: 'input', property: 'isRunning', operator: 'equals', value: true },
        { type: 'movement', operator: 'hasMovement' }
    ],
    animation: 'run',
    interruptOnInputRelease: true, // Se interrumpe al soltar tecla
    transitions: ['idle', 'walk', 'attack']
}
```

3. **Crear mapa de configuraciones en AnimationMixerSystem:**
```javascript
// animation-mixer-system.js - constructor
// Crear mapa de estado → StateConfig para acceder a propiedades de configuración
this.stateConfigMap = new Map();
for (const stateConfigData of ANIMATION_STATES) {
    const stateConfig = new StateConfig(stateConfigData);
    this.stateConfigMap.set(stateConfig.id, stateConfig);
}
```

4. **Reemplazar lógica hardcodeada:**
```javascript
// animation-mixer-system.js - playAnimation()
// ANTES (hardcodeado):
if (currentState === 'walk' || currentState === 'run') {
    // ...
}

// DESPUÉS (escalable):
const currentStateConfig = this.stateConfigMap.get(currentState);
if (currentStateConfig && currentStateConfig.interruptOnInputRelease) {
    // Permitir interrupción
}
```

**Notas:**
- Esta solución permite agregar nuevas animaciones de movimiento continuo (swim, fly, crawl, etc.) solo agregando `interruptOnInputRelease: true` en la configuración
- No se requiere modificar código para nuevas animaciones
- El código queda más limpio y mantenible
- Se mantiene compatibilidad con animaciones existentes (por defecto `interruptOnInputRelease = false`)

**Beneficios:**
- ✅ Escalable: nuevas animaciones solo requieren configuración
- ✅ Declarativo: comportamiento definido en configuración, no en código
- ✅ Mantenible: lógica centralizada en lugar de dispersa
- ✅ Documentado: la propiedad está bien comentada explicando su propósito

---

### Paso 7: Optimizar Transiciones (Opcional)

**Descripción:**
Si es necesario, ajustar los tiempos de fadeOut/fadeIn para transiciones más suaves.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js` (valores de fadeOut/fadeIn)

**Detalles de implementación:**
Si las transiciones son muy bruscas o muy lentas, ajustar los valores de fade:

```javascript
// Actualmente es 0.2 segundos
currentAction.fadeOut(0.2);
action.fadeIn(0.2);

// Podría ajustarse a valores entre 0.15 y 0.3 según se vea mejor
```

**Notas:**
- Solo ajustar si es necesario después de probar
- Considerar que fadeOut/fadeIn muy largos pueden sentirse lentos
- fadeOut/fadeIn muy cortos pueden verse bruscos

---

### Paso 8: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-020_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Las transiciones de animación deben ser eficientes
- Verificar que no se crean múltiples AnimationActions innecesariamente
- Asegurar que se limpian correctamente las animaciones anteriores

### Seguridad
- No aplica directamente (es un cambio en el frontend visual)

### Casos Edge
- **Ataque en progreso:** Si el jugador suelta la tecla durante un ataque, la animación de ataque debe completarse antes de ir a idle
- **Transiciones muy rápidas:** Asegurar que múltiples cambios rápidos de estado no causen flickering
- **Personaje en el aire:** Si el personaje está saltando, debe mantener la animación de jump hasta tocar suelo

### Compatibilidad
- Mantener compatibilidad con el sistema de animaciones existente
- No romper otras transiciones que funcionan correctamente (attack → combat_stance, etc.)

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Usar fadeOut/fadeIn para transiciones suaves
  - Verificar estado antes de crear nuevas AnimationActions
  - Limpiar referencias a animaciones anteriores correctamente

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna - solo cambios en código existente

### Variables de Entorno (si aplica)
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/animation-mixer-system.js` - Corrección principal en método `playAnimation()`
2. `frontend/src/ecs/systems/animation-state-system.js` - Verificar que detecta cambios de estado correctamente (probablemente no requiere cambios)
3. `frontend/src/ecs/animation/conditions/movement-condition.js` - Verificar evaluación de movimiento (probablemente no requiere cambios)

## Testing

### Tests a Crear/Modificar
- Testing manual de transiciones de animación
- Verificar en navegador con herramientas de desarrollo

### Escenarios de Prueba
1. Walk → Idle: Presionar 'W', soltar, verificar cambio a idle
2. Run → Idle: Presionar 'W'+'Shift', soltar, verificar cambio a idle
3. Múltiples cambios rápidos: Verificar que no hay animaciones fantasma
4. Attack → Idle: Verificar que ataque completa antes de ir a idle

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos JavaScript en `frontend/src/ecs/systems/`
2. Verificar en ambiente local que las animaciones funcionan correctamente
3. Rebuild de contenedor frontend si es necesario (si hay cambios en dependencias)

### Verificación Post-Deployment
- [ ] Verificar que al presionar 'W' la animación de walk inicia
- [ ] Verificar que al soltar 'W' la animación cambia a idle inmediatamente
- [ ] Verificar que las transiciones son suaves (sin saltos visuales)
- [ ] Verificar que no hay errores en la consola del navegador
- [ ] Verificar que otras animaciones (attack, run) siguen funcionando correctamente

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

