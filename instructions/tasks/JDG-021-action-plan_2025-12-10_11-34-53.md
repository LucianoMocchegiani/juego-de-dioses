# JDG-021 - Integración de Animaciones Avanzadas y Sistema de Combate con Combos

## Descripción de la Tarea

Implementar un sistema de combate avanzado que integre las 42 animaciones disponibles, incluyendo sistema de combos (clicks consecutivos), combinaciones de teclas, y preparación para sistema de armamentos futuro. El sistema debe ser escalable y fácil de extender.

**Comportamiento actual:**
- Solo 4 animaciones básicas en uso (walk, run, combat_stance, left_slash)
- Un solo tipo de ataque disponible
- No hay sistema de combos
- No hay combinaciones de teclas
- 38 animaciones adicionales disponibles pero no integradas

**Comportamiento esperado:**
- Todas las animaciones disponibles integradas y utilizables
- Sistema de combos funcional con clicks consecutivos
- Combinaciones de teclas para ataques especiales (click+shift, click+ctrl, etc.)
- Arquitectura preparada para sistema de armas (aunque no existe aún)
- Animaciones de defensa funcionales (parry, dodge, block)
- Animaciones contextuales automáticas (hit reactions, caídas, etc.)

## Criterios de Aceptación

1. ❌ Todas las 42 animaciones disponibles están registradas en ANIMATION_FILES
2. ❌ Sistema de combos funciona: 2-3 clicks consecutivos ejecutan diferentes ataques en secuencia
3. ❌ Combinaciones de teclas funcionan: Click + Shift = ataque pesado, Click + Ctrl = ataque cargado
4. ❌ Arquitectura preparada para sistema de armas (componente o configuración extensible)
5. ❌ Animaciones de defensa pueden activarse (parry con Q, dodge con E durante movimiento)
6. ❌ Animaciones contextuales se activan automáticamente (hit reaction cuando se recibe daño)
7. ❌ Transiciones entre animaciones son suaves
8. ❌ El sistema es escalable y fácil de extender con nuevas animaciones
9. ❌ No hay regresiones en animaciones existentes

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js (AnimationMixer, AnimationAction)
- ECS (Entity Component System): AnimationStateSystem, AnimationMixerSystem
- Sistema de estados de animación basado en configuración declarativa
- Sistema de input (InputManager, InputComponent)

## Pasos de Implementación

### Paso 1: Crear Estructura de Carpetas y Archivos Base

**Descripción:**
Crear la estructura de carpetas y archivos base para el sistema de combos y combate, siguiendo la arquitectura propuesta.

**Archivos a crear:**
- `frontend/src/ecs/animation/combos/` (nueva carpeta)
- `frontend/src/ecs/animation/combos/README.md` (documentación del módulo)
- `frontend/src/ecs/animation/combos/input-buffer.js`
- `frontend/src/ecs/animation/combos/combo-manager.js`
- `frontend/src/ecs/animation/combos/combo-chain.js`
- `frontend/src/ecs/animation/combos/index.js`
- `frontend/src/ecs/animation/config/combo-config.js`
- `frontend/src/ecs/animation/config/input-combinations-config.js`
- `frontend/src/ecs/animation/config/weapon-animations-config.js`

**Detalles de implementación:**
Crear las carpetas y archivos vacíos con estructura básica. Los detalles de implementación se cubrirán en pasos posteriores.

**Notas:**
- Crear README.md en la carpeta `combos/` explicando qué contiene el módulo
- Usar estructura de carpetas modular y organizada
- Mantener consistencia con estructura existente en `frontend/src/ecs/animation/`

---

### Paso 2: Implementar InputBuffer

**Descripción:**
Implementar la clase `InputBuffer` que almacena inputs recientes con timestamp para permitir detección de combos con ventana temporal.

**Archivos a crear/modificar:**
- `frontend/src/ecs/animation/combos/input-buffer.js`

**Detalles de implementación:**
```javascript
/**
 * Input Buffer - Almacena inputs recientes con timestamp para detección de combos
 */
export class InputBuffer {
    constructor(maxAge = 2000) {
        /**
         * Edad máxima de inputs en milisegundos (por defecto 2 segundos)
         * @type {number}
         */
        this.maxAge = maxAge;
        
        /**
         * Buffer de inputs con timestamp
         * @type {Array<{type: string, timestamp: number}>}
         */
        this.buffer = [];
    }
    
    /**
     * Agregar input al buffer
     * @param {string} inputType - Tipo de input ('click', 'click+shift', etc.)
     * @param {number} timestamp - Timestamp del input (performance.now())
     */
    addInput(inputType, timestamp) {
        this.buffer.push({ type: inputType, timestamp });
        this.cleanOldInputs(timestamp);
    }
    
    /**
     * Obtener inputs recientes dentro de una ventana temporal
     * @param {number} windowMs - Ventana temporal en milisegundos
     * @param {number} currentTime - Tiempo actual (performance.now())
     * @returns {Array<string>} Array de tipos de inputs en orden cronológico
     */
    getRecentInputs(windowMs, currentTime) {
        this.cleanOldInputs(currentTime);
        const cutoff = currentTime - windowMs;
        
        return this.buffer
            .filter(input => input.timestamp >= cutoff)
            .map(input => input.type);
    }
    
    /**
     * Limpiar inputs antiguos del buffer
     * @param {number} currentTime - Tiempo actual
     */
    cleanOldInputs(currentTime) {
        const cutoff = currentTime - this.maxAge;
        this.buffer = this.buffer.filter(input => input.timestamp > cutoff);
    }
    
    /**
     * Limpiar todo el buffer
     */
    clear() {
        this.buffer = [];
    }
    
    /**
     * Obtener el último input
     * @returns {string|null} Tipo del último input o null si está vacío
     */
    getLastInput() {
        if (this.buffer.length === 0) return null;
        return this.buffer[this.buffer.length - 1].type;
    }
    
    /**
     * Obtener el tiempo del último input
     * @returns {number|null} Timestamp del último input o null si está vacío
     */
    getLastInputTime() {
        if (this.buffer.length === 0) return null;
        return this.buffer[this.buffer.length - 1].timestamp;
    }
}
```

**Notas:**
- El buffer debe limpiar automáticamente inputs antiguos para evitar acumulación de memoria
- Los inputs se almacenan con timestamp para permitir ventanas temporales
- Métodos helper para obtener último input y su timestamp

---

### Paso 3: Implementar ComboChain y ComboManager

**Descripción:**
Implementar las clases `ComboChain` (representa una secuencia de combo) y `ComboManager` (gestiona detección y ejecución de combos).

**Archivos a crear/modificar:**
- `frontend/src/ecs/animation/combos/combo-chain.js`
- `frontend/src/ecs/animation/combos/combo-manager.js`

**Detalles de implementación:**

**combo-chain.js:**
```javascript
/**
 * Representa una cadena de combo (secuencia de ataques)
 */
export class ComboChain {
    constructor(config) {
        this.id = config.id;
        this.steps = config.steps;  // Array de {input, animation, timing}
        this.cancelable = config.cancelable !== undefined ? config.cancelable : false;
        this.weaponTypes = config.weaponTypes || ['generic'];
    }
    
    /**
     * Verificar si el combo puede ejecutarse con el tipo de arma dado
     * @param {string|null} weaponType - Tipo de arma o null si no hay arma
     * @returns {boolean}
     */
    canUseWithWeapon(weaponType) {
        if (!weaponType) weaponType = 'generic';
        return this.weaponTypes.includes(weaponType);
    }
    
    /**
     * Obtener el número de pasos del combo
     * @returns {number}
     */
    getStepCount() {
        return this.steps.length;
    }
}
```

**combo-manager.js:**
```javascript
import { ComboChain } from './combo-chain.js';
import { InputBuffer } from './input-buffer.js';

/**
 * Gestiona detección y ejecución de combos
 */
export class ComboManager {
    constructor(comboConfigs) {
        /**
         * Array de cadenas de combo disponibles
         * @type {Array<ComboChain>}
         */
        this.combos = comboConfigs.map(config => new ComboChain(config));
        
        /**
         * Input buffer para almacenar inputs recientes
         * @type {InputBuffer}
         */
        this.inputBuffer = new InputBuffer(2000);
        
        /**
         * Combo actualmente activo
         * @type {ComboChain|null}
         */
        this.activeCombo = null;
        
        /**
         * Paso actual en el combo activo
         * @type {number}
         */
        this.currentStep = 0;
        
        /**
         * Timestamp del último paso completado
         * @type {number}
         */
        this.lastStepTime = 0;
    }
    
    /**
     * Procesar nuevo input y detectar si inicia o continúa un combo
     * @param {string} inputType - Tipo de input
     * @param {number} currentTime - Tiempo actual
     * @param {string|null} weaponType - Tipo de arma equipada
     * @returns {Object|null} Objeto con información del combo detectado o null
     */
    processInput(inputType, currentTime, weaponType = null) {
        // Agregar input al buffer
        this.inputBuffer.addInput(inputType, currentTime);
        
        // Si hay un combo activo, verificar si continúa
        if (this.activeCombo) {
            const nextStep = this.activeCombo.steps[this.currentStep];
            
            // Verificar si el input coincide con el siguiente paso
            if (nextStep && nextStep.input === inputType) {
                // Verificar timing window
                const timeSinceLastStep = currentTime - this.lastStepTime;
                if (timeSinceLastStep <= nextStep.timing) {
                    // Avanzar al siguiente paso
                    this.currentStep++;
                    this.lastStepTime = currentTime;
                    
                    // Si es el último paso, combo completado
                    if (this.currentStep >= this.activeCombo.steps.length) {
                        const result = {
                            comboId: this.activeCombo.id,
                            step: this.currentStep - 1,
                            animation: nextStep.animation,
                            isComplete: true
                        };
                        this.resetCombo();
                        return result;
                    } else {
                        // Combo continúa
                        return {
                            comboId: this.activeCombo.id,
                            step: this.currentStep - 1,
                            animation: nextStep.animation,
                            isComplete: false
                        };
                    }
                } else {
                    // Timing window expirado, resetear combo
                    this.resetCombo();
                }
            } else {
                // Input no coincide, resetear combo
                this.resetCombo();
            }
        }
        
        // Intentar detectar nuevo combo
        const detectedCombo = this.detectCombo(inputType, currentTime, weaponType);
        if (detectedCombo) {
            this.startCombo(detectedCombo, currentTime);
            const firstStep = detectedCombo.steps[0];
            return {
                comboId: detectedCombo.id,
                step: 0,
                animation: firstStep.animation,
                isComplete: false
            };
        }
        
        return null;
    }
    
    /**
     * Detectar si un input inicia algún combo disponible
     * @param {string} inputType - Tipo de input
     * @param {number} currentTime - Tiempo actual
     * @param {string|null} weaponType - Tipo de arma equipada
     * @returns {ComboChain|null}
     */
    detectCombo(inputType, currentTime, weaponType) {
        // Buscar combos que empiecen con este input y sean compatibles con el arma
        for (const combo of this.combos) {
            if (!combo.canUseWithWeapon(weaponType)) continue;
            
            const firstStep = combo.steps[0];
            if (firstStep && firstStep.input === inputType) {
                return combo;
            }
        }
        return null;
    }
    
    /**
     * Iniciar un combo
     * @param {ComboChain} combo - Combo a iniciar
     * @param {number} currentTime - Tiempo actual
     */
    startCombo(combo, currentTime) {
        this.activeCombo = combo;
        this.currentStep = 1;  // Ya procesamos el primer paso
        this.lastStepTime = currentTime;
    }
    
    /**
     * Resetear combo activo
     */
    resetCombo() {
        this.activeCombo = null;
        this.currentStep = 0;
        this.lastStepTime = 0;
    }
    
    /**
     * Verificar si hay un combo activo
     * @returns {boolean}
     */
    hasActiveCombo() {
        return this.activeCombo !== null;
    }
    
    /**
     * Cancelar combo activo (por ejemplo, si se recibe daño)
     */
    cancelCombo() {
        this.resetCombo();
    }
}
```

**Notas:**
- El ComboManager detecta combos comparando inputs recientes con las secuencias configuradas
- Los combos se filtran por tipo de arma (si no hay arma, usa 'generic')
- Timing windows permiten cierta flexibilidad en la ejecución de combos
- El combo se resetea si se interrumpe la secuencia o expira el timing

---

### Paso 4: Crear Configuración de Combos

**Descripción:**
Crear el archivo de configuración de combos con algunos combos básicos para probar el sistema.

**Archivos a crear/modificar:**
- `frontend/src/ecs/animation/config/combo-config.js`

**Detalles de implementación:**
```javascript
/**
 * Configuración de Combos
 * 
 * Define secuencias de ataques que se ejecutan con inputs consecutivos.
 */

export const COMBO_CHAINS = [
    {
        id: 'basic_combo_3hit',
        steps: [
            { input: 'click', animation: 'left_slash', timing: 500 },
            { input: 'click', animation: 'attack', timing: 400 },
            { input: 'click', animation: 'double_blade_spin', timing: 600 }
        ],
        cancelable: false,
        weaponTypes: ['sword', 'generic']
    },
    {
        id: 'basic_combo_2hit',
        steps: [
            { input: 'click', animation: 'left_slash', timing: 500 },
            { input: 'click', animation: 'attack', timing: 400 }
        ],
        cancelable: false,
        weaponTypes: ['generic']
    },
    {
        id: 'heavy_combo_2hit',
        steps: [
            { input: 'click+shift', animation: 'charged_slash', timing: 800 },
            { input: 'click+shift', animation: 'charged_upward_slash', timing: 1000 }
        ],
        cancelable: true,
        weaponTypes: ['sword', 'axe']
    }
];
```

**Notas:**
- Empezar con combos simples para validar el sistema
- Los timings son en milisegundos y definen la ventana para el siguiente input
- `weaponTypes` define qué armas pueden usar este combo
- `cancelable` indica si el combo puede cancelarse con otra acción

---

### Paso 5: Crear ComboComponent y ComboSystem

**Descripción:**
Crear el componente ECS `ComboComponent` para almacenar estado de combos y el sistema `ComboSystem` que procesa inputs y gestiona combos.

**Archivos a crear/modificar:**
- `frontend/src/ecs/components/combo.js`
- `frontend/src/ecs/systems/combo-system.js`
- `frontend/src/ecs/components/index.js` (exportar ComboComponent)
- `frontend/src/ecs/systems/index.js` (exportar ComboSystem)

**Detalles de implementación:**

**combo.js:**
```javascript
/**
 * Componente de Combo
 * 
 * Almacena el estado de combos activos para una entidad.
 */
export class ComboComponent {
    constructor() {
        /**
         * ID del combo actualmente activo
         * @type {string|null}
         */
        this.activeComboId = null;
        
        /**
         * Paso actual en el combo
         * @type {number}
         */
        this.comboStep = 0;
        
        /**
         * Timestamp del último input de combo
         * @type {number}
         */
        this.lastComboInputTime = 0;
        
        /**
         * Animación que debe ejecutarse por el combo
         * @type {string|null}
         */
        this.comboAnimation = null;
        
        /**
         * Si el combo actual está completo
         * @type {boolean}
         */
        this.comboComplete = false;
    }
    
    /**
     * Resetear estado del combo
     */
    reset() {
        this.activeComboId = null;
        this.comboStep = 0;
        this.lastComboInputTime = 0;
        this.comboAnimation = null;
        this.comboComplete = false;
    }
}
```

**combo-system.js:**
```javascript
import { System } from '../system.js';
import { ComboManager } from '../../animation/combos/combo-manager.js';
import { COMBO_CHAINS } from '../../animation/config/combo-config.js';

/**
 * Sistema de Combos
 * 
 * Gestiona detección y ejecución de combos basados en inputs del usuario.
 * Se ejecuta antes de InputSystem para procesar inputs y detectar combos.
 */
export class ComboSystem extends System {
    constructor() {
        super();
        this.requiredComponents = ['Input', 'Combo'];
        this.priority = 0.5; // Antes de InputSystem (priority 0)
        
        /**
         * Mapa de entityId -> ComboManager
         * Cada entidad tiene su propio ComboManager
         * @type {Map<number, ComboManager>}
         */
        this.comboManagers = new Map();
    }
    
    /**
     * Obtener o crear ComboManager para una entidad
     * @param {number} entityId - ID de la entidad
     * @returns {ComboManager}
     */
    getComboManager(entityId) {
        if (!this.comboManagers.has(entityId)) {
            const manager = new ComboManager(COMBO_CHAINS);
            this.comboManagers.set(entityId, manager);
        }
        return this.comboManagers.get(entityId);
    }
    
    /**
     * Actualizar sistema de combos
     * @param {number} deltaTime - Tiempo transcurrido desde el último frame
     */
    update(deltaTime) {
        const entities = this.getEntities();
        const currentTime = performance.now();
        
        for (const entityId of entities) {
            const input = this.ecs.getComponent(entityId, 'Input');
            const combo = this.ecs.getComponent(entityId, 'Combo');
            const weapon = this.ecs.getComponent(entityId, 'Weapon'); // Opcional
            
            if (!input || !combo) continue;
            
            // Obtener tipo de arma (si existe)
            const weaponType = weapon ? weapon.weaponType : null;
            
            // Obtener ComboManager para esta entidad
            const comboManager = this.getComboManager(entityId);
            
            // Verificar si hay click reciente
            const keysDown = input.keysDown || new Set();
            const mouseButtonsDown = input.mouseButtonsDown || new Set();
            
            // Determinar tipo de input
            let inputType = null;
            if (mouseButtonsDown.has(0)) { // Click izquierdo
                if (input.isRunning) {
                    inputType = 'click+shift';
                } else if (keysDown.has('ControlLeft') || keysDown.has('ControlRight')) {
                    inputType = 'click+ctrl';
                } else if (keysDown.has('AltLeft') || keysDown.has('AltRight')) {
                    inputType = 'click+alt';
                } else {
                    inputType = 'click';
                }
            }
            
            // Procesar input en el ComboManager
            if (inputType) {
                const comboResult = comboManager.processInput(inputType, currentTime, weaponType);
                
                if (comboResult) {
                    // Actualizar ComboComponent con resultado
                    combo.activeComboId = comboResult.comboId;
                    combo.comboStep = comboResult.step;
                    combo.comboAnimation = comboResult.animation;
                    combo.comboComplete = comboResult.isComplete;
                    combo.lastComboInputTime = currentTime;
                } else if (combo.activeComboId) {
                    // Si había un combo activo pero no se procesó, resetear
                    combo.reset();
                    comboManager.resetCombo();
                }
            } else if (combo.activeComboId) {
                // Verificar si el combo expiró por tiempo
                const timeSinceLastInput = currentTime - combo.lastComboInputTime;
                const comboConfig = COMBO_CHAINS.find(c => c.id === combo.activeComboId);
                
                if (comboConfig && combo.comboStep < comboConfig.steps.length) {
                    const currentStep = comboConfig.steps[combo.comboStep];
                    if (timeSinceLastInput > currentStep.timing * 1.5) {
                        // Combo expirado, resetear
                        combo.reset();
                        comboManager.resetCombo();
                    }
                }
            }
        }
    }
}
```

**Notas:**
- ComboSystem se ejecuta antes de InputSystem para procesar inputs primero
- Cada entidad tiene su propio ComboManager
- El sistema detecta combinaciones de teclas (click+shift, click+ctrl, etc.)
- Si un combo expira por tiempo, se resetea automáticamente

---

### Paso 6: Integrar ComboSystem con AnimationStateSystem

**Descripción:**
Modificar `AnimationStateSystem` para que considere combos activos al determinar el estado de animación.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-state-system.js`
- `frontend/src/ecs/animation/conditions/combo-condition.js` (crear)

**Detalles de implementación:**

**combo-condition.js:**
```javascript
import { BaseCondition } from './base-condition.js';

/**
 * Condición basada en combos activos
 */
export class ComboCondition extends BaseCondition {
    evaluate(context) {
        const { combo } = context;
        if (!combo) return false;
        
        const { operator } = this.config;
        const { value } = this.config;
        
        switch (operator) {
            case 'hasActiveCombo':
                return combo.activeComboId !== null;
            case 'comboIdEquals':
                return combo.activeComboId === value;
            case 'comboStepEquals':
                return combo.comboStep === value;
            case 'comboAnimationEquals':
                return combo.comboAnimation === value;
            default:
                return false;
        }
    }
}
```

**Modificar condition-factory.js:**
```javascript
import { ComboCondition } from './combo-condition.js';

// En el switch de create():
case 'combo':
    return new ComboCondition(conditionConfig);
```

**Modificar animation-state-system.js:**
```javascript
// En update(), agregar combo al context:
const context = {
    input,
    physics,
    combo: this.ecs.getComponent(entityId, 'Combo') // Agregar combo al context
};

// Actualizar requiredComponents:
this.requiredComponents = ['Animation', 'Input', 'Physics', 'Combo'];
```

**Agregar estado de combo en animation-config.js:**
```javascript
{
    id: 'combo_attack',
    priority: 11,  // Mayor que attack normal
    conditions: [
        { type: 'combo', operator: 'hasActiveCombo', value: true },
        { type: 'combo', operator: 'comboAnimationEquals', value: 'combo.animation' }
    ],
    animation: 'combo.animation',  // Se resuelve dinámicamente
    canInterrupt: true,
    transitions: ['combat_stance', 'idle']
}
```

**Notas:**
- La animación del combo se debe resolver dinámicamente desde ComboComponent
- El estado de combo tiene alta prioridad para sobreescribir ataques normales
- Necesitamos una forma de pasar la animación específica del combo al estado

---

### Paso 7: Implementar Resolución Dinámica de Animación de Combo

**Descripción:**
Modificar el sistema para que la animación del combo se resuelva dinámicamente desde ComboComponent en lugar de estar hardcodeada.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-state-system.js`
- `frontend/src/ecs/animation/config/animation-config.js`

**Detalles de implementación:**

**Modificar animation-state-system.js:**
```javascript
// Después de determinar activeState, si es combo_attack, resolver animación:
if (activeState && activeState.id === 'combo_attack') {
    const combo = this.ecs.getComponent(entityId, 'Combo');
    if (combo && combo.comboAnimation) {
        // Usar la animación específica del combo
        animation.currentState = 'combo_attack';
        // Guardar animación específica en el componente Animation (requiere extender)
        animation.comboAnimationName = combo.comboAnimation;
    }
} else {
    animation.currentState = activeState.id;
    animation.comboAnimationName = null;
}
```

**Modificar AnimationComponent:**
```javascript
// Agregar propiedad opcional para animación de combo:
this.comboAnimationName = null;  // Animación específica si está en combo
```

**Modificar AnimationMixerSystem para usar comboAnimationName:**
```javascript
// En update(), antes de obtener animationName:
let animationName = null;
if (animation.comboAnimationName) {
    animationName = animation.comboAnimationName;
} else {
    animationName = this.getAnimationNameForState(animation.currentState);
}
```

**Notas:**
- Esta solución permite que los combos usen diferentes animaciones dinámicamente
- Requiere extender AnimationComponent para almacenar animación de combo específica
- AnimationMixerSystem debe verificar primero si hay animación de combo antes de resolver por estado

---

### Paso 8: Crear Configuración de Combinaciones de Input

**Descripción:**
Crear el archivo de configuración para combinaciones de teclas (click+shift, click+ctrl, etc.) que no son combos sino ataques únicos.

**Archivos a crear/modificar:**
- `frontend/src/ecs/animation/config/input-combinations-config.js`

**Detalles de implementación:**
```javascript
/**
 * Configuración de Combinaciones de Input
 * 
 * Define acciones que se ejecutan con combinaciones de teclas.
 */

export const INPUT_COMBINATIONS = [
    {
        id: 'heavy_attack',
        triggers: ['click', 'shift'],  // Click + Shift
        animation: 'heavy_hammer_swing',
        attackType: 'heavy',
        conditions: {
            weaponType: ['hammer', 'axe', 'generic']
        }
    },
    {
        id: 'charged_attack',
        triggers: ['click', 'ctrl'],   // Click + Ctrl
        animation: 'charged_axe_chop',
        attackType: 'charged',
        chargeTime: 500,  // Tiempo de carga en ms (futuro)
        conditions: {
            weaponType: ['axe', 'generic']
        }
    },
    {
        id: 'special_attack',
        triggers: ['click', 'alt'],    // Click + Alt
        animation: 'sword_judgment',
        attackType: 'special',
        conditions: {
            weaponType: ['sword']
        }
    },
    {
        id: 'parry',
        triggers: ['keyQ'],
        animation: 'sword_parry_backward',
        defenseType: 'parry',
        requiresWeapon: true
    },
    {
        id: 'dodge',
        triggers: ['keyE'],            // Durante movimiento
        animation: 'roll_dodge',
        defenseType: 'dodge',
        conditions: {
            hasMovement: true  // Solo si hay movimiento
        }
    },
    {
        id: 'grab',
        triggers: ['keyF'],            // Agarrar/Interactuar
        animation: 'collect_object',
        actionType: 'grab',
        conditions: {}
    }
];
```

**Notas:**
- Estas son acciones únicas, no combos (aunque pueden iniciar combos)
- Cada combinación puede tener condiciones (tipo de arma, estado del personaje)
- Algunas requieren arma (parry) y otras no (dodge, algunos ataques)

---

### Paso 9: Crear CombatSystem y CombatComponent

**Descripción:**
Crear el sistema que procesa combinaciones de input y determina tipo de ataque/defensa, y el componente que almacena estado de combate.

**Archivos a crear/modificar:**
- `frontend/src/ecs/components/combat.js`
- `frontend/src/ecs/systems/combat-system.js`
- `frontend/src/ecs/components/index.js` (exportar CombatComponent)
- `frontend/src/ecs/systems/index.js` (exportar CombatSystem)

**Detalles de implementación:**

**combat.js:**
```javascript
/**
 * Componente de Combate
 * 
 * Almacena el estado de combate de una entidad (tipo de ataque, defensa, etc.)
 */
export class CombatComponent {
    constructor() {
        /**
         * Si está atacando
         * @type {boolean}
         */
        this.isAttacking = false;
        
        /**
         * Tipo de ataque: 'light', 'heavy', 'charged', 'special', null
         * @type {string|null}
         */
        this.attackType = null;
        
        /**
         * Tipo de defensa: 'parry', 'dodge', 'block', null
         * @type {string|null}
         */
        this.defenseType = null;
        
        /**
         * Si el ataque actual puede cancelarse
         * @type {boolean}
         */
        this.canCancel = false;
        
        /**
         * Animación de ataque/defensa que debe ejecutarse
         * @type {string|null}
         */
        this.combatAnimation = null;
    }
    
    /**
     * Resetear estado de combate
     */
    reset() {
        this.isAttacking = false;
        this.attackType = null;
        this.defenseType = null;
        this.canCancel = false;
        this.combatAnimation = null;
    }
}
```

**combat-system.js:**
```javascript
import { System } from '../system.js';
import { INPUT_COMBINATIONS } from '../../animation/config/input-combinations-config.js';

/**
 * Sistema de Combate
 * 
 * Procesa combinaciones de input y determina tipo de ataque/defensa.
 * Se ejecuta después de InputSystem pero antes de AnimationStateSystem.
 */
export class CombatSystem extends System {
    constructor() {
        super();
        this.requiredComponents = ['Input', 'Combat'];
        this.priority = 1.5; // Después de InputSystem (1), antes de AnimationStateSystem (2)
    }
    
    /**
     * Verificar si una combinación de input está activa
     * @param {Object} combination - Configuración de combinación
     * @param {Object} input - InputComponent
     * @returns {boolean}
     */
    checkCombination(combination, input) {
        const triggers = combination.triggers;
        
        for (const trigger of triggers) {
            if (trigger === 'click') {
                if (!input.mouseButtonsDown || !input.mouseButtonsDown.has(0)) {
                    return false;
                }
            } else if (trigger === 'shift') {
                if (!input.isKeyPressed('ShiftLeft') && !input.isKeyPressed('ShiftRight')) {
                    return false;
                }
            } else if (trigger === 'ctrl') {
                if (!input.isKeyPressed('ControlLeft') && !input.isKeyPressed('ControlRight')) {
                    return false;
                }
            } else if (trigger === 'alt') {
                if (!input.isKeyPressed('AltLeft') && !input.isKeyPressed('AltRight')) {
                    return false;
                }
            } else if (trigger === 'keyE') {
                if (!input.isKeyPressed('KeyE')) {
                    return false;
                }
            } else if (trigger === 'keyF') {
                if (!input.isKeyPressed('KeyF')) {
                    return false;
                }
            } else if (trigger === 'keyQ') {
                if (!input.isKeyPressed('KeyQ')) {
                    return false;
                }
            }
        }
        return true;
    }
    
    /**
     * Verificar condiciones de una combinación
     * @param {Object} combination - Configuración de combinación
     * @param {Object} context - Contexto (input, weapon, etc.)
     * @returns {boolean}
     */
    checkConditions(combination, context) {
        const { conditions } = combination;
        if (!conditions) return true;
        
        // Verificar weaponType
        if (conditions.weaponType) {
            const weaponType = context.weapon ? context.weapon.weaponType : 'generic';
            if (!conditions.weaponType.includes(weaponType)) {
                return false;
            }
        }
        
        // Verificar hasMovement
        if (conditions.hasMovement !== undefined) {
            const hasMovement = context.input.moveDirection.x !== 0 || context.input.moveDirection.y !== 0;
            if (conditions.hasMovement !== hasMovement) {
                return false;
            }
        }
        
        // Verificar requiresWeapon
        if (combination.requiresWeapon && !context.weapon) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Actualizar sistema de combate
     * @param {number} deltaTime - Tiempo transcurrido
     */
    update(deltaTime) {
        const entities = this.getEntities();
        
        for (const entityId of entities) {
            const input = this.ecs.getComponent(entityId, 'Input');
            const combat = this.ecs.getComponent(entityId, 'Combat');
            const weapon = this.ecs.getComponent(entityId, 'Weapon'); // Opcional
            
            if (!input || !combat) continue;
            
            const context = { input, weapon };
            
            // Verificar cada combinación de input
            for (const combination of INPUT_COMBINATIONS) {
                if (this.checkCombination(combination, input) && this.checkConditions(combination, context)) {
                    // Combinación detectada
                    combat.combatAnimation = combination.animation;
                    
                    if (combination.attackType) {
                        combat.isAttacking = true;
                        combat.attackType = combination.attackType;
                        combat.defenseType = null;
                    } else if (combination.defenseType) {
                        combat.defenseType = combination.defenseType;
                        combat.isAttacking = false;
                        combat.attackType = null;
                    }
                    
                    // Salir del loop después de encontrar la primera combinación válida
                    break;
                }
            }
        }
    }
}
```

**Notas:**
- CombatSystem procesa combinaciones de teclas y actualiza CombatComponent
- Las combinaciones se verifican en orden (la primera que coincida se usa)
- Se verifica tipo de arma y otras condiciones antes de aplicar la combinación

---

### Paso 10: Integrar CombatSystem con AnimationStateSystem

**Descripción:**
Modificar `AnimationStateSystem` para considerar `CombatComponent` al determinar estados de animación.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-state-system.js`
- `frontend/src/ecs/animation/conditions/combat-condition.js` (crear)
- `frontend/src/ecs/animation/config/animation-config.js`

**Detalles de implementación:**

**combat-condition.js:**
```javascript
import { BaseCondition } from './base-condition.js';

/**
 * Condición basada en estado de combate
 */
export class CombatCondition extends BaseCondition {
    evaluate(context) {
        const { combat } = context;
        if (!combat) return false;
        
        const { property, operator, value } = this.config;
        
        switch (property) {
            case 'isAttacking':
                return combat.isAttacking === value;
            case 'attackType':
                return operator === 'equals' ? combat.attackType === value : false;
            case 'defenseType':
                return operator === 'equals' ? combat.defenseType === value : false;
            case 'combatAnimation':
                return combat.combatAnimation === value;
            default:
                return false;
        }
    }
}
```

**Agregar al condition-factory.js:**
```javascript
case 'combat':
    return new CombatCondition(conditionConfig);
```

**Modificar animation-state-system.js:**
```javascript
// Agregar combat al context:
const context = {
    input,
    physics,
    combo: this.ecs.getComponent(entityId, 'Combo'),
    combat: this.ecs.getComponent(entityId, 'Combat')
};

// Actualizar requiredComponents:
this.requiredComponents = ['Animation', 'Input', 'Physics', 'Combo', 'Combat'];
```

**Agregar estados de combate en animation-config.js:**
```javascript
{
    id: 'heavy_attack',
    priority: 11,
    conditions: [
        { type: 'combat', property: 'attackType', operator: 'equals', value: 'heavy' }
    ],
    animation: 'combat.combatAnimation',  // Se resuelve dinámicamente
    canInterrupt: true,
    transitions: ['combat_stance', 'idle']
},
{
    id: 'charged_attack',
    priority: 11,
    conditions: [
        { type: 'combat', property: 'attackType', operator: 'equals', value: 'charged' }
    ],
    animation: 'combat.combatAnimation',
    canInterrupt: true,
    transitions: ['combat_stance', 'idle']
},
{
    id: 'parry',
    priority: 12,
    conditions: [
        { type: 'combat', property: 'defenseType', operator: 'equals', value: 'parry' }
    ],
    animation: 'combat.combatAnimation',
    canInterrupt: true,
    transitions: ['combat_stance', 'idle']
},
{
    id: 'dodge',
    priority: 12,
    conditions: [
        { type: 'combat', property: 'defenseType', operator: 'equals', value: 'dodge' }
    ],
    animation: 'combat.combatAnimation',
    canInterrupt: true,
    transitions: ['idle', 'walk', 'run']
}
```

**Notas:**
- Similar a combos, las animaciones de combate se resuelven dinámicamente
- Los estados de defensa tienen prioridad alta para sobreescribir otros estados
- Requiere modificar AnimationMixerSystem para resolver animaciones de combat también

---

### Paso 11: Extender AnimationMixerSystem para Resolver Animaciones Dinámicas

**Descripción:**
Modificar `AnimationMixerSystem` para resolver animaciones dinámicas desde ComboComponent y CombatComponent.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// En update(), modificar la lógica de obtener animationName:
const clips = mesh.userData.animationClips;
if (clips) {
    let animationName = null;
    
    // Prioridad 1: Animación de combo (si hay combo activo)
    if (animation.comboAnimationName) {
        animationName = animation.comboAnimationName;
    }
    // Prioridad 2: Animación de combate (si hay acción de combate)
    else {
        const combat = this.ecs.getComponent(entityId, 'Combat');
        if (combat && combat.combatAnimation) {
            animationName = combat.combatAnimation;
        }
        // Prioridad 3: Resolver por estado normal
        else {
            animationName = this.getAnimationNameForState(animation.currentState);
        }
    }
    
    // Si la animación existe en los clips cargados, reproducirla
    if (animationName && clips[animationName]) {
        this.playAnimation(mixer, clips, animationName, mesh);
    } else if (clips['combat_stance']) {
        // Fallback: usar combat_stance si no hay animación específica
        this.playAnimation(mixer, clips, 'combat_stance', mesh);
    }
}
```

**Notas:**
- Las animaciones se resuelven en orden de prioridad: combo > combate > estado normal
- Si la animación no existe en los clips, usa fallback a combat_stance
- Esto permite que combos y combinaciones usen animaciones específicas

---

### Paso 12: Crear WeaponComponent y Configuración de Armas

**Descripción:**
Crear el componente opcional `WeaponComponent` y configuración de animaciones por tipo de arma, preparando para sistema de armas futuro.

**Archivos a crear/modificar:**
- `frontend/src/ecs/components/weapon.js`
- `frontend/src/ecs/animation/config/weapon-animations-config.js`
- `frontend/src/ecs/components/index.js` (exportar WeaponComponent)

**Detalles de implementación:**

**weapon.js:**
```javascript
/**
 * Componente de Arma (Opcional)
 * 
 * Almacena información sobre el arma equipada.
 * Este componente es opcional - el sistema funciona sin él usando animaciones genéricas.
 */
export class WeaponComponent {
    constructor(options = {}) {
        /**
         * Tipo de arma: 'sword', 'axe', 'hammer', 'spear', etc.
         * @type {string}
         */
        this.weaponType = options.weaponType || 'generic';
        
        /**
         * ID del arma específica (para sistema futuro de armas únicas)
         * @type {string|null}
         */
        this.weaponId = options.weaponId || null;
        
        /**
         * Si tiene escudo equipado
         * @type {boolean}
         */
        this.hasShield = options.hasShield || false;
    }
}
```

**weapon-animations-config.js:**
```javascript
/**
 * Configuración de Animaciones por Tipo de Arma
 * 
 * Mapea tipos de armas a animaciones específicas.
 * Si no hay arma equipada o no hay animación específica, se usa 'generic'.
 */

export const WEAPON_ANIMATIONS = {
    'sword': {
        lightAttack: 'left_slash',
        heavyAttack: 'charged_slash',
        specialAttack: 'sword_judgment',
        parry: 'sword_parry_backward',
        walk: 'walking',
        run: 'running'
    },
    'axe': {
        lightAttack: 'attack',
        heavyAttack: 'heavy_hammer_swing',
        chargedAttack: 'charged_axe_chop',
        specialAttack: 'axe_spin_attack',
        walk: 'walking',
        run: 'running'
    },
    'hammer': {
        lightAttack: 'attack',
        heavyAttack: 'heavy_hammer_swing',
        walk: 'walking',
        run: 'running'
    },
    'spear': {
        lightAttack: 'attack',
        walk: 'spear_walk',
        run: 'running'
    },
    'generic': {
        lightAttack: 'left_slash',
        heavyAttack: 'attack',
        walk: 'walking',
        run: 'running'
    }
};
```

**Notas:**
- WeaponComponent es opcional - el sistema debe funcionar sin él
- 'generic' es el fallback cuando no hay arma o no hay animación específica
- Por ahora es solo estructura - se usará cuando se implemente sistema de armas

---

### Paso 13: Integrar Todas las Animaciones en ANIMATION_FILES

**Descripción:**
Registrar todas las 42 animaciones disponibles en `ANIMATION_FILES` y crear estados correspondientes en `ANIMATION_STATES`.

**Archivos a modificar:**
- `frontend/src/ecs/animation/config/animation-config.js`

**Detalles de implementación:**
```javascript
export const ANIMATION_FILES = {
    // Ataques
    'left_slash': 'animations/Animation_Left_Slash_withSkin.glb',
    'attack': 'animations/Animation_Attack_withSkin.glb',
    'heavy_hammer_swing': 'animations/Animation_Heavy_Hammer_Swing_withSkin.glb',
    'axe_spin_attack': 'animations/Animation_Axe_Spin_Attack_withSkin.glb',
    'charged_axe_chop': 'animations/Animation_Charged_Axe_Chop_withSkin.glb',
    'charged_upward_slash': 'animations/Animation_Charged_Upward_Slash_withSkin.glb',
    'charged_slash': 'animations/Animation_Charged_Slash_withSkin.glb',
    'double_blade_spin': 'animations/Animation_Double_Blade_Spin_withSkin.glb',
    'sword_judgment': 'animations/Animation_Sword_Judgment_withSkin.glb',
    'simple_kick': 'animations/Animation_Simple_Kick_withSkin.glb',
    
    // Defensa
    'sword_parry_backward': 'animations/Animation_Sword_Parry_Backward_withSkin.glb',
    'shield_push_left': 'animations/Animation_Shield_Push_Left_withSkin.glb',
    'stand_dodge': 'animations/Animation_Stand_Dodge_withSkin.glb',
    'roll_dodge': 'animations/Animation_Roll_Dodge_withSkin.glb',
    
    // Movimiento
    'walking': 'animations/Animation_Walking_withSkin.glb',
    'running': 'animations/Animation_Running_withSkin.glb',
    'run_fast': 'animations/Animation_RunFast_withSkin.glb',
    'regular_jump': 'animations/Animation_Regular_Jump_withSkin.glb',
    'backflip': 'animations/Animation_Backflip_withSkin.glb',
    'dive_down_and_land': 'animations/Animation_Dive_Down_and_Land_2_withSkin.glb',
    'swim_idle': 'animations/Animation_Swim_Idle_withSkin.glb',
    'swimming_to_edge': 'animations/Animation_swimming_to_edge_withSkin.glb',
    'crouch_walk_forward': 'animations/Animation_Cautious_Crouch_Walk_Forward_inplace_withSkin.glb',
    'crouch_walk_right': 'animations/Animation_Cautious_Crouch_Walk_Right_inplace_withSkin.glb',
    'limping_walk': 'animations/Animation_Limping_Walk_inplace_withSkin.glb',
    'stand_up': 'animations/Animation_Stand_Up2_withSkin.glb',
    'spear_walk': 'animations/Animation_Spear_Walk_withSkin.glb',
    
    // Reacciones/Daño
    'hit_reaction': 'animations/Animation_Hit_Reaction_withSkin.glb',
    'hit_reaction_1': 'animations/Animation_Hit_Reaction_1_withSkin.glb',
    'electrocution_reaction': 'animations/Animation_Electrocution_Reaction_withSkin.glb',
    'falling_down': 'animations/Animation_falling_down_withSkin.glb',
    'shot_and_fall_backward': 'animations/Animation_Shot_and_Fall_Backward_withSkin.glb',
    
    // Acciones Especiales
    'collect_object': 'animations/Animation_Collect_Object_withSkin.glb',
    'stand_and_drink': 'animations/Animation_Stand_and_Drink_withSkin.glb',
    'talk_with_hands_open': 'animations/Animation_Talk_with_Hands_Open_withSkin.glb',
    'charged_spell_cast': 'animations/Animation_Charged_Spell_Cast_withSkin.glb',
    'skill_01': 'animations/Animation_Skill_01_withSkin.glb',
    'crouch_charge_and_throw': 'animations/Animation_Crouch_Charge_and_Throw_withSkin.glb',
    'crouch_and_step_back': 'animations/Animation_Crouch_and_Step_Back_withSkin.glb',
    
    // Idle/Stance
    'combat_stance': 'animations/Animation_Combat_Stance_withSkin.glb',
    'idle_11': 'animations/Animation_Idle_11_withSkin.glb'
};

// Agregar estados adicionales en ANIMATION_STATES según necesidad
// (algunos se agregarán en pasos posteriores)
```

**Notas:**
- Mapear todos los archivos GLB a nombres de animación consistentes
- Usar nombres descriptivos y en snake_case
- Mantener compatibilidad con animaciones existentes (walk, run, etc.)

---

### Paso 14: Registrar Sistemas en app.js

**Descripción:**
Registrar los nuevos sistemas (ComboSystem, CombatSystem) en la aplicación y agregar componentes a las entidades que los necesiten.

**Archivos a modificar:**
- `frontend/src/app.js`
- `frontend/src/ecs/factories/player-factory.js` (agregar componentes opcionales)

**Detalles de implementación:**

**app.js:**
```javascript
import { ComboSystem } from './ecs/systems/combo-system.js';
import { CombatSystem } from './ecs/systems/combat-system.js';

// En constructor, después de crear otros sistemas:
this.comboSystem = new ComboSystem();
this.combatSystem = new CombatSystem();

// Registrar sistemas con prioridades correctas:
this.ecs.registerSystem(this.inputSystem);         // Priority 0
this.ecs.registerSystem(this.comboSystem);         // Priority 0.5
this.ecs.registerSystem(this.physicsSystem);       // Priority 1
this.ecs.registerSystem(this.combatSystem);        // Priority 1.5
this.ecs.registerSystem(this.animationStateSystem); // Priority 2
this.ecs.registerSystem(this.animationMixerSystem); // Priority 2.5
// ... resto de sistemas
```

**player-factory.js:**
```javascript
import { ComboComponent } from '../components/combo.js';
import { CombatComponent } from '../components/combat.js';
import { WeaponComponent } from '../components/weapon.js'; // Opcional

// En createPlayer(), después de agregar AnimationComponent:
ecs.addComponent(playerId, 'Animation', new AnimationComponent());

// Agregar componentes de combate:
ecs.addComponent(playerId, 'Combo', new ComboComponent());
ecs.addComponent(playerId, 'Combat', new CombatComponent());

// Opcional: agregar WeaponComponent si queremos probar con un arma:
// ecs.addComponent(playerId, 'Weapon', new WeaponComponent({ weaponType: 'sword' }));
```

**Notas:**
- Las prioridades de los sistemas son importantes para el orden de ejecución
- ComboSystem debe ejecutarse antes de InputSystem para procesar inputs
- CombatSystem debe ejecutarse después de InputSystem pero antes de AnimationStateSystem
- WeaponComponent es opcional - se puede agregar después para pruebas

---

### Paso 15: Actualizar READMEs

**Descripción:**
Actualizar documentación para incluir los nuevos sistemas y componentes.

**Archivos a crear/modificar:**
- `frontend/src/ecs/animation/combos/README.md`
- `frontend/src/ecs/animation/README.md` (actualizar)
- `frontend/src/ecs/README.md` (actualizar)

**Detalles de implementación:**

**combos/README.md:**
```markdown
# Sistema de Combos

Este módulo implementa el sistema de combos para el sistema de combate.

## Componentes

- **InputBuffer**: Almacena inputs recientes con timestamp para detección de combos
- **ComboChain**: Representa una secuencia de combo (pasos de ataque)
- **ComboManager**: Gestiona detección y ejecución de combos

## Uso

Los combos se definen en `../config/combo-config.js` y se procesan automáticamente por `ComboSystem`.

## Flujo

1. Usuario presiona inputs (clicks, combinaciones)
2. InputBuffer almacena inputs con timestamp
3. ComboManager detecta si la secuencia coincide con algún combo configurado
4. Si coincide, inicia el combo y ejecuta animaciones en secuencia
5. ComboSystem actualiza ComboComponent con el estado del combo
6. AnimationStateSystem lee ComboComponent para determinar animación
```

**Actualizar animation/README.md:**
- Agregar sección sobre sistema de combos
- Documentar nuevas configuraciones (combo-config, input-combinations-config, weapon-animations-config)

**Actualizar ecs/README.md:**
- Documentar ComboSystem, CombatSystem
- Documentar ComboComponent, CombatComponent, WeaponComponent

**Notas:**
- Mantener documentación actualizada con los cambios
- Incluir ejemplos de uso cuando sea relevante

---

### Paso 16: Testing y Ajustes

**Descripción:**
Probar el sistema completo, ajustar timings de combos, y verificar que todo funciona correctamente.

**Archivos a probar:**
- Todo el sistema integrado

**Detalles de implementación:**
Escenarios de prueba:

1. **Sistema de Combos:**
   - Presionar click → click → click y verificar que ejecuta combo de 3 golpes
   - Presionar click → esperar mucho tiempo → click y verificar que NO ejecuta combo
   - Verificar que cada paso del combo ejecuta la animación correcta

2. **Combinaciones de Teclas:**
   - Click + Shift ejecuta ataque pesado
   - Click + Ctrl ejecuta ataque cargado
   - Q ejecuta parry
   - E durante movimiento ejecuta dodge

3. **Integración:**
   - Verificar que combos y combinaciones no se interfieren
   - Verificar que las animaciones se ejecutan correctamente
   - Verificar transiciones suaves

4. **Sistema de Armas (preparación):**
   - Agregar WeaponComponent con weaponType='sword' y verificar que funciona
   - Verificar que sin WeaponComponent funciona con animaciones genéricas

**Notas:**
- Ajustar timings de combos según feel del juego
- Verificar que no hay regresiones en animaciones existentes
- Probar edge cases (inputs muy rápidos, múltiples combinaciones simultáneas)

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-021_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Input buffer debe limitarse a inputs recientes (últimos 1-2 segundos)
- Combo detection debe ser eficiente (no iterar sobre todos los combos cada frame)
- Cache de combos activos por tipo de arma puede optimizar

### Extensibilidad
- Nueva arma = solo agregar entrada en weapon-animations-config.js
- Nuevo combo = solo agregar entrada en combo-config.js
- Nueva combinación = solo agregar entrada en input-combinations-config.js

### Compatibilidad
- Sistema funciona sin WeaponComponent (fallback a genéricas)
- Combos opcionales (pueden deshabilitarse)
- Compatibilidad retroactiva con animaciones existentes

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna - solo cambios en código JavaScript existente

### Variables de Entorno (si aplica)
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/animation/combos/` - Sistema de combos (nuevo)
2. `frontend/src/ecs/systems/combo-system.js` - Sistema ECS de combos (nuevo)
3. `frontend/src/ecs/systems/combat-system.js` - Sistema ECS de combate (nuevo)
4. `frontend/src/ecs/components/combo.js` - Componente de combos (nuevo)
5. `frontend/src/ecs/components/combat.js` - Componente de combate (nuevo)
6. `frontend/src/ecs/components/weapon.js` - Componente de arma (nuevo, opcional)
7. `frontend/src/ecs/animation/config/combo-config.js` - Configuración de combos (nuevo)
8. `frontend/src/ecs/animation/config/input-combinations-config.js` - Configuración de combinaciones (nuevo)
9. `frontend/src/ecs/animation/config/weapon-animations-config.js` - Configuración de armas (nuevo)
10. `frontend/src/ecs/animation/config/animation-config.js` - Expandir con todas las animaciones
11. `frontend/src/ecs/systems/animation-state-system.js` - Integrar combos y combate
12. `frontend/src/ecs/systems/animation-mixer-system.js` - Resolver animaciones dinámicas

## Testing

### Tests a Crear/Modificar
- Testing manual de combos y combinaciones
- Verificar en navegador con herramientas de desarrollo

### Escenarios de Prueba
1. Sistema de combos funciona correctamente
2. Combinaciones de teclas funcionan correctamente
3. Integración entre sistemas funciona sin conflictos
4. Sistema de armas (preparación) funciona correctamente

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

