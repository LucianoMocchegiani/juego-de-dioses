# JDG-024 - Sistema de Ambiente y Natación

## Descripción de la Tarea

Implementar sistema de detección de agua y estados de animación para natación (`swim`, `swim_idle`).

**Comportamiento actual:**
- No hay detección de agua o líquidos.
- El `CollisionSystem` solo detecta partículas sólidas (`estado_nombre === 'solido'`).
- No hay estados de animación para natación.
- Las animaciones de natación existen (`swimming_to_edge`, `swim_idle`, `swim_forward`) pero no están configuradas.

**Comportamiento esperado:**
- Sistema detecta cuando el personaje está en agua/líquidos.
- Estado `swim` se activa cuando está en agua + hay movimiento.
- Estado `swim_idle` se activa cuando está en agua + sin movimiento.
- Transiciones suaves al entrar/salir del agua.
- Prioridades correctas (swim > walk/run).

## Criterios de Aceptación

1. [ ] Sistema de detección de agua funciona correctamente (detecta partículas líquidas).
2. [ ] Estado `swim` funciona correctamente: se activa cuando está en agua + movimiento.
3. [ ] Estado `swim_idle` funciona correctamente: se activa cuando está en agua sin movimiento.
4. [ ] Prioridades de estados correctamente configuradas (swim/swim_idle > walk/run, pero < combat/jump).
5. [ ] Transiciones suaves al entrar/salir del agua.
6. [ ] Detección funciona con diferentes tipos de líquidos (agua, agua_sucia, lava, pantano).
7. [ ] El código sigue el patrón ECS y usa el sistema de condiciones existente.

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)
- [ ] Backend (FastAPI) - No requiere cambios
- [ ] Base de Datos (PostgreSQL) - No requiere cambios

### Tecnologías Involucradas
- JavaScript ES6+
- ECS (Entity Component System)
- Three.js
- Sistema de colisiones
- Sistema de animaciones con condiciones

### Referencias
- Análisis de arquitectura: `instructions/analysis/JDG-024-architecture-analysis_2026-01-10_12-46-47.md`
- Ticket original: `instructions/tickets/JDG-024_work-ticket_2025-12-10_15-10-00.md`

## Pasos de Implementación

### Paso 1: Agregar propiedad isInWater a PhysicsComponent

**Descripción:**
Agregar propiedad `isInWater` al componente de física para rastrear cuando la entidad está en agua/líquidos.

**Archivos a modificar:**
- `frontend/src/ecs/components/physics.js`

**Detalles de implementación:**
```javascript
// En el constructor de PhysicsComponent
constructor(options = {}) {
    // ... propiedades existentes ...
    
    // Detección de ambiente
    this.isInWater = options.isInWater !== undefined ? options.isInWater : false;
}

// Nota: Consistente con isGrounded e isFlying existentes
```

**Testing:**
- Verificar que `isInWater` se inicializa en `false` por defecto.
- Verificar que puede establecerse en `true`/`false` desde opciones.

---

### Paso 2: Modificar CollisionSystem para detectar partículas líquidas

**Descripción:**
Extender `CollisionSystem` para detectar partículas líquidas además de sólidas. Actualizar `physics.isInWater` basándose en la detección.

**Archivos a modificar:**
- `frontend/src/ecs/systems/collision-system.js`
- `frontend/src/config/animation-constants.js` (agregar constantes de tipos líquidos)

**Detalles de implementación:**

1. **Agregar constantes de tipos líquidos:**
```javascript
// En animation-constants.js
COLLISION: {
    // ... existente ...
    PARTICLE_STATE_LIQUID: 'liquido',
    LIQUID_TYPES: ['agua', 'agua_sucia', 'lava', 'pantano'], // Tipos específicos conocidos
}
```

2. **Agregar método para detectar líquidos:**
```javascript
// En CollisionSystem
detectLiquidAtPosition(position) {
    // Opción 1: Usar partículas ya cargadas (si están disponibles)
    if (this.particles && this.particles.length > 0) {
        const particlesAtPosition = this.particles.filter(p => 
            p.celda_x === Math.floor(position.x) &&
            p.celda_y === Math.floor(position.y) &&
            p.celda_z === Math.floor(position.z) &&
            !p.extraida
        );
        
        // Verificar si hay líquidos
        const hasLiquid = particlesAtPosition.some(p => 
            p.estado_nombre === ANIMATION_CONSTANTS.COLLISION.PARTICLE_STATE_LIQUID ||
            ANIMATION_CONSTANTS.COLLISION.LIQUID_TYPES.includes(p.tipo_nombre)
        );
        
        return hasLiquid;
    }
    
    // Opción 2: Si no hay partículas cargadas, retornar false
    // (puede extenderse en el futuro para consultar API)
    return false;
}
```

3. **Actualizar método update() para detectar agua:**
```javascript
update(deltaTime) {
    const entities = this.getEntities();
    
    for (const entityId of entities) {
        const position = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.POSITION);
        const physics = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.PHYSICS);
        
        if (!position || !physics) continue;
        
        // ... código existente de colisiones sólidas ...
        
        // Detectar agua/líquidos
        physics.isInWater = this.detectLiquidAtPosition(position);
    }
}
```

**Consideraciones:**
- Usar partículas ya cargadas del viewport cuando están disponibles (optimización).
- Si no hay partículas cargadas, retornar `false` (puede extenderse en el futuro).
- Considerar usar `spatialGrid` si está disponible para queries más eficientes.
- La detección puede ser en la misma celda Z o Z-1 (ajustar según necesidad).

**Testing:**
- Verificar que detecta partículas con `estado_nombre === 'liquido'`.
- Verificar que detecta tipos específicos: 'agua', 'agua_sucia', 'lava', 'pantano'.
- Verificar que `physics.isInWater` se actualiza correctamente.
- Verificar que no detecta partículas `extraida = true`.

---

### Paso 3: Crear WaterCondition

**Descripción:**
Crear condición para evaluar si una entidad está en agua, siguiendo el patrón de condiciones existente.

**Archivos a crear:**
- `frontend/src/ecs/conditions/water-condition.js`

**Archivos a modificar:**
- `frontend/src/config/animation-constants.js` (agregar CONDITION_TYPES.WATER)
- `frontend/src/ecs/conditions/condition-factory.js` (agregar caso 'water')
- `frontend/src/ecs/conditions/index.js` (exportar WaterCondition)

**Detalles de implementación:**

1. **Crear water-condition.js:**
```javascript
/**
 * Condición basada en ambiente acuático
 */
import { BaseCondition } from './base-condition.js';

export class WaterCondition extends BaseCondition {
    evaluate(context) {
        const { physics } = context;
        if (!physics) return false;
        
        const { operator } = this.config;
        
        switch (operator) {
            case 'isInWater':
                return physics.isInWater === true;
            case 'notInWater':
                return physics.isInWater === false;
            default:
                return false;
        }
    }
}
```

2. **Agregar constante en animation-constants.js:**
```javascript
CONDITION_TYPES: {
    INPUT: 'input',
    PHYSICS: 'physics',
    MOVEMENT: 'movement',
    COMBO: 'combo',
    COMBAT: 'combat',
    WATER: 'water', // NUEVO
},
```

3. **Actualizar ConditionFactory:**
```javascript
import { WaterCondition } from './water-condition.js';

// En el switch de create()
case ANIMATION_CONSTANTS.CONDITION_TYPES.WATER:
    return new WaterCondition(conditionConfig);
```

4. **Exportar en index.js:**
```javascript
export { WaterCondition } from './water-condition.js';
```

**Testing:**
- Verificar que `WaterCondition.evaluate()` retorna `true` cuando `physics.isInWater === true`.
- Verificar que retorna `false` cuando `physics.isInWater === false` o `physics` es null.
- Verificar que `ConditionFactory.create()` crea instancia de `WaterCondition` para tipo 'water'.

---

### Paso 4: Configurar Estados de Natación en animation-config.js

**Descripción:**
Agregar estados `swim` y `swim_idle` en la configuración de animaciones con prioridades y condiciones apropiadas.

**Archivos a modificar:**
- `frontend/src/config/animation-config.js`

**Detalles de implementación:**

Agregar estados después de `flying` (priority 10) y antes de `crouch_walk` (priority 7):

```javascript
{
    id: 'swim',
    type: 'movement',
    priority: 7.5, // Mayor que walk/run (4-5) pero menor que jump (9) y combat (10-12)
    conditions: [
        { type: 'water', operator: 'isInWater' },
        { type: 'movement', operator: 'hasMovement' },
        { type: 'physics', property: 'isFlying', operator: 'equals', value: false } // No nadar si está volando
    ],
    animation: 'swim_forward', // Usar animación de natación hacia adelante
    interruptOnInputRelease: true,
    transitions: ['swim_idle', 'idle', 'walk', 'run']
},
{
    id: 'swim_idle',
    type: 'idle',
    priority: 7.5, // Misma prioridad que swim
    conditions: [
        { type: 'water', operator: 'isInWater' },
        { type: 'movement', operator: 'noMovement' },
        { type: 'physics', property: 'isFlying', operator: 'equals', value: false }
    ],
    animation: 'swim_idle', // Usar animación de flotación
    transitions: ['swim', 'idle', 'walk', 'run']
},
```

**Notas:**
- Las animaciones `swim_forward` y `swim_idle` ya existen en `ANIMATION_FILES`.
- Prioridad 7.5 asegura que tenga precedencia sobre walk (4) y run (5), pero no sobre jump (9) o combat (10-12).
- Incluir condición de `!isFlying` para evitar conflictos con vuelo.

**Testing:**
- Verificar que los estados están correctamente configurados.
- Verificar que las animaciones referenciadas existen en `ANIMATION_FILES`.
- Verificar prioridades son correctas.

---

### Paso 5: Verificar AnimationStateSystem (Sin Cambios Necesarios)

**Descripción:**
Verificar que `AnimationStateSystem` ya incluye `physics` en el contexto, permitiendo que `WaterCondition` funcione sin modificaciones.

**Archivos a revisar:**
- `frontend/src/ecs/systems/animation-state-system.js`

**Verificación:**
- Confirmar que el contexto incluye `physics` (ya está incluido según código actual).
- Confirmar que `StateRegistry.determineActiveState(context)` pasa el contexto correctamente.
- No se requieren cambios, solo verificación.

**Testing:**
- Verificar que el contexto contiene `physics` cuando se evalúan condiciones.
- Verificar que `WaterCondition` puede acceder a `context.physics.isInWater`.

---

### Paso 6: Testing Manual Completo

**Descripción:**
Probar el sistema completo en diferentes escenarios para verificar que funciona correctamente.

**Escenarios de prueba:**

1. **Entrar al agua:**
   - Caminar hacia partículas de agua.
   - Verificar que `physics.isInWater` cambia a `true`.
   - Verificar que se activa estado `swim` o `swim_idle` según movimiento.

2. **Nadar (movimiento en agua):**
   - Moverse en agua.
   - Verificar que se activa estado `swim`.
   - Verificar que la animación `swim_forward` se reproduce.

3. **Flotar (quieto en agua):**
   - Quedarse quieto en agua.
   - Verificar que se activa estado `swim_idle`.
   - Verificar que la animación `swim_idle` se reproduce.

4. **Salir del agua:**
   - Caminar fuera del agua.
   - Verificar que `physics.isInWater` cambia a `false`.
   - Verificar que vuelve a estado `walk`/`run`/`idle` apropiado.

5. **Diferentes tipos de líquidos:**
   - Probar con partículas de tipo 'agua'.
   - Probar con partículas de tipo 'agua_sucia'.
   - Probar con partículas de tipo 'lava' (si existen).
   - Probar con partículas de tipo 'pantano' (si existen).
   - Verificar que todos se detectan correctamente.

6. **Transiciones suaves:**
   - Entrar y salir del agua rápidamente.
   - Verificar que las transiciones son suaves sin flickering.
   - Verificar que no hay estados intermedios incorrectos.

7. **Prioridades:**
   - Probar combate mientras está en agua (combat debe tener prioridad).
   - Probar salto mientras está en agua (jump debe tener prioridad).
   - Verificar que swim/swim_idle tienen prioridad sobre walk/run.

**Casos edge a considerar:**
- Entidad en el límite entre agua y aire (puede causar flickering).
- Múltiples partículas líquidas en la misma posición.
- Partículas líquidas con `extraida = true` (no deben detectarse).
- Entidad volando sobre agua (no debe activar natación).

---

### Paso 7: Ajustes y Optimizaciones (Opcional)

**Descripción:**
Ajustar parámetros y optimizar según resultados de testing.

**Consideraciones:**
- **Umbral de detección**: Ajustar si la detección es muy sensible o poco sensible.
- **Debounce/Throttle**: Agregar si hay flickering al entrar/salir del agua.
- **Cache**: Cachear resultados de detección si la entidad no se ha movido significativamente.
- **SpatialGrid**: Usar `spatialGrid` para queries más eficientes si está disponible.
- **Z offset**: Considerar detectar en Z-1 o Z+1 si la detección no es precisa.

**Archivos a modificar:**
- `frontend/src/ecs/systems/collision-system.js` (ajustes de detección)

---

### Paso Final: Generar Descripción del Pull Request

**Comando:**
`@juego-de-dioses/instructions/pr-description.mdc generate este y estamos`

**Notas:**
- Asegurarse de que todos los criterios de aceptación están cumplidos.
- Incluir información sobre constantes agregadas.
- Mencionar que backend y base de datos no requieren cambios.

## Notas de Implementación

### Decisiones de Diseño

1. **Agregar `isInWater` a PhysicsComponent (Opción A)**: Se eligió agregar la propiedad directamente a `PhysicsComponent` en lugar de crear un nuevo `EnvironmentComponent` porque:
   - Menor refactorización.
   - Consistente con `isGrounded` e `isFlying` existentes.
   - Suficiente para natación básica.
   - Puede migrarse a componente separado en el futuro si se necesita más complejidad.

2. **Detección por `estado_nombre` y `tipo_nombre`**: Se detectan líquidos tanto por `estado_nombre === 'liquido'` (genérico) como por `tipo_nombre` específico ('agua', 'agua_sucia', etc.) para:
   - Máxima compatibilidad con diferentes tipos de líquidos.
   - Detección genérica para futuros tipos de líquidos.
   - Detección específica para tipos conocidos.

3. **Prioridad 7.5 para estados de natación**: Se eligió 7.5 porque:
   - Mayor que walk (4) y run (5) para tener precedencia.
   - Menor que jump (9) y combat (10-12) para no interferir con acciones prioritarias.
   - Permite que combat y jump se activen incluso en agua.

### Extensiones Futuras

- **Efectos ambientales**: Agregar velocidad reducida en agua, daño por lava, resistencia, etc.
- **Profundidad de agua**: Detectar profundidad y ajustar comportamiento.
- **Otros ambientes**: Extender para detectar gas tóxico, zonas mágicas, etc.
- **EnvironmentComponent**: Migrar a componente separado si se necesita más complejidad.
- **Velocidad de natación**: Agregar velocidad específica para movimiento en agua.

## Referencias

- Análisis de arquitectura: `instructions/analysis/JDG-024-architecture-analysis_2026-01-10_12-46-47.md`
- Ticket: `instructions/tickets/JDG-024_work-ticket_2025-12-10_15-10-00.md`
- Plan anterior (desactualizado): `instructions/tasks/JDG-024-action-plan_2025-12-10_15-10-00.md`
