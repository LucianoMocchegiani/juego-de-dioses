# JDG-025 - Sistema de Equipamiento y Visualización de Armas

## Nota sobre Nomenclatura

Para mayor claridad y consistencia, este plan usa nombres descriptivos que reflejan la función real de cada sistema:

- **`PositionUpdateSystem`**: Sistema que actualiza posición y rotación de entidades (renombrado desde `RenderSystem` para mayor claridad)
- **`WeaponEquipSystem`**: Sistema de equipamiento de armas (renombrado desde `WeaponRenderSystem` para mayor claridad)

**Nomenclatura de Sistemas ECS:**
- `InputSystem` - Procesa input del teclado/mouse ✅
- `PhysicsSystem` - Aplica física (gravedad, velocidad) ✅
- `CollisionSystem` - Detecta y resuelve colisiones ✅
- `CombatSystem` - Procesa acciones de combate ✅
- `ComboSystem` - Gestiona combos de ataques ✅
- `AnimationStateSystem` - Determina estado de animación ✅
- `AnimationMixerSystem` - Reproduce animaciones GLB ✅
- `PositionUpdateSystem` - Actualiza posición/rotación de meshes ✅ (renombrado desde `RenderSystem`)
- `WeaponEquipSystem` - Gestiona equipamiento de armas ✅ (renombrado desde `WeaponRenderSystem`)

## Descripción de la Tarea

Implementar un sistema completo de equipamiento y visualización de armas en el juego. El sistema debe permitir cargar modelos GLB de armas desde el backend, adjuntarlos visualmente al personaje en la posición correcta, y gestionar el cambio de armas equipadas.

**Comportamiento actual:**
- El `WeaponComponent` existe pero solo almacena el tipo de arma (string), no el modelo 3D
- Los modelos GLB de armas están disponibles en `/static/models/weapons/` pero no se cargan ni visualizan
- El sistema de animaciones por tipo de arma funciona correctamente
- No hay forma de visualizar armas en el personaje
- No existe sistema de attachment (adjuntar armas al personaje)

**Comportamiento esperado:**
- Las armas se cargan desde archivos GLB y se visualizan en el personaje
- Las armas se adjuntan correctamente al personaje usando bones del esqueleto (en la mano derecha, espalda, etc.)
- El personaje debe tener esqueleto para que el sistema de attachment funcione
- Se puede equipar/desequipar armas cambiando el `WeaponComponent`
- El sistema usa cache para reutilizar modelos de armas cargados
- Las armas se integran correctamente con el sistema de animaciones existente

## Criterios de Aceptación

1. ❌ Los modelos GLB de armas se cargan correctamente desde `/static/models/weapons/`
2. ❌ Las armas se visualizan adjuntadas al personaje en la posición correcta
3. ❌ El sistema soporta attachment por bones (el personaje debe tener esqueleto)
4. ❌ El `WeaponComponent` almacena información completa del arma (modelo, attachment point, offsets)
5. ❌ El sistema usa cache para reutilizar modelos de armas entre múltiples personajes
6. ❌ Las armas se pueden equipar/desequipar cambiando el `WeaponComponent`
7. ❌ El sistema se integra correctamente con el sistema de animaciones existente
8. ❌ Todas las armas disponibles (sword, axe, two-handed-axe, hammer, two-handed-hammer, spear) funcionan correctamente

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI) - Solo verificación de rutas estáticas (ya funcionan)
- [x] Frontend (Three.js) - Implementación principal
- [ ] Base de Datos (PostgreSQL) - No necesario para MVP
- [ ] Cache (Redis) - No necesario para MVP
- [ ] Docker/Infraestructura - No requiere cambios

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn (solo verificación)
- Frontend: HTML5, JavaScript ES6+, Three.js
- Modelos 3D: GLB/GLTF format
- Sistema ECS: Entity Component System personalizado

## Pasos de Implementación

### Paso 0: Reorganizar Estructura de Directorios (Genéricos fuera de animation/)

**Descripción:**
Reorganizar la estructura de directorios moviendo sistemas genéricos (`conditions/`, `states/`, `combos/`) fuera de `animation/` para reflejar que son reutilizables y no específicos de animaciones.

**Razón:**
- `conditions/` es un sistema genérico de evaluación de condiciones (puede usarse para IA, combate, UI, etc.)
- `states/` es un sistema genérico de máquinas de estados (puede usarse para cualquier FSM)
- `combos/` es específico de combate, no de animaciones
- Mantenerlos en `animation/` es confuso y limita su reutilización

**Estructura actual:**
```
ecs/
├── animation/
│   ├── combos/        ← Sistema de combos (lógica de combate)
│   ├── conditions/     ← Sistema genérico de condiciones
│   └── states/         ← Sistema genérico de estados
```

**Estructura nueva:**
```
ecs/
├── conditions/         ← Sistema genérico de condiciones (nuevo nivel)
├── states/             ← Sistema genérico de estados (nuevo nivel)
├── combos/             ← Sistema específico de combos (nuevo nivel)
└── animation/          ← Vacío o solo helpers específicos (si aplica)
```

**Archivos a mover:**
1. `frontend/src/ecs/animation/combos/` → `frontend/src/ecs/combos/`
2. `frontend/src/ecs/animation/conditions/` → `frontend/src/ecs/conditions/`
3. `frontend/src/ecs/animation/states/` → `frontend/src/ecs/states/`

**Archivos a actualizar (imports):**

**Sistemas que importan desde los directorios movidos:**

1. `frontend/src/ecs/systems/combo-system.js`
   ```javascript
   // Antes:
   import { ComboManager } from '../animation/combos/combo-manager.js';
   // Después:
   import { ComboManager } from '../combos/combo-manager.js';
   ```

2. `frontend/src/ecs/systems/animation-state-system.js`
   ```javascript
   // Antes:
   import { StateRegistry } from '../animation/states/state-registry.js';
   // Después:
   import { StateRegistry } from '../states/state-registry.js';
   ```

3. `frontend/src/ecs/systems/animation-mixer-system.js`
   ```javascript
   // Antes:
   import { AnimationState } from '../animation/states/animation-state.js';
   // Después:
   import { AnimationState } from '../states/animation-state.js';
   ```

**Archivos dentro de los directorios movidos que importan desde fuera:**

4. `frontend/src/ecs/states/state-registry.js` (después de mover)
   ```javascript
   // Antes:
   import { ConditionFactory } from '../conditions/condition-factory.js';
   import { ANIMATION_CONSTANTS } from '../../../config/animation-constants.js';
   // Después:
   import { ConditionFactory } from '../conditions/condition-factory.js';
   import { ANIMATION_CONSTANTS } from '../../config/animation-constants.js';
   ```

5. `frontend/src/ecs/conditions/condition-factory.js` (después de mover)
   ```javascript
   // Antes:
   import { ANIMATION_CONSTANTS } from '../../../config/animation-constants.js';
   // Después:
   import { ANIMATION_CONSTANTS } from '../../config/animation-constants.js';
   ```

**Archivos de documentación y exports:**

6. `frontend/src/ecs/animation/index.js` (si existe)
   - Eliminar o actualizar exports si ya no hay nada en `animation/`
   - Si solo exporta desde config, mantenerlo o moverlo

7. `frontend/src/ecs/README.md`
   - Actualizar referencias a rutas de directorios
   - Actualizar estructura de directorios en la documentación

8. `frontend/src/ecs/animation/README.md` (si existe)
   - Actualizar rutas relativas en ejemplos
   - Actualizar referencias a otros módulos

**Nota sobre imports internos:**
- Los archivos dentro de cada directorio que importan entre sí (ej: `combo-manager.js` importa `combo-chain.js`) NO necesitan cambios
- Solo los imports que salen del directorio necesitan actualización

**Pasos de ejecución:**

1. **Crear nuevos directorios:**
   - `frontend/src/ecs/conditions/`
   - `frontend/src/ecs/states/`
   - `frontend/src/ecs/combos/`

2. **Mover archivos completos (mantener estructura interna):**
   - Mover `animation/combos/*` → `combos/*`
   - Mover `animation/conditions/*` → `conditions/*`
   - Mover `animation/states/*` → `states/*`

3. **Actualizar imports en sistemas:**
   - `systems/combo-system.js`
   - `systems/animation-state-system.js`
   - `systems/animation-mixer-system.js`

4. **Actualizar rutas relativas en archivos movidos:**
   - `states/state-registry.js` (ruta a `config/`)
   - `conditions/condition-factory.js` (ruta a `config/`)

5. **Actualizar documentación:**
   - `ecs/README.md` (estructura de directorios, referencias a rutas)
   - `ecs/animation/README.md` (actualizar estructura mostrada, rutas relativas)
   - `ecs/combos/README.md` (actualizar rutas relativas a sistemas)
   - `ecs/animation/index.js` (verificar si aún es necesario o eliminarlo)

6. **Verificar:**
   - Ejecutar el juego y verificar que todo funciona
   - Verificar que no hay errores en consola
   - Verificar que las animaciones siguen funcionando
   - Verificar que los combos siguen funcionando

**Notas:**
- Esta reorganización NO cambia funcionalidad, solo estructura
- Todos los sistemas seguirán funcionando igual
- Facilita reutilización futura de `conditions/` y `states/` para otros sistemas
- `combos/` queda claramente identificado como sistema de combate

**Verificación:**
- Ejecutar el juego y verificar que todo funciona
- Verificar que no hay errores en consola
- Verificar que las animaciones siguen funcionando
- Verificar que los combos siguen funcionando

---

### Paso 1: Extender WeaponComponent

**Descripción:**
Extender el `WeaponComponent` para almacenar información completa sobre el modelo del arma, incluyendo ruta del modelo, instancia del modelo cargado, punto de attachment, offsets, rotación y escala.

**Archivos a modificar/crear:**
- `frontend/src/ecs/components/weapon.js`

**Detalles de implementación:**
```javascript
export class WeaponComponent {
    constructor(options = {}) {
        this.weaponType = options.weaponType || 'generic';
        this.weaponId = options.weaponId || null;
        
        // NUEVO: Información del modelo
        this.modelPath = options.modelPath || null;  // Ruta del modelo GLB
        this.modelInstance = null;                    // Instancia del modelo cargado
        this.attachmentPoint = options.attachmentPoint || 'right_hand';  // Punto de attachment
        this.offset = options.offset || { x: 0, y: 0, z: 0 };  // Offset relativo
        this.rotation = options.rotation || { x: 0, y: 0, z: 0 };  // Rotación adicional
        this.scale = options.scale || 1.0;  // Escala del modelo
        
        this.hasShield = options.hasShield || false;
    }
}
```

**Notas:**
- Mantener compatibilidad con código existente que usa `weaponType`
- Los campos nuevos son opcionales y tienen valores por defecto
- `modelInstance` se inicializa como `null` y se asignará cuando se cargue el modelo

---

### Paso 2: Crear Configuración de Modelos de Armas

**Descripción:**
Crear un archivo de configuración que mapea cada tipo de arma a su ruta de modelo GLB, punto de attachment, offsets, rotación y escala. Esta configuración centraliza todos los datos de armas.

**Archivos a modificar/crear:**
- `frontend/src/config/weapon-models-config.js`
- `frontend/src/config/README.md` (actualizar)

**Detalles de implementación:**
```javascript
/**
 * Configuración de Modelos de Armas
 * 
 * Define la ruta del modelo GLB, punto de attachment, offsets, rotación y escala
 * para cada tipo de arma disponible.
 */
export const WEAPON_MODELS = {
    sword: {
        path: 'weapons/sword.glb',
        attachmentPoint: 'RightHand',  // Bone real encontrado: RightHand (índice 19)
        offset: { x: 0.05, y: 0, z: 0.1 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1.0
    },
    axe: {
        path: 'weapons/axe.glb',
        attachmentPoint: 'RightHand',  // Bone real encontrado: RightHand (índice 19)
        offset: { x: 0.05, y: 0, z: 0.1 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1.0
    },
    'two-handed-axe': {
        path: 'weapons/two-handed-axe.glb',
        attachmentPoint: 'RightHand',  // Para armas de dos manos, también usar RightHand
        offset: { x: 0, y: 0, z: 0.1 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1.0
    },
    hammer: {
        path: 'weapons/hammer.glb',
        attachmentPoint: 'RightHand',  // Bone real encontrado: RightHand (índice 19)
        offset: { x: 0.05, y: 0, z: 0.1 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1.0
    },
    'two-handed-hammer': {
        path: 'weapons/two-handed-hammer.glb',
        attachmentPoint: 'RightHand',  // Para armas de dos manos, también usar RightHand
        offset: { x: 0, y: 0, z: 0.1 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1.0
    },
    spear: {
        path: 'weapons/spear.glb',
        attachmentPoint: 'RightHand',  // Bone real encontrado: RightHand (índice 19)
        offset: { x: 0.05, y: 0, z: 0.1 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1.0
    }
};
```

**Notas:**
- Los offsets están en coordenadas de Three.js (X=izq/der, Y=arriba/abajo, Z=adelante/atrás)
- Los valores de offset y rotación son aproximados y pueden requerir ajustes después de pruebas
    - **Bones disponibles confirmados:** El personaje tiene 24 bones. Para armas se usa `RightHand` (índice 19). Otros bones disponibles: `LeftHand` (15), `RightArm` (17), `RightForeArm` (18), `Spine`/`Spine01`/`Spine02` (11/10/9) para espalda
- **⚠️ READMEs:** Actualizar `frontend/src/config/README.md` para documentar este nuevo archivo de configuración

---

### Paso 3: Crear Utilidades de Attachment

**Descripción:**
Crear funciones helper para adjuntar armas al personaje. El sistema usa attachment por bones ya que el personaje debe tener esqueleto.

**Archivos a modificar/crear:**
- `frontend/src/utils/weapon-attachment.js`
- `frontend/src/utils/README.md` (actualizar)

**Detalles de implementación:**
```javascript
import * as THREE from 'three';
import { findBone, hasSkeleton } from '../renderers/models/bones-utils.js';

/**
 * Adjuntar arma al personaje
 * @param {THREE.Group} weaponModel - Modelo del arma a adjuntar
 * @param {THREE.Group} characterMesh - Mesh del personaje
 * @param {Object} attachmentConfig - Configuración de attachment
 * @param {string} attachmentConfig.point - Nombre del bone de attachment (ej: 'RightHand', 'LeftHand', 'Spine', etc.)
 * @param {Object} attachmentConfig.offset - Offset {x, y, z} relativo al bone
 * @param {Object} attachmentConfig.rotation - Rotación {x, y, z} en radianes
 * @param {number} attachmentConfig.scale - Escala del modelo
 * @returns {boolean} True si se adjuntó correctamente
 * 
 * Bones disponibles confirmados en el personaje:
 * - RightHand (índice 19) - Para armas de una mano
 * - LeftHand (índice 15) - Para escudos o armas secundarias
 * - RightArm (índice 17) / RightForeArm (índice 18) - Para armas de dos manos
 * - Spine/Spine01/Spine02 (índices 11/10/9) - Para armas en la espalda
 */
export function attachWeaponToCharacter(weaponModel, characterMesh, attachmentConfig) {
    if (!weaponModel || !characterMesh || !attachmentConfig) {
        return false;
    }
    
    // Aplicar escala
    if (attachmentConfig.scale !== undefined) {
        weaponModel.scale.set(attachmentConfig.scale, attachmentConfig.scale, attachmentConfig.scale);
    }
    
    // Attachment por bones (el personaje debe tener esqueleto)
    if (!hasSkeleton(characterMesh)) {
        console.error('attachWeaponToCharacter: El personaje debe tener esqueleto');
        return false;
    }
    
    const bone = findBone(characterMesh, attachmentConfig.point);
    if (!bone) {
        console.error(`attachWeaponToCharacter: No se encontró el bone "${attachmentConfig.point}"`);
        return false;
    }
    
    // Adjuntar al bone
    bone.add(weaponModel);
    
    // Aplicar offsets y rotaciones relativos al bone
    weaponModel.position.set(
        attachmentConfig.offset.x || 0,
        attachmentConfig.offset.y || 0,
        attachmentConfig.offset.z || 0
    );
    
    weaponModel.rotation.set(
        attachmentConfig.rotation.x || 0,
        attachmentConfig.rotation.y || 0,
        attachmentConfig.rotation.z || 0
    );
    
    return true;
}

/**
 * Desadjuntar arma del personaje
 * @param {THREE.Group} weaponModel - Modelo del arma a desadjuntar
 */
export function detachWeaponFromCharacter(weaponModel) {
    if (!weaponModel || !weaponModel.parent) {
        return;
    }
    
    // Remover del parent (bone o mesh)
    weaponModel.parent.remove(weaponModel);
}
```

**Notas:**
- El personaje debe tener esqueleto para que el attachment funcione correctamente
- Los offsets son relativos al bone de attachment
- La función `findBone()` hace búsqueda case-insensitive y parcial, así que 'RightHand', 'righthand', o 'hand' funcionarán
- **Bones confirmados:** El personaje tiene 24 bones. Usar nombres exactos como 'RightHand' para mejor precisión
- **⚠️ READMEs:** Actualizar `frontend/src/utils/README.md` para documentar las nuevas funciones de attachment

---

### Paso 4: Crear WeaponEquipSystem

**Descripción:**
Crear un nuevo sistema ECS (`WeaponEquipSystem`) que procesa todas las entidades con `WeaponComponent` y `RenderComponent`. Este sistema se encarga de cargar modelos de armas, adjuntarlos al personaje, y gestionar el equipamiento/desequipamiento de armas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/weapon-equip-system.js`
- `frontend/src/ecs/systems/index.js` (actualizar para exportar el nuevo sistema)
- `frontend/src/ecs/systems/README.md` (actualizar si existe)

**Detalles de implementación:**
```javascript
import { System } from '../system.js';
import { ECS_CONSTANTS } from '../../config/ecs-constants.js';
import { WEAPON_MODELS } from '../../config/weapon-models-config.js';
import { ModelLoader } from '../../renderers/models/model-loader.js';
import { ModelCache } from '../../renderers/models/model-cache.js';
import { attachWeaponToCharacter, detachWeaponFromCharacter } from '../../utils/weapon-attachment.js';
import { getBackendBaseUrl } from '../../utils/config.js';

export class WeaponEquipSystem extends System {
    constructor(scene) {
        super();
        this.requiredComponents = [
            ECS_CONSTANTS.COMPONENT_NAMES.RENDER,
            ECS_CONSTANTS.COMPONENT_NAMES.WEAPON
        ];
        this.scene = scene;
        this.modelLoader = new ModelLoader();
        this.weaponCache = ModelCache.getInstance(); // Reutilizar cache global
        this.priority = 2.8; // Ejecutar después de AnimationMixerSystem pero antes de PositionUpdateSystem
    }
    
    /**
     * Actualizar sistema de equipamiento de armas
     * @param {number} deltaTime - Tiempo transcurrido desde el último frame
     */
    update(_deltaTime) {
        const entities = this.getEntities();
        
        for (const entityId of entities) {
            const weapon = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.WEAPON);
            const render = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.RENDER);
            
            if (!weapon || !render || !render.mesh) continue;
            
            // Obtener configuración del arma
            const weaponConfig = WEAPON_MODELS[weapon.weaponType];
            if (!weaponConfig) {
                // Si no hay configuración, desequipar arma si existe
                if (weapon.modelInstance) {
                    this.unequipWeapon(entityId, weapon);
                }
                continue;
            }
            
            // Si el arma ya está equipada y es la misma, no hacer nada
            if (weapon.modelInstance && weapon.modelPath === weaponConfig.path) {
                continue;
            }
            
            // Si hay un arma diferente equipada, desequiparla primero
            if (weapon.modelInstance && weapon.modelPath !== weaponConfig.path) {
                this.unequipWeapon(entityId, weapon);
            }
            
            // Equipar nueva arma
            this.equipWeapon(entityId, weapon, render, weaponConfig);
        }
    }
    
    /**
     * Equipar arma a una entidad
     * @param {number} entityId - ID de la entidad
     * @param {WeaponComponent} weapon - Componente de arma
     * @param {RenderComponent} render - Componente de render
     * @param {Object} weaponConfig - Configuración del arma
     */
    async equipWeapon(entityId, weapon, render, weaponConfig) {
        try {
            // Construir URL del modelo
            const backendBase = getBackendBaseUrl();
            const modelUrl = `${backendBase}/static/models/${weaponConfig.path}`;
            
            // Verificar cache
            let weaponModel = null;
            if (this.weaponCache.has(modelUrl)) {
                weaponModel = this.weaponCache.get(modelUrl); // Ya clona internamente
            } else {
                // Cargar modelo
                weaponModel = await this.modelLoader.loadModel(modelUrl, 'glb');
                
                // Cachear modelo original (sin transformaciones)
                const originalClone = weaponModel.clone();
                originalClone.scale.set(1, 1, 1);
                originalClone.position.set(0, 0, 0);
                originalClone.rotation.set(0, 0, 0);
                this.weaponCache.set(modelUrl, originalClone);
            }
            
            // Adjuntar arma al personaje
            const attachmentConfig = {
                point: weaponConfig.attachmentPoint,
                offset: weaponConfig.offset,
                rotation: {
                    x: (weaponConfig.rotation.x || 0) * Math.PI / 180,
                    y: (weaponConfig.rotation.y || 0) * Math.PI / 180,
                    z: (weaponConfig.rotation.z || 0) * Math.PI / 180
                },
                scale: weaponConfig.scale
            };
            
            if (attachWeaponToCharacter(weaponModel, render.mesh, attachmentConfig)) {
                // Actualizar WeaponComponent
                weapon.modelPath = weaponConfig.path;
                weapon.modelInstance = weaponModel;
                weapon.attachmentPoint = weaponConfig.attachmentPoint;
                weapon.offset = weaponConfig.offset;
                weapon.rotation = weaponConfig.rotation;
                weapon.scale = weaponConfig.scale;
            }
        } catch (error) {
            console.error(`Error equipando arma ${weaponConfig.path}:`, error);
        }
    }
    
    /**
     * Desequipar arma de una entidad
     * @param {number} entityId - ID de la entidad
     * @param {WeaponComponent} weapon - Componente de arma
     */
    unequipWeapon(entityId, weapon) {
        if (weapon.modelInstance) {
            detachWeaponFromCharacter(weapon.modelInstance);
            
            // Remover de la escena si está directamente en ella
            if (weapon.modelInstance.parent === this.scene) {
                this.scene.remove(weapon.modelInstance);
            }
            
            // Limpiar referencia
            weapon.modelInstance = null;
            weapon.modelPath = null;
        }
    }
}
```

**Notas:**
- El sistema debe ejecutarse después de `AnimationMixerSystem` pero antes de `PositionUpdateSystem`
- Usar el `ModelCache` global para reutilizar modelos entre personajes
- El método `equipWeapon` es asíncrono pero se llama desde `update` (síncrono), así que las cargas serán progresivas
- **⚠️ READMEs:** Actualizar `frontend/src/ecs/systems/README.md` si existe, o crear uno documentando todos los sistemas

---

### Paso 5: Registrar WeaponEquipSystem en App

**Descripción:**
Registrar el nuevo `WeaponEquipSystem` en la clase `App` para que se ejecute en cada frame. El sistema debe inicializarse después de cargar la dimensión (cuando ya existe la escena).

**Archivos a modificar/crear:**
- `frontend/src/app.js`

**Detalles de implementación:**
```javascript
// En el import de sistemas, agregar:
import { InputSystem, PhysicsSystem, PositionUpdateSystem, CollisionSystem, AnimationStateSystem, AnimationMixerSystem, ComboSystem, CombatSystem, WeaponEquipSystem } from './ecs/systems/index.js';

// En el constructor, agregar:
this.weaponEquipSystem = null;

// En loadDemo(), después de inicializar PositionUpdateSystem:
// 16.5. Inicializar WeaponEquipSystem
if (!this.weaponEquipSystem) {
    this.weaponEquipSystem = new WeaponEquipSystem(this.scene.scene);
    this.ecs.registerSystem(this.weaponEquipSystem);
}
```

**Notas:**
- El sistema se inicializa después de `PositionUpdateSystem` porque necesita la escena
- Se registra con el ECS para que se ejecute automáticamente cada frame

---

### Paso 6: Actualizar PlayerFactory para Soporte de Arma Inicial

**Descripción:**
Actualizar `PlayerFactory` para permitir especificar un arma inicial al crear el jugador. Esto permite probar el sistema desde el inicio.

**Archivos a modificar/crear:**
- `frontend/src/ecs/factories/player-factory.js`

**Detalles de implementación:**
```javascript
// En createPlayer(), agregar opción:
static async createPlayer(options) {
    const { 
        ecs, 
        scene, 
        x = ANIMATION_CONSTANTS.DEFAULT_SPAWN.X, 
        y = ANIMATION_CONSTANTS.DEFAULT_SPAWN.Y, 
        z = ANIMATION_CONSTANTS.DEFAULT_SPAWN.Z, 
        cellSize = ANIMATION_CONSTANTS.DEFAULT_SPAWN.CELL_SIZE,
        characterId = null,
        templateId = null,
        dimensionId = null,
        initialWeapon = null  // NUEVO: Tipo de arma inicial (ej: 'sword', 'axe', etc.)
    } = options;
    
    // ... código existente ...
    
    // Agregar arma por defecto o inicial
    const weaponType = initialWeapon || COMBAT_CONSTANTS.WEAPON_TYPES.SWORD;
    ecs.addComponent(playerId, ECS_CONSTANTS.COMPONENT_NAMES.WEAPON, new WeaponComponent({
        weaponType: weaponType,
        hasShield: false
    }));
    
    return playerId;
}
```

**Notas:**
- Mantener compatibilidad con código existente (arma por defecto si no se especifica)
- El `WeaponEquipSystem` se encargará de cargar y visualizar el arma automáticamente

---

### Paso 7: Crear Utilidad para Equipar/Desequipar Armas (Opcional - Testing)

**Descripción:**
Crear una función helper para facilitar el equipamiento/desequipamiento de armas durante el desarrollo y testing. Esta función puede ser llamada desde la consola o desde un sistema de input temporal.

**Archivos a modificar/crear:**
- `frontend/src/utils/weapon-utils.js`
- `frontend/src/utils/README.md` (actualizar)

**Detalles de implementación:**
```javascript
import { ECS_CONSTANTS } from '../config/ecs-constants.js';
import { WeaponComponent } from '../ecs/components/weapon.js';
import { WEAPON_MODELS } from '../config/weapon-models-config.js';

/**
 * Equipar arma a una entidad
 * @param {ECSManager} ecs - ECS Manager
 * @param {number} entityId - ID de la entidad
 * @param {string} weaponType - Tipo de arma ('sword', 'axe', etc.) o null para desequipar
 */
export function equipWeapon(ecs, entityId, weaponType) {
    if (!ecs || !entityId) {
        console.error('equipWeapon: ecs y entityId son requeridos');
        return;
    }
    
    // Verificar que el tipo de arma existe
    if (weaponType && !WEAPON_MODELS[weaponType]) {
        console.error(`equipWeapon: Tipo de arma "${weaponType}" no existe`);
        return;
    }
    
    // Obtener o crear WeaponComponent
    let weapon = ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.WEAPON);
    
    if (weaponType) {
        // Equipar arma
        const weaponConfig = WEAPON_MODELS[weaponType];
        
        if (!weapon) {
            weapon = new WeaponComponent({
                weaponType: weaponType,
                modelPath: weaponConfig.path,
                attachmentPoint: weaponConfig.attachmentPoint,
                offset: weaponConfig.offset,
                rotation: weaponConfig.rotation,
                scale: weaponConfig.scale
            });
            ecs.addComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.WEAPON, weapon);
        } else {
            // Actualizar componente existente
            weapon.weaponType = weaponType;
            weapon.modelPath = weaponConfig.path;
            weapon.attachmentPoint = weaponConfig.attachmentPoint;
            weapon.offset = weaponConfig.offset;
            weapon.rotation = weaponConfig.rotation;
            weapon.scale = weaponConfig.scale;
            // El WeaponEquipSystem se encargará de cargar y adjuntar el modelo
        }
    } else {
        // Desequipar arma
        if (weapon) {
            weapon.weaponType = 'generic';
            weapon.modelPath = null;
            weapon.modelInstance = null;
            // El WeaponEquipSystem se encargará de remover el modelo
        }
    }
}

/**
 * Obtener tipo de arma equipada
 * @param {ECSManager} ecs - ECS Manager
 * @param {number} entityId - ID de la entidad
 * @returns {string|null} Tipo de arma o null si no tiene
 */
export function getEquippedWeapon(ecs, entityId) {
    const weapon = ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.WEAPON);
    return weapon ? weapon.weaponType : null;
}
```

**Notas:**
- Esta función es útil para testing y desarrollo
- Puede ser llamada desde la consola del navegador: `equipWeapon(app.ecs, app.playerId, 'sword')`
- **⚠️ READMEs:** Actualizar `frontend/src/utils/README.md` para documentar estas funciones

---

### Paso 8: Ajustar Offsets y Rotaciones de Armas

**Descripción:**
Probar todas las armas en el juego y ajustar los offsets, rotaciones y escalas en `weapon-models-config.js` para que se vean correctamente posicionadas en el personaje. Este paso requiere pruebas visuales.

**Archivos a modificar/crear:**
- `frontend/src/config/weapon-models-config.js`

**Detalles de implementación:**
- Cargar el juego y probar cada arma
- Ajustar valores de `offset`, `rotation` y `scale` en la configuración
- Probar con diferentes personajes si es posible
- Documentar valores finales en comentarios

**Notas:**
- Los valores iniciales son aproximados y requerirán ajustes
- Los offsets son relativos al bone de attachment del esqueleto del personaje
- Considerar crear diferentes configuraciones por tipo de personaje si es necesario (futuro)

---

### Paso 9: Optimizar Modelo two-handed-axe.glb (Opcional)

**Descripción:**
El modelo `two-handed-axe.glb` es muy pesado (3.8MB). Considerar optimizarlo si causa problemas de rendimiento. Esto puede requerir herramientas externas como Blender o gltf-pipeline.

**Archivos a modificar/crear:**
- `backend/static/models/weapons/two-handed-axe.glb` (reemplazar con versión optimizada)

**Detalles de implementación:**
- Usar gltf-pipeline para optimizar: `gltf-pipeline -i two-handed-axe.glb -o two-handed-axe-optimized.glb`
- O usar Blender para reducir polígonos y comprimir texturas
- Verificar que el modelo optimizado se vea correctamente

**Notas:**
- Este paso es opcional y solo necesario si hay problemas de rendimiento
- No es crítico para el MVP

---

### Paso 10: Testing y Verificación

**Descripción:**
Probar el sistema completo: cargar diferentes armas, verificar que se visualizan correctamente, que se adjuntan en la posición correcta, y que funcionan con las animaciones existentes.

**Archivos a modificar/crear:**
- Ninguno (solo testing)

**Detalles de implementación:**
1. Cargar el juego y verificar que el arma por defecto (espada) se visualiza
2. Probar cambiar armas usando `equipWeapon()` desde la consola
3. Verificar que las armas se posicionan correctamente
4. Verificar que las animaciones funcionan con cada tipo de arma
5. Verificar que el personaje tiene esqueleto y que el attachment funciona correctamente
6. Verificar que el cache funciona (múltiples personajes con la misma arma)

**Notas:**
- Documentar cualquier problema encontrado
- Ajustar offsets/rotaciones si es necesario

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-025_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- **Cache de modelos**: Los modelos GLB se cachean para reutilización entre múltiples personajes, reduciendo carga de memoria
- **Clonación eficiente**: Se clonan modelos cacheados en lugar de cargarlos múltiples veces
- **Sistema ECS optimizado**: El `WeaponEquipSystem` solo procesa entidades con `WeaponComponent` y `RenderComponent`

### Seguridad
- **Validación de rutas**: Las rutas de modelos se validan contra la configuración antes de cargar
- **Manejo de errores**: Errores de carga de modelos no rompen el juego, solo se registran en consola

### Casos Edge
- **Personaje sin esqueleto**: El sistema requiere que el personaje tenga esqueleto; si no lo tiene, se muestra un error
- **Arma no encontrada**: Si un tipo de arma no tiene configuración, se desequipa automáticamente
- **Modelo no cargado**: Si falla la carga del modelo, el sistema continúa sin el arma visual
- **Cambio rápido de armas**: El sistema maneja correctamente el cambio de armas sin dejar modelos huérfanos
- **Bone no encontrado**: Si el bone de attachment no existe, se muestra un error y el attachment falla

### Compatibilidad
- **Compatibilidad con código existente**: El `WeaponComponent` extendido mantiene compatibilidad con código que solo usa `weaponType`
- **Integración con animaciones**: El sistema de animaciones existente funciona sin cambios
- **Requisito de esqueleto**: El personaje debe tener esqueleto para que el sistema de attachment funcione correctamente

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Clases ES6 para organización
  - Sistema ECS para separación de responsabilidades
  - Cache pattern para reutilización de modelos
  - Strategy pattern para diferentes tipos de attachment
  - Factory pattern para equipamiento de armas

- **Sistema ECS**: 
  - `WeaponEquipSystem` extiende `System` base
  - Procesa entidades con componentes requeridos
  - Prioridad configurable para orden de ejecución

- **Carga de Modelos**: 
  - Reutilizar `ModelLoader` y `ModelCache` existentes
  - Clonar modelos cacheados para nuevas instancias
  - Aplicar transformaciones después de clonar

- **Attachment de Armas**: 
  - Attachment exclusivamente por bones (el personaje debe tener esqueleto)
  - Usar `findBone()` para localizar el bone de attachment
  - Aplicar offsets y rotaciones relativos al bone

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna - se reutilizan dependencias existentes (Three.js, ModelLoader, ModelCache)

### Variables de Entorno (si aplica)
Ninguna nueva - se usa `BACKEND_BASE_URL` existente para construir URLs de modelos

## Archivos Principales Involucrados

1. `frontend/src/ecs/components/weapon.js` - Componente extendido con información de modelo
2. `frontend/src/config/weapon-models-config.js` - Configuración de modelos de armas
3. `frontend/src/utils/weapon-attachment.js` - Utilidades de attachment
4. `frontend/src/ecs/systems/weapon-equip-system.js` - Sistema de equipamiento de armas
5. `frontend/src/app.js` - Registro del nuevo sistema
6. `frontend/src/ecs/factories/player-factory.js` - Soporte para arma inicial
7. `frontend/src/utils/weapon-utils.js` - Funciones helper para equipamiento

## Testing

### Tests a Crear/Modificar
- No se requieren tests automatizados para MVP (testing manual)

### Escenarios de Prueba
1. **Carga inicial**: Verificar que el arma por defecto se carga y visualiza correctamente
2. **Cambio de armas**: Probar cambiar entre diferentes tipos de armas
3. **Desequipamiento**: Verificar que al desequipar un arma, el modelo se remueve correctamente
4. **Múltiples personajes**: Verificar que múltiples personajes pueden usar la misma arma (cache)
5. **Esqueleto del personaje**: Verificar que el personaje tiene esqueleto y que el attachment por bones funciona correctamente
6. **Integración con animaciones**: Verificar que las animaciones funcionan correctamente con cada tipo de arma

## Deployment

### Orden de Deployment
1. Backend: No requiere cambios (rutas estáticas ya funcionan)
2. Frontend: Actualizar archivos estáticos
3. Base de datos: No requiere cambios
4. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar que los modelos GLB se cargan correctamente desde `/static/models/weapons/`
- [ ] Verificar que las armas se visualizan en el personaje
- [ ] Verificar que el cambio de armas funciona
- [ ] Verificar que las animaciones funcionan con cada tipo de arma
- [ ] Verificar logs de consola para errores

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
