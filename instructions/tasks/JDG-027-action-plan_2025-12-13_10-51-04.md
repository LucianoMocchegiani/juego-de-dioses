# JDG-027 - Sistema de Dodge Estilo Dark Souls - Refactor

## Descripción de la Tarea

Refactorizar el sistema de dodge y acciones de combate para implementar una arquitectura escalable con configuración centralizada, cooldowns, estado persistente durante animaciones, y sincronización correcta entre sistemas. Esto prepara el sistema para futuras mejoras como i-frames y diferentes tipos de movimientos.

**Comportamiento actual:**
- La velocidad de dodge está hardcodeada en `physics-system.js` (20 celdas/segundo)
- No hay cooldown, permitiendo spam de dodge
- `defenseType: 'dodge'` se resetea cada frame en `combat.reset()`
- No hay forma de trackear si el jugador está actualmente haciendo dodge
- No hay sincronización entre cuando termina la animación y cuando se resetea el estado
- Agregar nuevas acciones similares requiere modificar código en múltiples sistemas

**Comportamiento esperado:**
- Configuración centralizada de acciones de combate en `combat-actions-config.js`
- Cooldown configurable por acción (dodge: 0.5 segundos)
- Estado persistente durante animación (`activeAction`, `actionCooldowns`)
- Sistema detecta cuando la animación termina y resetea el estado correctamente
- Protección contra interrupciones durante acciones con `preventInterruption: true`
- Fácil agregar nuevas acciones solo con configuración (sin modificar sistemas)
- Preparado para futuras mejoras (i-frames, diferentes tipos de movimiento)

## Criterios de Aceptación

1. ❌ Existe archivo `combat-actions-config.js` con configuración de dodge (cooldown, velocidad, animación, etc.)
2. ❌ `CombatComponent` tiene propiedades para trackear acción activa y cooldowns
3. ❌ El dodge tiene cooldown de 0.5 segundos y no se puede spamear
4. ❌ El estado de dodge persiste durante toda la animación (no se resetea cada frame)
5. ❌ El sistema detecta cuando la animación de dodge termina y resetea el estado correctamente
6. ❌ El dodge no se puede interrumpir durante la animación (protección contra interrupciones)
7. ❌ Agregar una nueva acción similar (ej: dash) solo requiere agregar entrada en configuración
8. ❌ Todos los valores (cooldown, velocidad) están en configuración, no hardcodeados

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js
- ECS (Entity Component System): CombatSystem, PhysicsSystem, AnimationMixerSystem
- Sistema de configuración declarativa
- Sistema de input (InputManager, InputComponent)

## Pasos de Implementación

### Paso 1: Crear Configuración de Acciones de Combate

**Descripción:**
Crear el archivo de configuración centralizada `combat-actions-config.js` que define acciones de combate con propiedades específicas (cooldown, movimiento, i-frames). **IMPORTANTE:** Esta config referencia estados de animación en `animation-config.js` para evitar duplicación de propiedades como `isOneShot`, `preventInterruption`, `animation`, etc.

**Estrategia de Separación de Responsabilidades:**
- **`animation-config.js`**: Define **estados de animación** (isOneShot, preventInterruption, animation, transitions)
- **`combat-actions-config.js`**: Define **acciones de combate** (cooldown, movimiento, i-frames) que **referencian** estados de animación
- **Helper `getCompleteActionConfig()`**: Combina ambas configuraciones cuando se necesita la configuración completa

**Archivos a crear/modificar:**
- `frontend/src/config/combat-actions-config.js` (NUEVO)
- `frontend/src/config/README.md` (actualizar documentación)
- Considerar eliminar o deprecar `input-combinations-config.js` si ya no se usa

**Detalles de implementación:**
```javascript
/**
 * Configuración de Acciones de Combate
 * 
 * Define acciones de combate con propiedades específicas: cooldown, movimiento, etc.
 * REFERENCIA estados de animación en animation-config.js para evitar duplicación.
 * 
 * IMPORTANTE: No duplica propiedades que ya están en ANIMATION_STATES:
 * - isOneShot, preventInterruption, animation -> vienen de animation-config.js
 * - Esta config solo agrega propiedades específicas de combate (cooldown, movimiento)
 */
export const COMBAT_ACTIONS = {
    dodge: {
        id: 'dodge',
        inputAction: 'dodge',  // Referencia a INPUT_MAP
        animationStateId: 'dodge',  // Referencia a ANIMATION_STATES[id='dodge']
        defenseType: 'dodge',
        
        // Cooldown (específico de combate, no está en animation-config)
        cooldown: 0.5,  // segundos
        
        // Movimiento (específico de combate, no está en animation-config)
        hasMovement: true,
        movementSpeed: 20,  // celdas/segundo (migrado desde physics-system.js)
        movementType: 'directional',  // 'directional' | 'forward' | 'backward' | 'none'
        useMovementInput: true,  // Si true, usa input.moveDirection, si false, usa cámara
        
        // I-Frames (para futuro, específico de combate)
        hasIFrames: false,
        iFrameStart: 0.0,  // porcentaje de la animación (0.0 = inicio)
        iFrameEnd: 0.3,    // porcentaje de la animación (0.3 = 30% del total)
    },
    
    specialAttack: {
        id: 'specialAttack',
        inputAction: 'specialAttack',
        animationStateId: 'special_attack',  // Referencia a ANIMATION_STATES[id='special_attack']
        attackType: 'special',
        
        // Cooldown (específico de combate)
        cooldown: 2.0,
        
        // Movimiento (específico de combate)
        hasMovement: false,
        
        // I-Frames (para futuro)
        hasIFrames: false,
    },
    
    parry: {
        id: 'parry',
        inputAction: 'parry',
        animationStateId: 'parry',  // Referencia a ANIMATION_STATES[id='parry']
        defenseType: 'parry',
        cooldown: 0.0,  // Sin cooldown por ahora
        hasMovement: false,
        hasIFrames: false,
    },
    
    heavyAttack: {
        id: 'heavyAttack',
        inputAction: 'heavyAttack',
        animationStateId: 'heavy_attack',  // Referencia a ANIMATION_STATES[id='heavy_attack']
        attackType: 'heavy',
        cooldown: 0.0,
        hasMovement: false,
        hasIFrames: false,
    },
    
    chargedAttack: {
        id: 'chargedAttack',
        inputAction: 'chargedAttack',
        animationStateId: 'charged_attack',  // Referencia a ANIMATION_STATES[id='charged_attack']
        attackType: 'charged',
        cooldown: 0.0,
        hasMovement: false,
        hasIFrames: false,
    },
    
    // ... más acciones según necesidad
};

/**
 * Helper: Obtener configuración completa de una acción (combat + animation)
 * @param {string} actionId - ID de la acción
 * @returns {Object|null} Configuración combinada
 */
export function getCompleteActionConfig(actionId) {
    const combatConfig = COMBAT_ACTIONS[actionId];
    if (!combatConfig) return null;
    
    // Buscar estado de animación correspondiente
    const animationState = ANIMATION_STATES.find(state => state.id === combatConfig.animationStateId);
    if (!animationState) {
        console.warn(`Animation state '${combatConfig.animationStateId}' no encontrado para acción '${actionId}'`);
        return null;
    }
    
    // Combinar configs: combat config tiene prioridad sobre animation config
    return {
        ...animationState,  // Propiedades de animación (isOneShot, preventInterruption, etc.)
        ...combatConfig,    // Propiedades de combate (cooldown, movimiento, etc.) - sobrescribe si hay conflicto
    };
}
```

**Notas:**
- **NO duplicar** propiedades que ya están en `ANIMATION_STATES` (isOneShot, preventInterruption, animation)
- Usar `animationStateId` para referenciar el estado correspondiente en `animation-config.js`
- Agregar solo propiedades específicas de combate que NO están en animation-config (cooldown, movimiento, i-frames)
- Crear helper `getCompleteActionConfig()` que combina ambas configuraciones
- Migrar velocidad de dodge (20 celdas/segundo) desde `physics-system.js`

**Recursos útiles:**
- Ver análisis de arquitectura: `instructions/analysis/JDG-027-architecture-analysis_2025-12-13_10-32-33.md`
- Ver `animation-config.js` para entender qué propiedades NO duplicar (isOneShot, preventInterruption, animation)
- Ver `input-combinations-config.js` (si existe pero no se usa, considerar eliminarlo o deprecarlo)

**⚠️ IMPORTANTE - Evitar Duplicación:**
- `animation-config.js` ya define: `isOneShot`, `preventInterruption`, `animation`, `transitions`, etc.
- `combat-actions-config.js` solo agrega: `cooldown`, `movementSpeed`, `hasMovement`, `iFrames`, etc.
- Usar `animationStateId` para referenciar el estado en `animation-config.js`, no duplicar propiedades

---

### Paso 2: Mejorar CombatComponent con Estado Persistente

**Descripción:**
Agregar propiedades y métodos a `CombatComponent` para trackear acción activa, cooldowns, y estado persistente durante animaciones.

**Archivos a modificar:**
- `frontend/src/ecs/components/combat.js`

**Detalles de implementación:**
```javascript
export class CombatComponent {
    constructor() {
        // ... propiedades existentes ...
        
        /**
         * Acción de combate actualmente en progreso
         * @type {string|null} ID de la acción (ej: 'dodge', 'specialAttack')
         */
        this.activeAction = null;
        
        /**
         * Timestamp de cuando se inició la acción actual
         * @type {number|null} Timestamp en milisegundos
         */
        this.actionStartTime = null;
        
        /**
         * Cooldowns por acción
         * @type {Map<string, number>} Map<actionId, cooldownRemaining>
         */
        this.actionCooldowns = new Map();
        
        /**
         * Si la acción actual tiene i-frames activos
         * @type {boolean}
         */
        this.hasIFrames = false;
    }
    
    /**
     * Iniciar una acción de combate
     * @param {string} actionId - ID de la acción
     */
    startAction(actionId) {
        this.activeAction = actionId;
        this.actionStartTime = performance.now();
        // El sistema se encargará de setear defenseType/attackType según la configuración
    }
    
    /**
     * Finalizar la acción actual
     */
    endAction() {
        this.activeAction = null;
        this.actionStartTime = null;
        this.hasIFrames = false;
    }
    
    /**
     * Verificar si una acción está en cooldown
     * @param {string} actionId - ID de la acción
     * @returns {boolean}
     */
    isOnCooldown(actionId) {
        const remaining = this.actionCooldowns.get(actionId) || 0;
        return remaining > 0;
    }
    
    /**
     * Actualizar cooldowns (llamar cada frame)
     * @param {number} deltaTime - Tiempo transcurrido en segundos
     */
    updateCooldowns(deltaTime) {
        for (const [actionId, remaining] of this.actionCooldowns.entries()) {
            const newRemaining = remaining - deltaTime;
            if (newRemaining <= 0) {
                this.actionCooldowns.delete(actionId);
            } else {
                this.actionCooldowns.set(actionId, newRemaining);
            }
        }
    }
    
    /**
     * Resetear estado de combate
     * NO resetea activeAction si está activo (se resetea cuando la animación termine)
     */
    reset() {
        this.isAttacking = false;
        this.attackType = null;
        
        // Solo resetear defenseType si NO hay acción activa
        if (!this.activeAction) {
            this.defenseType = null;
        }
        
        this.canCancel = false;
        this.combatAnimation = null;
    }
}
```

**Notas:**
- Mantener compatibilidad con código existente
- El método `reset()` debe preservar `activeAction` si está activo
- Los cooldowns se actualizan cada frame con `updateCooldowns(deltaTime)`

---

### Paso 3: Refactorizar CombatSystem para Usar Configuración

**Descripción:**
Refactorizar `CombatSystem` para usar la configuración de `COMBAT_ACTIONS` en lugar de código hardcodeado. Implementar sistema de cooldowns y procesamiento de acciones basado en configuración.

**Archivos a modificar:**
- `frontend/src/ecs/systems/combat-system.js`

**Detalles de implementación:**
```javascript
import { COMBAT_ACTIONS, getCompleteActionConfig } from '../../config/combat-actions-config.js';
import { ANIMATION_STATES } from '../../config/animation-config.js';

export class CombatSystem extends System {
    update(deltaTime) {
        const entities = this.getEntities();
        
        for (const entityId of entities) {
            const input = this.ecs.getComponent(entityId, 'Input');
            const combat = this.ecs.getComponent(entityId, 'Combat');
            
            if (!input || !combat) continue;
            
            // Verificar si hay combo activo (prioridad sobre acciones individuales)
            const combo = this.ecs.getComponent(entityId, 'Combo');
            if (combo && combo.activeComboId) {
                continue; // ComboSystem maneja esto
            }
            
            // Actualizar cooldowns
            combat.updateCooldowns(deltaTime);
            
            // Si hay una acción activa, no procesar nuevos inputs
            // (la acción se finalizará cuando la animación termine en AnimationMixerSystem)
            if (combat.activeAction) {
                continue;
            }
            
            // Si no hay acción activa, procesar nuevos inputs
            combat.reset(); // Esto solo resetea si no hay activeAction
            
            // Procesar acciones según configuración (en orden de prioridad)
            for (const [actionId, actionConfig] of Object.entries(COMBAT_ACTIONS)) {
                // Verificar input usando checkAction con el inputAction configurado
                const wantsAction = this.checkActionInput(input, actionConfig.inputAction);
                
                // Verificar condiciones adicionales (arma, etc.)
                const canExecute = this.canExecuteAction(entityId, actionConfig);
                
                if (wantsAction && canExecute && !combat.isOnCooldown(actionId)) {
                    // Iniciar acción
                    combat.startAction(actionId);
                    this.applyActionConfig(combat, actionConfig);
                    
                    // Aplicar cooldown
                    combat.actionCooldowns.set(actionId, actionConfig.cooldown);
                    
                    return; // Una acción por frame
                }
            }
        }
    }
    
    checkActionInput(input, inputAction) {
        // Implementar lógica para verificar si el input corresponde a la acción
        // Puede usar InputSystem.checkAction o lógica similar
        switch (inputAction) {
            case 'dodge':
                return input.wantsToDodge;
            case 'specialAttack':
                return input.wantsToSpecialAttack;
            case 'parry':
                return input.wantsToParry;
            // ... más casos
            default:
                return false;
        }
    }
    
    canExecuteAction(entityId, actionConfig) {
        // Verificar condiciones como tipo de arma requerida
        // Por ahora, siempre retorna true, pero se puede extender
        return true;
    }
    
    applyActionConfig(combat, actionConfig) {
        // Obtener configuración completa (combina combat + animation)
        const completeConfig = getCompleteActionConfig(actionConfig.id);
        if (!completeConfig) {
            console.warn(`No se pudo obtener configuración completa para acción: ${actionConfig.id}`);
            return;
        }
        
        // Setear tipo de ataque/defensa (solo de combat config, no de animation)
        if (actionConfig.defenseType) {
            combat.defenseType = actionConfig.defenseType;
        }
        if (actionConfig.attackType) {
            combat.attackType = actionConfig.attackType;
        }
        
        // Setear animación desde animation state
        combat.combatAnimation = completeConfig.animation;
        
        // Setear flags de protección desde animation state
        // (preventInterruption ya está en animation state, se maneja automáticamente)
        combat.isAttacking = actionConfig.attackType !== null;
    }
}
```

**Notas:**
- Importar `COMBAT_ACTIONS` y `getCompleteActionConfig` desde la configuración
- Usar `getCompleteActionConfig()` para obtener la configuración completa que combina combat + animation
- Mantener compatibilidad con sistema de combos existente
- El orden de procesamiento puede ser importante (prioridad de acciones)
- Las propiedades de animación (isOneShot, preventInterruption) vienen de `animation-config.js`, no se duplican

---

### Paso 4: Refactorizar PhysicsSystem para Usar Configuración

**Descripción:**
Refactorizar `PhysicsSystem` para usar la configuración de movimiento desde `COMBAT_ACTIONS`. Manejar flag `movementApplied` para aplicar impulso solo una vez al inicio de la acción.

**Archivos a modificar:**
- `frontend/src/ecs/systems/physics-system.js`

**Detalles de implementación:**
```javascript
import { COMBAT_ACTIONS } from '../../config/combat-actions-config.js';

export class PhysicsSystem extends System {
    updatePhysics(timestep) {
        const entities = this.getEntities();
        
        for (const entityId of entities) {
            const physics = this.ecs.getComponent(entityId, 'Physics');
            const position = this.ecs.getComponent(entityId, 'Position');
            const input = this.ecs.getComponent(entityId, 'Input');
            const combat = this.ecs.getComponent(entityId, 'Combat');
            const render = this.ecs.getComponent(entityId, 'Render');
            
            if (!physics || !position) continue;
            
            // ... código existente de salto y gravedad ...
            
            // Aplicar movimiento de acciones de combate
            if (input && combat && combat.activeAction) {
                const actionConfig = COMBAT_ACTIONS[combat.activeAction];
                
                if (actionConfig && actionConfig.hasMovement) {
                    const movementSpeed = actionConfig.movementSpeed;
                    
                    // Inicializar flag si no existe
                    if (!render.mesh.userData.movementApplied) {
                        render.mesh.userData.movementApplied = false;
                    }
                    
                    // Calcular dirección según configuración (solo una vez al inicio)
                    if (!render.mesh.userData.movementApplied) {
                        let dirX = 0, dirY = 0;
                        
                        if (actionConfig.useMovementInput && 
                            (input.moveDirection.x !== 0 || input.moveDirection.y !== 0)) {
                            // Usar dirección de input
                            dirX = input.moveDirection.x;
                            dirY = input.moveDirection.y;
                        } else {
                            // Usar dirección de cámara (hacia adelante)
                            const cameraRotation = render?.rotationY || 0;
                            const cos = Math.cos(cameraRotation);
                            const sin = Math.sin(cameraRotation);
                            dirX = -sin;
                            dirY = -cos;
                        }
                        
                        // Aplicar impulso solo una vez al inicio
                        physics.velocity.x = dirX * movementSpeed;
                        physics.velocity.y = dirY * movementSpeed;
                        render.mesh.userData.movementApplied = true;
                    }
                }
            } else {
                // Si no hay acción activa, resetear flag
                if (render && render.mesh && render.mesh.userData.movementApplied) {
                    render.mesh.userData.movementApplied = false;
                }
            }
            
            // ... resto del código de física ...
        }
    }
}
```

**Notas:**
- Usar `COMBAT_ACTIONS[combat.activeAction]` para obtener la configuración de combate
- Las propiedades de movimiento (`hasMovement`, `movementSpeed`, `useMovementInput`) vienen de `combat-actions-config.js`
- No duplicar propiedades de animación (esas están en `animation-config.js`)
- Usar `render.mesh.userData.movementApplied` para trackear si ya se aplicó el impulso
- Resetear el flag cuando no hay acción activa
- Remover la lógica hardcodeada de dodge actual (velocidad 20 hardcodeada)

---

### Paso 5: Mejorar AnimationMixerSystem para Finalizar Acciones

**Descripción:**
Mejorar `AnimationMixerSystem` para detectar cuando las animaciones de combate terminan y llamar a `combat.endAction()` para resetear el estado correctamente. Actualizar i-frames si corresponde.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
import { COMBAT_ACTIONS, getCompleteActionConfig } from '../../config/combat-actions-config.js';

export class AnimationMixerSystem extends System {
    update(deltaTime) {
        // ... código existente ...
        
        // Verificar si acciones de combate terminaron
        if (mesh.userData.combatAction) {
            const action = mesh.userData.combatAction;
            const actionDuration = action.getClip().duration;
            
            // Obtener configuración de la acción
            const entityId = mesh.userData.entityId;
            if (entityId) {
                const combat = this.ecs.getComponent(entityId, 'Combat');
                if (combat && combat.activeAction) {
                    const combatConfig = COMBAT_ACTIONS[combat.activeAction];
                    
                    // Actualizar i-frames si corresponde (propiedad específica de combate)
                    if (combatConfig && combatConfig.hasIFrames) {
                        const progress = action.time / actionDuration;
                        combat.hasIFrames = progress >= combatConfig.iFrameStart && 
                                           progress <= combatConfig.iFrameEnd;
                    }
                }
            }
            
            // Cuando la animación termine completamente
            if (!action.isRunning() && action.time >= actionDuration) {
                mesh.userData.combatAction = null;
                
                // Resetear flag de movimiento aplicado
                if (mesh.userData.movementApplied !== undefined) {
                    mesh.userData.movementApplied = false;
                }
                
                // Finalizar acción en CombatComponent
                const entityId = mesh.userData.entityId;
                if (entityId) {
                    const combat = this.ecs.getComponent(entityId, 'Combat');
                    if (combat) {
                        combat.endAction();
                    }
                    
                    // Cambiar estado de animación a idle para transición suave
                    const anim = this.ecs.getComponent(entityId, 'Animation');
                    if (anim) {
                        anim.currentState = 'idle';
                    }
                }
            }
        }
        
        // ... código existente de playAnimation ...
        
        // Al reproducir animación de combate, guardar referencia
        if (isOneShot) {
            action.setLoop(THREE.LoopOnce);
            action.clampWhenFinished = false;
            
            // Verificar si es acción de combate
            const entityId = mesh.userData.entityId;
            let isCombatAction = false;
            if (entityId) {
                const combat = this.ecs.getComponent(entityId, 'Combat');
                if (combat && combat.activeAction) {
                    isCombatAction = true;
                }
            }
            
            if (isCombatAction) {
                mesh.userData.combatAction = action;
            } else {
                mesh.userData.attackAction = action;
                mesh.userData.isAttacking = true;
            }
        }
    }
}
```

**Notas:**
- Distinguir entre acciones de combate (con `combat.activeAction`) y ataques normales
- Usar `COMBAT_ACTIONS[combat.activeAction]` para obtener la configuración de combate
- Las propiedades de movimiento (`hasMovement`, `movementSpeed`) vienen de `combat-actions-config.js`
- Las propiedades de animación (`isOneShot`, `preventInterruption`) vienen de `animation-config.js` (no duplicar)
- Actualizar i-frames durante la animación si está configurado en `combat-actions-config.js`
- Resetear flags correctamente cuando termina la animación

---

### Paso 6: Testing y Ajustes

**Descripción:**
Probar el sistema completo de dodge con cooldown, verificar que el estado persiste durante la animación, que no se puede interrumpir, y que se resetea correctamente al terminar. Ajustar valores de configuración según feedback.

**Archivos a probar:**
- Todos los sistemas modificados
- Configuración de acciones

**Escenarios de prueba:**
1. Presionar E múltiples veces rápidamente y verificar que solo funciona después del cooldown
2. Verificar que `defenseType` no se resetea durante la animación de dodge
3. Verificar que el estado se resetea cuando la animación termina
4. Intentar interrumpir el dodge con otras acciones y verificar que no se puede
5. Cambiar valores en `combat-actions-config.js` (cooldown, velocidad) y verificar que se aplican sin modificar código
6. Probar dodge con movimiento y sin movimiento

**Notas:**
- Ajustar valores de cooldown y velocidad según feedback de gameplay
- Verificar que no hay regresiones en otras acciones de combate

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-027_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- El sistema de cooldowns usa Map lookup (O(1)), eficiente
- No hay impacto significativo en rendimiento
- La configuración se carga una vez al inicio

### Compatibilidad
- Los cambios son compatibles con el sistema ECS existente
- Se agregan propiedades y métodos, no se modifican interfaces existentes
- Mantiene compatibilidad con sistema de combos existente

### Extensibilidad
- Agregar nuevas acciones solo requiere configuración en `combat-actions-config.js`
- Si la acción necesita un nuevo estado de animación, agregarlo en `animation-config.js` y referenciarlo
- Fácil agregar nuevas propiedades a la configuración sin duplicar información
- Preparado para futuras mejoras (i-frames, diferentes tipos de movimiento)

### Evitar Duplicación
- **Separación clara de responsabilidades:**
  - `animation-config.js`: Propiedades de animación (isOneShot, preventInterruption, animation, transitions)
  - `combat-actions-config.js`: Propiedades de combate (cooldown, movimiento, i-frames)
- **Referencias cruzadas:** `combat-actions-config.js` usa `animationStateId` para referenciar estados en `animation-config.js`
- **Helper function:** `getCompleteActionConfig()` combina ambas configuraciones cuando se necesita
- **Beneficio:** Cambiar propiedades de animación solo requiere modificar `animation-config.js`, no múltiples archivos

### Testing
- La configuración separada facilita testing unitario
- Se puede mockear la configuración fácilmente
- Los sistemas pueden testearse de forma independiente

## Patrones de Diseño Utilizados

### Configuration Pattern
- Separar datos de configuración de la lógica de código
- Todas las acciones definidas en `combat-actions-config.js`

### State Machine Pattern
- Estados claros: "inactivo", "en progreso", "en cooldown"
- `CombatComponent.activeAction` trackea el estado actual

### Strategy Pattern
- Diferentes estrategias de movimiento según tipo de acción
- `movementType` y `useMovementInput` en configuración

## Dependencias

### Dependencias Existentes
- Depende de: JDG-026 (Corrección de Inputs y Dodge Básico)

### Nuevas Dependencias
- Ninguna (solo archivos de configuración)

## Archivos Principales Involucrados

1. `frontend/src/config/combat-actions-config.js` - Configuración de acciones de combate (NUEVO)
   - Propiedades específicas de combate: cooldown, movimiento, i-frames
   - Referencia a `animation-config.js` via `animationStateId`
   - Helper `getCompleteActionConfig()` para combinar configuraciones
2. `frontend/src/config/animation-config.js` - Estados de animación (EXISTENTE, no modificar estructura)
   - Propiedades de animación: isOneShot, preventInterruption, animation, transitions
   - Referenciado por `combat-actions-config.js` para evitar duplicación
3. `frontend/src/ecs/components/combat.js` - Mejoras de estado persistente
4. `frontend/src/ecs/systems/combat-system.js` - Refactor para usar configuración
5. `frontend/src/ecs/systems/physics-system.js` - Refactor de movimiento
6. `frontend/src/ecs/systems/animation-mixer-system.js` - Detección de fin de animaciones

## Testing

### Tests a Crear/Modificar
- Unit tests para `CombatComponent` (métodos nuevos)
- Integration tests para sistema de cooldowns
- Integration tests para persistencia de estado durante animación

### Escenarios de Prueba
1. Dodge con cooldown funciona correctamente
2. Estado persiste durante animación
3. Estado se resetea cuando animación termina
4. Protección contra interrupciones funciona (viene de `animation-config.js`)
5. Cambiar valores en `combat-actions-config.js` (cooldown, velocidad) se refleja sin modificar código
6. Cambiar valores en `animation-config.js` (isOneShot, preventInterruption) se refleja sin duplicar código
7. `getCompleteActionConfig()` combina correctamente ambas configuraciones

## Deployment

### Orden de Deployment
1. Frontend: Rebuild Docker image y restart container
2. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar frontend en navegador
- [ ] Verificar que dodge funciona con cooldown
- [ ] Verificar que no hay regresiones en otras acciones
- [ ] Verificar logs de Docker

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. La migración puede hacerse incrementalmente, probando cada fase antes de continuar.

**⚠️ IMPORTANTE - Evitar Duplicación:**
- **NO duplicar propiedades** que ya existen en `animation-config.js` (isOneShot, preventInterruption, animation, transitions)
- **Usar referencias cruzadas** mediante `animationStateId` en `combat-actions-config.js`
- **Usar `getCompleteActionConfig()`** cuando se necesite la configuración completa que combina ambas
- **Separación clara:** `animation-config.js` = propiedades de animación, `combat-actions-config.js` = propiedades de combate

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

