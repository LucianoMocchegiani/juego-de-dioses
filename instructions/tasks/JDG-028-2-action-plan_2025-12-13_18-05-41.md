# JDG-028-2 - Optimización y Refactorización del Sistema de Animaciones y Combate

## Descripción de la Tarea

Optimizar el sistema de animaciones y combate mejorando performance mediante cacheo de componentes y configuraciones, y refactorizar el código extrayendo métodos privados y centralizando lógica para mejorar mantenibilidad y escalabilidad.

**Comportamiento actual:**
- Sistemas acceden a los mismos componentes múltiples veces en el mismo frame
- `CombatSystem` busca en arrays con `Array.find()` (O(n)) cada vez que se ejecuta una acción
- `AnimationMixerSystem.update()` tiene ~160 líneas con múltiples responsabilidades mezcladas
- Lógica de parry/dodge duplicada en dos lugares diferentes
- Magic values y strings hardcodeados dispersos en el código

**Comportamiento esperado:**
- Componentes se cachean al inicio del loop y se reutilizan
- Configuraciones se cachean en constructores (lookup O(1))
- Métodos grandes se dividen en métodos privados más pequeños y enfocados
- Lógica de parry/dodge centralizada en `CombatComponent`
- Constantes centralizadas en archivos de config

## Criterios de Aceptación

1. ✅ Componentes se cachean al inicio de loops en sistemas
2. ✅ `CombatSystem` usa cache de `ANIMATION_STATES` en lugar de `Array.find()`
3. ✅ `AnimationMixerSystem.update()` se divide en métodos privados más pequeños
4. ✅ `CombatComponent` tiene método `cleanupDefenseType()` para lógica de parry/dodge
5. ✅ Constantes centralizadas en archivo de config
6. ✅ Funcionalidad existente no se rompe (todas las animaciones funcionan)
7. ✅ Performance mejorado (menos accesos a componentes, lookups O(1))

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)

### Tecnologías Involucradas
- Frontend: JavaScript ES6+, Three.js
- ECS (Entity Component System)

## Pasos de Implementación

### Paso 1: Crear archivo de constantes centralizadas

**Descripción:**
Crear archivo para centralizar constantes de combate que están hardcodeadas en múltiples lugares.

**Archivos a crear:**
- `frontend/src/config/combat-constants.js`

**Detalles de implementación:**
```javascript
/**
 * Constantes centralizadas para sistema de combate
 */
export const COMBAT_CONSTANTS = {
    // Threshold para limpieza temprana de animaciones (95% de progreso)
    EARLY_CLEANUP_THRESHOLD: 0.95,
    
    // IDs de acciones de combate (para evitar strings hardcodeados)
    ACTION_IDS: {
        PARRY: 'parry',
        DODGE: 'dodge',
        SPECIAL_ATTACK: 'specialAttack',
        HEAVY_ATTACK: 'heavyAttack',
        CHARGED_ATTACK: 'chargedAttack',
        LIGHT_ATTACK: 'lightAttack',
    },
    
    // Tipos de armas (para validaciones)
    WEAPON_TYPES: {
        SWORD: 'sword',
        AXE: 'axe',
        HAMMER: 'hammer',
        GENERIC: 'generic',
    },
};
```

**Notas:**
- Centraliza valores mágicos y strings para evitar errores de tipeo
- Facilita cambios futuros (un solo lugar para modificar)

---

### Paso 2: Cachear configuraciones en `CombatSystem` constructor

**Descripción:**
Crear cache de `ANIMATION_STATES` en el constructor para evitar búsquedas O(n) repetidas.

**Archivos a modificar:**
- `frontend/src/ecs/systems/combat-system.js`

**Detalles de implementación:**
```javascript
// En constructor
constructor(inputManager) {
    super();
    this.inputManager = inputManager;
    this.requiredComponents = ['Input', 'Combat'];
    this.priority = 1.4;
    
    // Cachear mapeo de animationStateId → AnimationState (O(1) lookup)
    this.animationStateCache = new Map();
    for (const state of ANIMATION_STATES) {
        this.animationStateCache.set(state.id, state);
    }
}

// En applyActionConfig(), reemplazar:
// ANTES:
const animationState = ANIMATION_STATES.find(state => state.id === actionConfig.animationStateId);

// DESPUÉS:
const animationState = this.animationStateCache.get(actionConfig.animationStateId);
```

**Notas:**
- De O(n) a O(1) para búsqueda de estados de animación
- Se ejecuta una vez al crear el sistema, no cada frame

---

### Paso 3: Agregar método `cleanupDefenseType()` a `CombatComponent`

**Descripción:**
Centralizar la lógica de limpieza de `defenseType` para parry/dodge que está duplicada.

**Archivos a modificar:**
- `frontend/src/ecs/components/combat.js`

**Detalles de implementación:**
```javascript
/**
 * Limpiar defenseType según tipo de acción y estado del input
 * Centraliza la lógica especial para parry (mantener si tecla presionada) y dodge (siempre limpiar)
 * 
 * @param {string} actionId - ID de la acción que terminó
 * @param {Object|null} input - InputComponent o null
 */
cleanupDefenseType(actionId, input) {
    if (actionId === COMBAT_CONSTANTS.ACTION_IDS.PARRY) {
        // Parry: Solo limpiar si la tecla NO está presionada
        // Si está presionada, mantener para reactivación
        if (!input || !input.wantsToParry) {
            this.defenseType = null;
        }
        // Si está presionada, mantener defenseType = 'parry' para reactivación
    } else if (actionId === COMBAT_CONSTANTS.ACTION_IDS.DODGE) {
        // Dodge: Siempre limpiar (no debe reactivarse automáticamente)
        this.defenseType = null;
    } else {
        // Para otras acciones, limpiar normalmente
        this.defenseType = null;
    }
}
```

**Notas:**
- Centraliza lógica duplicada
- Usa constantes en lugar de strings hardcodeados
- Más fácil de testear y mantener

---

### Paso 4: Actualizar `CombatSystem.canExecuteAction()` para usar constantes

**Descripción:**
Reemplazar strings hardcodeados con constantes centralizadas.

**Archivos a modificar:**
- `frontend/src/ecs/systems/combat-system.js`

**Detalles de implementación:**
```javascript
// Importar constantes al inicio
import { COMBAT_CONSTANTS } from '../../config/combat-constants.js';

// En canExecuteAction(), reemplazar:
// ANTES:
if (actionConfig.id === 'parry' && !weapon) {
    return false;
}
if (actionConfig.id === 'specialAttack' && weaponType !== 'sword') {
    return false;
}

// DESPUÉS:
if (actionConfig.id === COMBAT_CONSTANTS.ACTION_IDS.PARRY && !weapon) {
    return false;
}
if (actionConfig.id === COMBAT_CONSTANTS.ACTION_IDS.SPECIAL_ATTACK && 
    weaponType !== COMBAT_CONSTANTS.WEAPON_TYPES.SWORD) {
    return false;
}
```

**Notas:**
- Usa constantes centralizadas
- Evita errores de tipeo
- Más fácil de cambiar en el futuro

---

### Paso 5: Extraer método `updateCombatAction()` en `AnimationMixerSystem`

**Descripción:**
Extraer la lógica de actualización de acciones de combate (i-frames, early cleanup, final cleanup) a un método privado separado.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// Importar constantes
import { COMBAT_CONSTANTS } from '../../config/combat-constants.js';

/**
 * @private
 * Actualizar acciones de combate en progreso (i-frames, limpieza temprana, limpieza final)
 * 
 * @param {number} entityId - ID de la entidad
 * @param {Object} combat - CombatComponent
 * @param {Object|null} input - InputComponent o null
 * @param {Object} anim - AnimationComponent
 * @param {THREE.Object3D} mesh - Mesh del modelo
 * @param {THREE.AnimationAction} action - Acción de combate activa
 */
updateCombatAction(entityId, combat, input, anim, mesh, action) {
    const actionDuration = action.getClip().duration;
    const progress = actionDuration > 0 ? action.time / actionDuration : 1.0;
    
    if (!combat.activeAction) return;
    
    const combatConfig = COMBAT_ACTIONS[combat.activeAction];
    const finishedActionId = combat.activeAction;
    
    // Actualizar i-frames si corresponde
    if (combatConfig && combatConfig.hasIFrames) {
        combat.hasIFrames = progress >= combatConfig.iFrameStart && 
                           progress <= combatConfig.iFrameEnd;
    }
    
    // Early cleanup: Limpiar defenseType antes de que termine completamente
    const shouldEarlyCleanup = progress >= COMBAT_CONSTANTS.EARLY_CLEANUP_THRESHOLD && progress < 1.0;
    if (shouldEarlyCleanup && (finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.PARRY || 
                               finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.DODGE)) {
        combat.cleanupDefenseType(finishedActionId, input);
    }
    
    // Verificar si la animación terminó completamente
    const animationFinished = progress >= 1.0 || (!action.isRunning() && action.time >= actionDuration);
    
    if (animationFinished) {
        this.cleanupFinishedCombatAction(entityId, finishedActionId, combat, input, anim, mesh);
    }
}
```

**Notas:**
- Extrae lógica compleja a método privado
- Usa componentes ya cacheados (no accede a ECS dentro del método)
- Usa constantes centralizadas

---

### Paso 6: Extraer método `cleanupFinishedCombatAction()` en `AnimationMixerSystem`

**Descripción:**
Extraer la lógica de limpieza cuando termina una animación de combate a un método privado separado.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
/**
 * @private
 * Limpiar estado cuando termina una animación de combate
 * 
 * @param {number} entityId - ID de la entidad
 * @param {string} finishedActionId - ID de la acción que terminó
 * @param {Object} combat - CombatComponent
 * @param {Object|null} input - InputComponent o null
 * @param {Object} anim - AnimationComponent
 * @param {THREE.Object3D} mesh - Mesh del modelo
 */
cleanupFinishedCombatAction(entityId, finishedActionId, combat, input, anim, mesh) {
    // Guardar si parry todavía se quiere (para reactivación)
    const parryStillWanted = finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.PARRY && 
                             input && input.wantsToParry;
    
    // Limpiar todo el estado de combate
    combat.clearCombatState();
    
    // Lógica especial por tipo de acción usando el helper centralizado
    if (parryStillWanted) {
        // Mantener defenseType para reactivación
        combat.defenseType = COMBAT_CONSTANTS.ACTION_IDS.PARRY;
    } else {
        // Limpiar defenseType según tipo de acción (usando helper)
        combat.cleanupDefenseType(finishedActionId, input);
    }
    
    // Resetear wantsToDodge para evitar reactivación
    if (finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.DODGE && input) {
        input.wantsToDodge = false;
    }
    
    // Cambiar estado de animación a idle
    if (anim) {
        anim.currentState = 'idle';
    }
    
    // Limpiar referencias en mesh
    mesh.userData.combatAction = null;
    mesh.userData.isAttacking = false;
    
    // Resetear flag de movimiento aplicado
    if (mesh.userData.movementApplied !== undefined) {
        mesh.userData.movementApplied = false;
    }
}
```

**Notas:**
- Usa el helper `cleanupDefenseType()` de `CombatComponent`
- Centraliza toda la lógica de limpieza
- Usa constantes en lugar de strings hardcodeados

---

### Paso 7: Cachear componentes en `AnimationMixerSystem.update()`

**Descripción:**
Cachear todos los componentes al inicio del loop para evitar accesos repetidos.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
update(deltaTime) {
    const entities = this.getEntities();

    for (const entityId of entities) {
        // Cachear componentes una sola vez al inicio
        const render = this.ecs.getComponent(entityId, 'Render');
        const animation = this.ecs.getComponent(entityId, 'Animation');
        const combat = this.ecs.getComponent(entityId, 'Combat');
        const input = this.ecs.getComponent(entityId, 'Input');
        const combo = this.ecs.getComponent(entityId, 'Combo');
        
        if (!render || !render.mesh || !animation) continue;

        const mesh = render.mesh;
        mesh.userData.entityId = entityId; // Guardar referencia para uso posterior

        // Inicializar mixer si no existe
        if (!mesh.userData.animationMixer) {
            this.initializeMixer(entityId, mesh).then(() => {
                if (mesh.userData.animationMixer && mesh.userData.animationClips) {
                    this.playAnimation(
                        mesh.userData.animationMixer,
                        mesh.userData.animationClips,
                        animation.currentState,
                        mesh
                    );
                }
            });
            continue;
        }

        // Actualizar mixer
        const mixer = mesh.userData.animationMixer;
        mixer.update(deltaTime);

        // Verificar si acciones de combate terminaron (usando método extraído)
        if (mesh.userData.combatAction) {
            const action = mesh.userData.combatAction;
            this.updateCombatAction(entityId, combat, input, animation, mesh, action);
        }

        // Reproducir animación según estado
        const clips = mesh.userData.animationClips;
        if (clips) {
            const animationName = this.resolveAnimationName(entityId, animation.currentState);
            const stateToUse = animation.currentState;

            if (animationName && clips[animationName]) {
                this.playAnimation(mixer, clips, stateToUse, mesh);
            } else if (clips[ANIMATION_MIXER.defaultState]) {
                this.playAnimation(mixer, clips, ANIMATION_MIXER.defaultState, mesh);
            }
        }
    }
}
```

**Notas:**
- Todos los componentes se cachean una vez al inicio
- Métodos privados reciben componentes cacheados como parámetros
- Reduce accesos a componentes en ~50% en algunos casos

---

### Paso 8: Actualizar `resolveAnimationName()` para usar componentes cacheados

**Descripción:**
Modificar `resolveAnimationName()` para aceptar componentes como parámetros en lugar de hacer lookups internos, cuando sea posible.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// Opción A: Mantener como está (se llama desde update donde ya tenemos componentes)
// Pero optimizar para que si se pasa combo/combat como parámetros opcionales, los use

// Opción B: Crear método sobrecargado que acepta componentes
/**
 * Resolver nombre de animación desde componentes fuente según prioridad
 * Prioridad: Combo > Combate > Normal (config)
 * 
 * @param {number} entityId - ID de la entidad
 * @param {string} stateId - ID del estado actual
 * @param {Object|null} combo - ComboComponent (opcional, si ya está cacheado)
 * @param {Object|null} combat - CombatComponent (opcional, si ya está cacheado)
 * @returns {string|null} Nombre de la animación o null si no se encuentra
 */
resolveAnimationName(entityId, stateId, combo = null, combat = null) {
    // Prioridad 1: Combo (si hay combo activo)
    const comboComp = combo || this.ecs.getComponent(entityId, 'Combo');
    if (comboComp?.activeComboId && comboComp?.comboAnimation) {
        return comboComp.comboAnimation;
    }
    
    // Prioridad 2: Combate (si hay acción activa)
    const combatComp = combat || this.ecs.getComponent(entityId, 'Combat');
    if (combatComp?.activeAction && combatComp?.combatAnimation) {
        return combatComp.combatAnimation;
    }
    
    // Prioridad 3: Resolver desde configuración (estado normal)
    return this.getAnimationNameForState(stateId);
}

// En update(), pasar componentes cacheados:
const animationName = this.resolveAnimationName(entityId, animation.currentState, combo, combat);
```

**Notas:**
- Permite pasar componentes ya cacheados para evitar lookups adicionales
- Mantiene compatibilidad hacia atrás (si no se pasan, los busca)
- Reduce accesos cuando se llama desde `update()`

---

### Paso 9: Actualizar `AnimationMixerSystem` para usar constantes

**Descripción:**
Reemplazar magic values y strings hardcodeados con constantes centralizadas.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// Importar constantes al inicio
import { COMBAT_CONSTANTS } from '../../config/combat-constants.js';

// Reemplazar:
// ANTES:
const EARLY_CLEANUP_THRESHOLD = 0.95;
if (finishedActionId === 'parry' || finishedActionId === 'dodge') {

// DESPUÉS:
// Usar COMBAT_CONSTANTS.EARLY_CLEANUP_THRESHOLD
if (finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.PARRY || 
    finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.DODGE) {
```

**Notas:**
- Usa constantes centralizadas
- Elimina magic values del código

---

### Paso 10: Actualizar `CombatSystem` para resetear wantsToDodge con constante

**Descripción:**
Reemplazar string hardcodeado con constante al resetear `wantsToDodge`.

**Archivos a modificar:**
- `frontend/src/ecs/systems/combat-system.js`

**Detalles de implementación:**
```javascript
// En update(), reemplazar:
// ANTES:
if (actionId === 'dodge') {
    input.wantsToDodge = false;
}

// DESPUÉS:
if (actionId === COMBAT_CONSTANTS.ACTION_IDS.DODGE) {
    input.wantsToDodge = false;
}
```

**Notas:**
- Usa constante en lugar de string hardcodeado
- Consistencia con el resto del código

---

### Paso 11: Verificar y actualizar imports en archivos modificados

**Descripción:**
Asegurar que todos los archivos importan correctamente las nuevas constantes y dependencias.

**Archivos a verificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`
- `frontend/src/ecs/systems/combat-system.js`
- `frontend/src/ecs/components/combat.js`

**Detalles de implementación:**
- Verificar que `COMBAT_CONSTANTS` está importado donde se usa
- Verificar que `COMBAT_ACTIONS` está importado donde se necesita
- Verificar que no hay imports duplicados o faltantes

**Notas:**
- Asegurar consistencia en imports
- Evitar dependencias circulares

---

### Paso 12: Testing y Verificación

**Descripción:**
Verificar que todas las optimizaciones funcionan correctamente y no rompen funcionalidad existente.

**Tests a realizar:**
1. ✅ Todas las animaciones funcionan correctamente (idle, walk, run, jump, crouch)
2. ✅ Animaciones de combate funcionan (attack, parry, dodge)
3. ✅ Animaciones de combo funcionan
4. ✅ Parry se reactiva si la tecla sigue presionada
5. ✅ Dodge solo se activa una vez por press
6. ✅ Cooldowns funcionan correctamente
7. ✅ I-frames se actualizan correctamente (si se usan en el futuro)
8. ✅ Performance mejorado (menos accesos a componentes verificable en código)
9. ✅ No hay errores de lint
10. ✅ No hay errores en consola del navegador

**Notas:**
- Probar cada tipo de animación manualmente
- Verificar que la funcionalidad es idéntica a antes
- Confirmar que el código es más limpio y mantenible

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-028-2_pr-description_[FECHA-HORA].md` en `/instructions/prs/`
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git

---

## Consideraciones Técnicas

### Performance

**Impacto esperado:**
- ✅ **Mejor:** ~30-50% reducción en accesos a componentes (cacheo)
- ✅ **Mejor:** Lookups O(1) en lugar de O(n) para estados de animación
- ✅ **Mejor:** Menos overhead en loops
- ⚠️ **Neutro:** Métodos adicionales pueden tener pequeño overhead de call stack, pero compensado por menos accesos

**Resultado neto:** Performance igual o mejor.

### Compatibilidad

**✅ No rompe funcionalidad existente:**
- Optimizaciones son internas (cacheo, extracción de métodos)
- APIs públicas no cambian
- Cambios son incrementales y seguros

**✅ Compatible con sistemas existentes:**
- No afecta otros sistemas
- Componentes mantienen misma interfaz
- Configuraciones no cambian

### Casos Edge

- ✅ Entidades sin componentes requeridos (ya se maneja con `continue`)
- ✅ Componentes que se eliminan durante el frame (cache puede estar obsoleto, pero se verifica en cada acceso)
- ✅ Múltiples entidades (cacheo ayuda en lugar de perjudicar)

### Testing

**Escenarios críticos:**
1. Animaciones normales cuando hay múltiples entidades
2. Acciones de combate rápidas (parry, dodge)
3. Transiciones entre estados
4. Limpieza correcta cuando terminan animaciones
5. Cooldowns funcionando correctamente

## Archivos Principales Involucrados

1. `frontend/src/config/combat-constants.js` - Nuevo archivo de constantes
2. `frontend/src/ecs/components/combat.js` - Agregar método `cleanupDefenseType()`
3. `frontend/src/ecs/systems/combat-system.js` - Cacheo de configs, usar constantes
4. `frontend/src/ecs/systems/animation-mixer-system.js` - Cacheo de componentes, extraer métodos, usar constantes

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

