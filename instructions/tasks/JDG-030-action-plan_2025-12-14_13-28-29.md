# JDG-030 - Sistema de Debugging y Herramientas de Desarrollo

## Descripción de la Tarea

Implementar un sistema completo de debugging y herramientas de desarrollo para facilitar el debugging, la inspección de estado, la validación y el monitoreo de performance del juego. El sistema debe ser completamente opcional y no afectar el performance en producción.

**Comportamiento actual:**
- No hay sistema estructurado de logging (solo `console.warn`/`console.error` esporádicos)
- No hay forma de inspeccionar el estado de entidades y componentes en runtime
- Métricas de performance limitadas (solo FPS y draw calls)
- No hay validación de estados inválidos
- No hay herramientas visuales para debugging
- No hay sistema de eventos estructurado

**Comportamiento esperado:**
- Sistema de logging estructurado con niveles y contexto
- Inspector de estado ECS para ver entidades y componentes en tiempo real
- Métricas detalladas de performance por sistema
- Validación de estado con warnings claros
- Sistema de eventos para timeline de debugging
- Panel de debugging visual en UI (opcional, activable con F3)

## Criterios de Aceptación

1. ✅ Sistema de logging estructurado funcionando con niveles (debug, info, warn, error)
2. ✅ Validación de estado detecta estados inválidos y muestra warnings
3. ✅ Inspector de estado puede inspeccionar entidades y componentes
4. ✅ Métricas detalladas muestran frame time por sistema
5. ✅ Sistema de eventos emite y registra eventos para debugging
6. ✅ Panel de debugging UI muestra métricas en tiempo real (opcional)
7. ✅ Todas las herramientas son opcionales y no afectan performance cuando están deshabilitadas
8. ✅ Documentación completa en READMEs

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)
- [ ] Backend (FastAPI)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js
- ECS: Sistema Entity Component System personalizado
- Performance API: `performance.now()` para mediciones

## Pasos de Implementación

### Paso 1: Crear Estructura de Carpetas y Configuración

**Descripción:**
Crear la estructura de carpetas para el sistema de debugging y el archivo de configuración centralizado.

**Archivos a modificar/crear:**
- `frontend/src/debug/config.js` (crear)
- `frontend/src/debug/README.md` (crear)

**Detalles de implementación:**
```javascript
// frontend/src/debug/config.js
/**
 * Configuración centralizada del sistema de debugging
 */
export const DEBUG_CONFIG = {
    // Habilitar debugging (por defecto solo en desarrollo)
    enabled: typeof process !== 'undefined' && process.env?.NODE_ENV === 'development',
    
    // Nivel de log por defecto
    defaultLogLevel: 'info', // 'debug' | 'info' | 'warn' | 'error'
    
    // Configuración de logger
    logger: {
        enabled: true,
        level: 'info',
        showTimestamp: true,
        showSystem: true
    },
    
    // Configuración de inspector
    inspector: {
        enabled: true,
        cacheEnabled: true,
        maxCacheSize: 100
    },
    
    // Configuración de métricas
    metrics: {
        enabled: true,
        sampleRate: 1, // 1 = cada frame, 0.1 = cada 10 frames
        maxHistorySize: 100
    },
    
    // Configuración de validación
    validator: {
        enabled: true,
        warnOnInvalid: true
    },
    
    // Configuración de eventos
    events: {
        enabled: true,
        maxHistorySize: 1000
    },
    
    // Configuración de UI
    ui: {
        enabled: true,
        toggleKey: 'F3',
        autoUpdateInterval: 1000 // ms
    }
};
```

**Notas:**
- Crear carpeta `frontend/src/debug/`
- **⚠️ READMEs:** Crear `frontend/src/debug/README.md` explicando la estructura del sistema de debugging

---

### Paso 2: Implementar Sistema de Logging Estructurado

**Descripción:**
Crear `DebugLogger` con niveles de log, contexto estructurado y filtrado.

**Archivos a modificar/crear:**
- `frontend/src/debug/logger.js` (crear)
- `frontend/src/debug/README.md` (actualizar)

**Detalles de implementación:**
```javascript
// frontend/src/debug/logger.js
import { DEBUG_CONFIG } from './config.js';

/**
 * Sistema de logging estructurado para debugging
 */
export class DebugLogger {
    constructor(options = {}) {
        const config = { ...DEBUG_CONFIG.logger, ...options };
        this.enabled = config.enabled && DEBUG_CONFIG.enabled;
        this.level = config.level || 'info';
        this.showTimestamp = config.showTimestamp ?? true;
        this.showSystem = config.showSystem ?? true;
        this.filters = options.filters || {}; // { system: 'AnimationMixer', level: 'warn' }
        this.subscribers = [];
        
        // Niveles de log ordenados por severidad
        this.levels = {
            debug: 0,
            info: 1,
            warn: 2,
            error: 3
        };
    }
    
    /**
     * Verificar si se debe loguear según nivel y filtros
     * @param {string} level - Nivel de log
     * @param {string} system - Nombre del sistema
     * @returns {boolean} Si se debe loguear
     */
    shouldLog(level, system) {
        if (!this.enabled) return false;
        
        // Verificar nivel mínimo
        if (this.levels[level] < this.levels[this.level]) {
            return false;
        }
        
        // Verificar filtros
        if (this.filters.system && this.filters.system !== system) {
            return false;
        }
        if (this.filters.level && this.filters.level !== level) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Log con contexto estructurado
     * @param {string} level - Nivel de log
     * @param {string} system - Nombre del sistema
     * @param {string} message - Mensaje
     * @param {Object} data - Datos adicionales
     */
    log(level, system, message, data = {}) {
        if (!this.shouldLog(level, system)) return;
        
        const logEntry = {
            timestamp: performance.now(),
            timestampISO: new Date().toISOString(),
            level,
            system,
            message,
            data,
            stack: level === 'error' ? new Error().stack : undefined
        };
        
        // Notificar a suscriptores (UI, archivo, etc.)
        this.notifySubscribers(logEntry);
        
        // Log a consola
        const consoleMethod = console[level] || console.log;
        const prefix = this.buildPrefix(system, level);
        consoleMethod(prefix, message, data);
    }
    
    /**
     * Construir prefijo para log
     * @param {string} system - Nombre del sistema
     * @param {string} level - Nivel de log
     * @returns {string} Prefijo formateado
     */
    buildPrefix(system, level) {
        const parts = [];
        
        if (this.showTimestamp) {
            const time = new Date().toLocaleTimeString();
            parts.push(`[${time}]`);
        }
        
        if (this.showSystem) {
            parts.push(`[${system}]`);
        }
        
        parts.push(`[${level.toUpperCase()}]`);
        
        return parts.join(' ');
    }
    
    /**
     * Notificar a suscriptores
     * @param {Object} logEntry - Entrada de log
     */
    notifySubscribers(logEntry) {
        this.subscribers.forEach(callback => {
            try {
                callback(logEntry);
            } catch (error) {
                console.error('Error in logger subscriber:', error);
            }
        });
    }
    
    // Helpers para cada nivel
    debug(system, message, data) { 
        this.log('debug', system, message, data); 
    }
    
    info(system, message, data) { 
        this.log('info', system, message, data); 
    }
    
    warn(system, message, data) { 
        this.log('warn', system, message, data); 
    }
    
    error(system, message, data) { 
        this.log('error', system, message, data); 
    }
    
    /**
     * Suscribirse a logs (para UI o archivos)
     * @param {Function} callback - Función callback que recibe logEntry
     */
    subscribe(callback) {
        this.subscribers.push(callback);
    }
    
    /**
     * Desuscribirse de logs
     * @param {Function} callback - Función callback a remover
     */
    unsubscribe(callback) {
        const index = this.subscribers.indexOf(callback);
        if (index > -1) {
            this.subscribers.splice(index, 1);
        }
    }
    
    /**
     * Configurar filtros
     * @param {Object} filters - Filtros { system, level }
     */
    setFilters(filters) {
        this.filters = { ...this.filters, ...filters };
    }
    
    /**
     * Habilitar/deshabilitar logger
     * @param {boolean} enabled - Si está habilitado
     */
    setEnabled(enabled) {
        this.enabled = enabled && DEBUG_CONFIG.enabled;
    }
}

// Singleton global
export const debugLogger = new DebugLogger();
```

**Notas:**
- El logger debe ser completamente opcional (no afecta performance cuando está deshabilitado)
- Usar `performance.now()` para timestamps precisos
- **⚠️ READMEs:** Actualizar `frontend/src/debug/README.md` con documentación del logger

---

### Paso 3: Integrar Logger en Sistemas Críticos

**Descripción:**
Integrar `DebugLogger` en sistemas críticos (AnimationMixerSystem, CombatSystem) reemplazando logs esporádicos.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js` (modificar)
- `frontend/src/ecs/systems/combat-system.js` (modificar)

**Detalles de implementación:**
```javascript
// frontend/src/ecs/systems/animation-mixer-system.js
import { debugLogger } from '../../debug/logger.js';

export class AnimationMixerSystem extends System {
    // ... código existente ...
    
    resolveAnimationName(entityId, stateId, combo = null, combat = null) {
        const stateConfig = this.stateConfigMap.get(stateId);
        if (!stateConfig) {
            debugLogger.warn('AnimationMixer', 'State not found in ANIMATION_STATES', {
                entityId,
                stateId,
                availableStates: Array.from(this.stateConfigMap.keys())
            });
            return null;
        }
        
        // ... resto del código existente ...
        
        const animationName = this.getAnimationNameForState(stateId);
        
        debugLogger.debug('AnimationMixer', 'Resolved animation name', {
            entityId,
            stateId,
            animationName
        });
        
        return animationName;
    }
    
    // Agregar logs en otros puntos clave:
    // - Cuando se carga una animación
    // - Cuando se reproduce una animación
    // - Cuando hay errores al cargar
    // - Cuando se limpia estado de combate
}
```

```javascript
// frontend/src/ecs/systems/combat-system.js
import { debugLogger } from '../../debug/logger.js';

export class CombatSystem extends System {
    // ... código existente ...
    
    applyActionConfig(combat, actionConfig) {
        const animationState = this.animationStateCache.get(actionConfig.animationStateId);
        if (!animationState) {
            debugLogger.warn('CombatSystem', 'Animation state not found', {
                actionId: actionConfig.id,
                animationStateId: actionConfig.animationStateId,
                availableStates: Array.from(this.animationStateCache.keys())
            });
            return;
        }
        
        // ... resto del código existente ...
        
        debugLogger.info('CombatSystem', 'Action started', {
            actionId: actionConfig.id,
            animationStateId: actionConfig.animationStateId
        });
    }
    
    // Agregar logs en otros puntos clave:
    // - Cuando se inicia una acción
    // - Cuando se termina una acción
    // - Cuando hay cooldowns
    // - Cuando se resetea estado
}
```

**Notas:**
- Reemplazar `console.warn`/`console.error` existentes con `debugLogger`
- Agregar logs informativos en puntos clave del flujo
- No agregar demasiados logs en hot paths (solo cuando sea necesario)

---

### Paso 4: Implementar Validación de Estado

**Descripción:**
Crear `StateValidator` para validar estados inválidos y mostrar warnings claros.

**Archivos a modificar/crear:**
- `frontend/src/debug/validator.js` (crear)
- `frontend/src/debug/README.md` (actualizar)
- `frontend/src/ecs/systems/animation-mixer-system.js` (modificar)
- `frontend/src/ecs/systems/combat-system.js` (modificar)

**Detalles de implementación:**
```javascript
// frontend/src/debug/validator.js
import { DEBUG_CONFIG } from './config.js';
import { debugLogger } from './logger.js';

/**
 * Validador de estado para detectar estados inválidos
 */
export class StateValidator {
    constructor(options = {}) {
        const config = { ...DEBUG_CONFIG.validator, ...options };
        this.enabled = config.enabled && DEBUG_CONFIG.enabled;
        this.warnOnInvalid = config.warnOnInvalid ?? true;
        this.validators = new Map();
    }
    
    /**
     * Registrar validador personalizado
     * @param {string} type - Tipo de estado
     * @param {Function} validator - Función validadora (value, context) => boolean
     */
    registerValidator(type, validator) {
        this.validators.set(type, validator);
    }
    
    /**
     * Validar estado de animación
     * @param {string} stateId - ID del estado
     * @param {Map|Object} validStates - Map u objeto de estados válidos
     * @param {string} context - Contexto (sistema, entidad)
     * @returns {boolean} Si es válido
     */
    validateAnimationState(stateId, validStates, context = '') {
        if (!this.enabled) return true;
        
        const isValid = validStates instanceof Map 
            ? validStates.has(stateId)
            : stateId in validStates;
        
        if (!isValid) {
            if (this.warnOnInvalid) {
                const validStatesList = validStates instanceof Map
                    ? Array.from(validStates.keys())
                    : Object.keys(validStates);
                
                debugLogger.warn('StateValidator', 'Invalid animation state', {
                    stateId,
                    context,
                    validStates: validStatesList
                });
            }
            return false;
        }
        return true;
    }
    
    /**
     * Validar acción de combate
     * @param {string} actionId - ID de la acción
     * @param {Object} validActions - Objeto de acciones válidas
     * @param {string} context - Contexto
     * @returns {boolean} Si es válido
     */
    validateCombatAction(actionId, validActions, context = '') {
        if (!this.enabled) return true;
        
        if (!validActions[actionId]) {
            if (this.warnOnInvalid) {
                debugLogger.warn('StateValidator', 'Invalid combat action', {
                    actionId,
                    context,
                    validActions: Object.keys(validActions)
                });
            }
            return false;
        }
        return true;
    }
    
    /**
     * Validar componente
     * @param {number} entityId - ID de la entidad
     * @param {string} componentType - Tipo de componente
     * @param {Object} component - Componente
     * @param {Object} schema - Esquema de validación { required: [...], optional: [...] }
     * @returns {boolean} Si es válido
     */
    validateComponent(entityId, componentType, component, schema) {
        if (!this.enabled) return true;
        
        // Validar propiedades requeridas
        for (const prop of schema.required || []) {
            if (!(prop in component)) {
                if (this.warnOnInvalid) {
                    debugLogger.warn('StateValidator', 'Missing required property', {
                        entityId,
                        componentType,
                        property: prop
                    });
                }
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Habilitar/deshabilitar validador
     * @param {boolean} enabled - Si está habilitado
     */
    setEnabled(enabled) {
        this.enabled = enabled && DEBUG_CONFIG.enabled;
    }
}

// Singleton global
export const stateValidator = new StateValidator();
```

**Integración en sistemas:**
```javascript
// frontend/src/ecs/systems/animation-mixer-system.js
import { stateValidator } from '../../debug/validator.js';

resolveAnimationName(entityId, stateId) {
    // Validar estado antes de procesar
    if (!stateValidator.validateAnimationState(
        stateId,
        this.stateConfigMap,
        `AnimationMixer.resolveAnimationName(${entityId})`
    )) {
        return null;
    }
    
    // ... resto del código ...
}
```

```javascript
// frontend/src/ecs/systems/combat-system.js
import { stateValidator } from '../../debug/validator.js';

applyActionConfig(combat, actionConfig) {
    // Validar que la acción existe
    if (!stateValidator.validateCombatAction(
        actionConfig.id,
        COMBAT_ACTIONS,
        `CombatSystem.applyActionConfig(${actionConfig.id})`
    )) {
        return;
    }
    
    // Validar que el estado de animación existe
    const animationState = this.animationStateCache.get(actionConfig.animationStateId);
    if (!animationState) {
        // Ya validado por validator, solo retornar
        return;
    }
    
    // ... resto del código ...
}
```

**Notas:**
- La validación debe ser completamente opcional (no afecta performance cuando está deshabilitada)
- Usar `debugLogger` para warnings en lugar de `console.warn` directo
- **⚠️ READMEs:** Actualizar `frontend/src/debug/README.md` con documentación del validador

---

### Paso 5: Implementar Inspector de Estado ECS

**Descripción:**
Crear `ECSInspector` para inspeccionar entidades, componentes y estadísticas del ECS en tiempo real.

**Archivos a modificar/crear:**
- `frontend/src/debug/inspector.js` (crear)
- `frontend/src/debug/README.md` (actualizar)
- `frontend/src/ecs/manager.js` (modificar - agregar método getComponentTypes y getSystems)

**Detalles de implementación:**
```javascript
// frontend/src/debug/inspector.js
import { DEBUG_CONFIG } from './config.js';

/**
 * Inspector de estado ECS para debugging
 */
export class ECSInspector {
    constructor(ecs) {
        this.ecs = ecs;
        const config = DEBUG_CONFIG.inspector;
        this.enabled = config.enabled && DEBUG_CONFIG.enabled;
        this.cacheEnabled = config.cacheEnabled ?? true;
        this.maxCacheSize = config.maxCacheSize ?? 100;
        this.cache = new Map(); // Cache de inspecciones
    }
    
    /**
     * Obtener información de una entidad
     * @param {number} entityId - ID de la entidad
     * @returns {Object|null} Información de la entidad o null si está deshabilitado
     */
    inspectEntity(entityId) {
        if (!this.enabled) return null;
        
        // Verificar cache
        if (this.cacheEnabled && this.cache.has(entityId)) {
            return this.cache.get(entityId);
        }
        
        const components = {};
        const componentTypes = this.ecs.getComponentTypes();
        
        for (const componentType of componentTypes) {
            const component = this.ecs.getComponent(entityId, componentType);
            if (component) {
                components[componentType] = this.serializeComponent(component);
            }
        }
        
        const info = {
            entityId,
            components,
            componentCount: Object.keys(components).length
        };
        
        // Guardar en cache
        if (this.cacheEnabled) {
            this.cache.set(entityId, info);
            // Limitar tamaño del cache
            if (this.cache.size > this.maxCacheSize) {
                const firstKey = this.cache.keys().next().value;
                this.cache.delete(firstKey);
            }
        }
        
        return info;
    }
    
    /**
     * Buscar entidades por componente o valor
     * @param {Object} query - Query de búsqueda { hasComponent, componentValue, etc. }
     * @returns {Array} Entidades que coinciden
     */
    findEntities(query) {
        if (!this.enabled) return [];
        
        const results = [];
        const entities = this.ecs.query();
        
        for (const entityId of entities) {
            const info = this.inspectEntity(entityId);
            if (this.matchesQuery(info, query)) {
                results.push(info);
            }
        }
        
        return results;
    }
    
    /**
     * Verificar si una entidad coincide con la query
     * @param {Object} info - Información de la entidad
     * @param {Object} query - Query de búsqueda
     * @returns {boolean} Si coincide
     */
    matchesQuery(info, query) {
        // Buscar por componente
        if (query.hasComponent) {
            if (!(query.hasComponent in info.components)) {
                return false;
            }
        }
        
        // Buscar por valor de componente
        if (query.componentValue) {
            const { componentType, property, value } = query.componentValue;
            const component = info.components[componentType];
            if (!component || component[property] !== value) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Obtener estadísticas del ECS
     * @returns {Object|null} Estadísticas o null si está deshabilitado
     */
    getStats() {
        if (!this.enabled) return null;
        
        const entities = this.ecs.query();
        const componentCounts = {};
        const componentTypes = this.ecs.getComponentTypes();
        
        // Inicializar contadores
        for (const componentType of componentTypes) {
            componentCounts[componentType] = 0;
        }
        
        // Contar componentes
        for (const entityId of entities) {
            for (const componentType of componentTypes) {
                if (this.ecs.hasComponent(entityId, componentType)) {
                    componentCounts[componentType]++;
                }
            }
        }
        
        return {
            totalEntities: entities.size,
            componentCounts,
            systems: this.ecs.getSystems().map(s => ({
                name: s.constructor.name,
                enabled: s.enabled,
                priority: s.priority
            }))
        };
    }
    
    /**
     * Serializar componente de forma segura
     * @param {Object} component - Componente a serializar
     * @returns {Object} Componente serializado
     */
    serializeComponent(component) {
        const serialized = {};
        for (const key in component) {
            if (key === 'mesh' || key === 'userData') {
                // Omitir objetos Three.js grandes
                serialized[key] = '[Object]';
            } else if (typeof component[key] === 'object' && component[key] !== null) {
                // Serializar objetos simples
                try {
                    serialized[key] = JSON.parse(JSON.stringify(component[key]));
                } catch (e) {
                    serialized[key] = '[Object]';
                }
            } else {
                serialized[key] = component[key];
            }
        }
        return serialized;
    }
    
    /**
     * Limpiar cache
     */
    clearCache() {
        this.cache.clear();
    }
    
    /**
     * Habilitar/deshabilitar inspector
     * @param {boolean} enabled - Si está habilitado
     */
    setEnabled(enabled) {
        this.enabled = enabled && DEBUG_CONFIG.enabled;
    }
}
```

**Agregar métodos necesarios en ECSManager:**
```javascript
// frontend/src/ecs/manager.js
// Agregar estos métodos si no existen:

/**
 * Obtener tipos de componentes disponibles
 * @returns {Array<string>} Array de tipos de componentes
 */
getComponentTypes() {
    return Array.from(this.components.keys());
}

/**
 * Obtener sistemas registrados
 * @returns {Array<System>} Array de sistemas
 */
getSystems() {
    return [...this.systems];
}
```

**Notas:**
- El inspector debe ser completamente opcional
- Cachear inspecciones para mejorar performance
- Omitir objetos grandes (meshes Three.js) en serialización
- **⚠️ READMEs:** Actualizar `frontend/src/debug/README.md` con documentación del inspector

---

### Paso 6: Implementar Sistema de Métricas Detalladas

**Descripción:**
Crear `DebugMetrics` para medir frame time por sistema y otras métricas detalladas de performance.

**Archivos a modificar/crear:**
- `frontend/src/debug/metrics.js` (crear)
- `frontend/src/debug/README.md` (actualizar)
- `frontend/src/ecs/manager.js` (modificar - integrar métricas en update)
- `frontend/src/app.js` (modificar - inicializar métricas)

**Detalles de implementación:**
```javascript
// frontend/src/debug/metrics.js
import { DEBUG_CONFIG } from './config.js';

/**
 * Sistema de métricas detalladas para debugging
 */
export class DebugMetrics {
    constructor(ecs) {
        this.ecs = ecs;
        const config = DEBUG_CONFIG.metrics;
        this.enabled = config.enabled && DEBUG_CONFIG.enabled;
        this.sampleRate = config.sampleRate ?? 1; // 1 = cada frame, 0.1 = cada 10 frames
        this.maxHistorySize = config.maxHistorySize ?? 100;
        this.frameCount = 0;
        
        this.metrics = {
            frameTime: [],
            systemTimes: new Map(), // systemName -> [times]
            entityCounts: new Map() // systemName -> [counts]
        };
        
        this.currentFrame = {
            startTime: 0,
            systemTimes: new Map()
        };
    }
    
    /**
     * Iniciar medición de frame
     */
    startFrame() {
        if (!this.enabled) return;
        
        // Sampling: solo medir cada N frames
        this.frameCount++;
        if (this.frameRate < 1 && Math.random() > this.sampleRate) {
            return;
        }
        
        this.currentFrame.startTime = performance.now();
        this.currentFrame.systemTimes.clear();
    }
    
    /**
     * Iniciar medición de sistema
     * @param {string} systemName - Nombre del sistema
     */
    startSystem(systemName) {
        if (!this.enabled) return;
        this.currentFrame.systemTimes.set(systemName, performance.now());
    }
    
    /**
     * Finalizar medición de sistema
     * @param {string} systemName - Nombre del sistema
     * @param {number} entityCount - Número de entidades procesadas
     */
    endSystem(systemName, entityCount) {
        if (!this.enabled) return;
        
        const startTime = this.currentFrame.systemTimes.get(systemName);
        if (!startTime) return;
        
        const time = performance.now() - startTime;
        
        // Agregar a métricas
        if (!this.metrics.systemTimes.has(systemName)) {
            this.metrics.systemTimes.set(systemName, []);
        }
        this.metrics.systemTimes.get(systemName).push(time);
        
        // Mantener solo últimos N frames
        const times = this.metrics.systemTimes.get(systemName);
        if (times.length > this.maxHistorySize) {
            times.shift();
        }
        
        // Contar entidades
        if (!this.metrics.entityCounts.has(systemName)) {
            this.metrics.entityCounts.set(systemName, []);
        }
        this.metrics.entityCounts.get(systemName).push(entityCount);
        const counts = this.metrics.entityCounts.get(systemName);
        if (counts.length > this.maxHistorySize) {
            counts.shift();
        }
    }
    
    /**
     * Finalizar medición de frame
     */
    endFrame() {
        if (!this.enabled) return;
        
        const frameTime = performance.now() - this.currentFrame.startTime;
        if (frameTime > 0) {
            this.metrics.frameTime.push(frameTime);
            
            // Mantener solo últimos N frames
            if (this.metrics.frameTime.length > this.maxHistorySize) {
                this.metrics.frameTime.shift();
            }
        }
    }
    
    /**
     * Obtener estadísticas
     * @returns {Object|null} Estadísticas de performance o null si está deshabilitado
     */
    getStats() {
        if (!this.enabled) return null;
        
        const stats = {
            frameTime: {
                avg: this.average(this.metrics.frameTime),
                min: this.metrics.frameTime.length > 0 ? Math.min(...this.metrics.frameTime) : 0,
                max: this.metrics.frameTime.length > 0 ? Math.max(...this.metrics.frameTime) : 0,
                count: this.metrics.frameTime.length
            },
            systems: {}
        };
        
        // Calcular estadísticas por sistema
        for (const [systemName, times] of this.metrics.systemTimes) {
            if (times.length === 0) continue;
            
            stats.systems[systemName] = {
                avgTime: this.average(times),
                minTime: Math.min(...times),
                maxTime: Math.max(...times),
                avgEntities: this.average(this.metrics.entityCounts.get(systemName) || [])
            };
        }
        
        return stats;
    }
    
    /**
     * Calcular promedio de array
     * @param {Array<number>} array - Array de números
     * @returns {number} Promedio
     */
    average(array) {
        if (array.length === 0) return 0;
        return array.reduce((a, b) => a + b, 0) / array.length;
    }
    
    /**
     * Resetear métricas
     */
    reset() {
        this.metrics.frameTime = [];
        this.metrics.systemTimes.clear();
        this.metrics.entityCounts.clear();
        this.frameCount = 0;
    }
    
    /**
     * Habilitar/deshabilitar métricas
     * @param {boolean} enabled - Si está habilitado
     */
    setEnabled(enabled) {
        this.enabled = enabled && DEBUG_CONFIG.enabled;
    }
}
```

**Integración en ECSManager:**
```javascript
// frontend/src/ecs/manager.js
// Agregar método para establecer métricas de debugging

/**
 * Establecer métricas de debugging
 * @param {DebugMetrics} debugMetrics - Instancia de DebugMetrics
 */
setDebugMetrics(debugMetrics) {
    this.debugMetrics = debugMetrics;
}

// Modificar método update:
update(deltaTime) {
    // Iniciar medición de frame
    if (this.debugMetrics) {
        this.debugMetrics.startFrame();
    }
    
    // Ordenar sistemas por prioridad
    const sortedSystems = [...this.systems].sort((a, b) => a.priority - b.priority);
    
    for (const system of sortedSystems) {
        if (system.enabled) {
            if (this.debugMetrics) {
                const entityCount = system.getEntities().size;
                this.debugMetrics.startSystem(system.constructor.name);
                system.update(deltaTime);
                this.debugMetrics.endSystem(system.constructor.name, entityCount);
            } else {
                system.update(deltaTime);
            }
        }
    }
    
    // Finalizar medición de frame
    if (this.debugMetrics) {
        this.debugMetrics.endFrame();
    }
}
```

**Notas:**
- Las métricas deben ser completamente opcionales
- Usar sampling para reducir overhead (solo medir cada N frames)
- Mantener solo últimos N frames en historial
- **⚠️ READMEs:** Actualizar `frontend/src/debug/README.md` con documentación de métricas

---

### Paso 7: Implementar Sistema de Eventos para Debugging

**Descripción:**
Crear `DebugEventEmitter` para emitir y registrar eventos estructurados para debugging y timeline.

**Archivos a modificar/crear:**
- `frontend/src/debug/events.js` (crear)
- `frontend/src/debug/README.md` (actualizar)
- `frontend/src/ecs/systems/combat-system.js` (modificar - agregar eventos)
- `frontend/src/ecs/systems/animation-mixer-system.js` (modificar - agregar eventos)

**Detalles de implementación:**
```javascript
// frontend/src/debug/events.js
import { DEBUG_CONFIG } from './config.js';

/**
 * Sistema de eventos para debugging
 */
export class DebugEventEmitter {
    constructor() {
        const config = DEBUG_CONFIG.events;
        this.enabled = config.enabled && DEBUG_CONFIG.enabled;
        this.maxHistorySize = config.maxHistorySize ?? 1000;
        this.listeners = new Map(); // eventName -> [listeners]
        this.eventHistory = []; // Timeline de eventos
    }
    
    /**
     * Emitir evento
     * @param {string} eventName - Nombre del evento
     * @param {Object} data - Datos del evento
     */
    emit(eventName, data = {}) {
        if (!this.enabled) return;
        
        const event = {
            name: eventName,
            timestamp: performance.now(),
            timestampISO: new Date().toISOString(),
            data
        };
        
        // Agregar a historial
        this.eventHistory.push(event);
        if (this.eventHistory.length > this.maxHistorySize) {
            this.eventHistory.shift();
        }
        
        // Notificar listeners
        const listeners = this.listeners.get(eventName) || [];
        listeners.forEach(listener => {
            try {
                listener(event);
            } catch (error) {
                console.error('Error in debug event listener:', error);
            }
        });
    }
    
    /**
     * Escuchar evento
     * @param {string} eventName - Nombre del evento
     * @param {Function} listener - Función listener que recibe (event) => {}
     * @returns {Function} Función para desuscribirse
     */
    on(eventName, listener) {
        if (!this.listeners.has(eventName)) {
            this.listeners.set(eventName, []);
        }
        this.listeners.get(eventName).push(listener);
        
        // Retornar función de desuscripción
        return () => {
            const listeners = this.listeners.get(eventName);
            if (listeners) {
                const index = listeners.indexOf(listener);
                if (index > -1) {
                    listeners.splice(index, 1);
                }
            }
        };
    }
    
    /**
     * Escuchar evento una sola vez
     * @param {string} eventName - Nombre del evento
     * @param {Function} listener - Función listener
     * @returns {Function} Función para desuscribirse
     */
    once(eventName, listener) {
        const wrappedListener = (event) => {
            listener(event);
            this.off(eventName, wrappedListener);
        };
        return this.on(eventName, wrappedListener);
    }
    
    /**
     * Desuscribirse de evento
     * @param {string} eventName - Nombre del evento
     * @param {Function} listener - Función listener a remover
     */
    off(eventName, listener) {
        const listeners = this.listeners.get(eventName);
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }
    
    /**
     * Obtener historial de eventos
     * @param {string} eventName - Filtrar por nombre (opcional)
     * @param {number} limit - Limitar número de eventos (opcional)
     * @returns {Array} Historial de eventos
     */
    getHistory(eventName = null, limit = null) {
        let history = eventName
            ? this.eventHistory.filter(e => e.name === eventName)
            : [...this.eventHistory];
        
        if (limit && limit > 0) {
            history = history.slice(-limit);
        }
        
        return history;
    }
    
    /**
     * Limpiar historial
     */
    clearHistory() {
        this.eventHistory = [];
    }
    
    /**
     * Habilitar/deshabilitar eventos
     * @param {boolean} enabled - Si está habilitado
     */
    setEnabled(enabled) {
        this.enabled = enabled && DEBUG_CONFIG.enabled;
    }
}

// Singleton global
export const debugEvents = new DebugEventEmitter();
```

**Integración en sistemas:**
```javascript
// frontend/src/ecs/systems/combat-system.js
import { debugEvents } from '../../debug/events.js';

update(deltaTime) {
    // ... código existente ...
    
    if (wantsAction && canExecute && !combat.isOnCooldown(actionId)) {
        combat.startAction(actionId);
        this.applyActionConfig(combat, actionConfig);
        
        // Emitir evento
        debugEvents.emit('combat:action:started', {
            entityId,
            actionId,
            actionConfig: {
                id: actionConfig.id,
                animationStateId: actionConfig.animationStateId
            }
        });
        
        // ... resto del código ...
    }
}

// Agregar eventos en otros puntos:
// - Cuando termina una acción
// - Cuando se activa un cooldown
// - Cuando se resetea estado
```

```javascript
// frontend/src/ecs/systems/animation-mixer-system.js
import { debugEvents } from '../../debug/events.js';

// Agregar eventos cuando:
// - Se resuelve un nombre de animación
// - Se carga una animación
// - Se reproduce una animación
// - Termina una animación
```

**Notas:**
- Los eventos deben ser completamente opcionales
- Limitar tamaño del historial para evitar memory leaks
- **⚠️ READMEs:** Actualizar `frontend/src/debug/README.md` con documentación de eventos

---

### Paso 8: Implementar Panel de Debugging UI (Opcional)

**Descripción:**
Crear `DebugPanel` para mostrar métricas y estadísticas en tiempo real en la UI, activable con tecla F3.

**Archivos a modificar/crear:**
- `frontend/src/debug/ui/debug-panel.js` (crear)
- `frontend/src/debug/ui/README.md` (crear)
- `frontend/src/app.js` (modificar - inicializar panel)

**Detalles de implementación:**
```javascript
// frontend/src/debug/ui/debug-panel.js
import { DEBUG_CONFIG } from '../config.js';

/**
 * Panel de debugging visual en UI
 */
export class DebugPanel {
    constructor(app, ecs) {
        this.app = app;
        this.ecs = ecs;
        const config = DEBUG_CONFIG.ui;
        this.enabled = config.enabled && DEBUG_CONFIG.enabled;
        this.toggleKey = config.toggleKey || 'F3';
        this.autoUpdateInterval = config.autoUpdateInterval || 1000;
        
        this.visible = false;
        this.panel = null;
        this.updateInterval = null;
        this.inspector = null;
        this.metrics = null;
        
        if (this.enabled) {
            this.init();
        }
    }
    
    /**
     * Inicializar panel
     */
    init() {
        // Crear panel HTML
        this.panel = document.createElement('div');
        this.panel.id = 'debug-panel';
        this.panel.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            width: 400px;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-y: auto;
            z-index: 10000;
            display: none;
            border: 2px solid #0f0;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        `;
        document.body.appendChild(this.panel);
        
        // Toggle con tecla
        document.addEventListener('keydown', (e) => {
            if (e.key === this.toggleKey) {
                e.preventDefault();
                this.toggle();
            }
        });
    }
    
    /**
     * Establecer inspector y métricas
     * @param {ECSInspector} inspector - Inspector de ECS
     * @param {DebugMetrics} metrics - Métricas de debugging
     */
    setTools(inspector, metrics) {
        this.inspector = inspector;
        this.metrics = metrics;
    }
    
    /**
     * Toggle visibilidad del panel
     */
    toggle() {
        this.visible = !this.visible;
        this.panel.style.display = this.visible ? 'block' : 'none';
        
        if (this.visible) {
            this.update();
            this.startAutoUpdate();
        } else {
            this.stopAutoUpdate();
        }
    }
    
    /**
     * Actualizar contenido del panel
     */
    update() {
        if (!this.visible || !this.panel) return;
        
        // Obtener métricas
        const metrics = this.metrics?.getStats();
        const stats = this.inspector?.getStats();
        const fps = this.app.performanceManager?.fps || 0;
        
        // Construir HTML
        let html = `
            <div style="margin-bottom: 10px; border-bottom: 1px solid #0f0; padding-bottom: 5px;">
                <h3 style="margin: 0; color: #0f0;">Debug Panel (${this.toggleKey} to toggle)</h3>
            </div>
        `;
        
        // Performance
        html += `
            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 5px 0; color: #0f0;">Performance</h4>
                <div style="margin-left: 10px;">
                    <div>FPS: <span style="color: ${fps >= 60 ? '#0f0' : fps >= 30 ? '#ff0' : '#f00'}">${fps}</span></div>
        `;
        
        if (metrics) {
            html += `
                    <div>Avg Frame Time: ${metrics.frameTime.avg.toFixed(2)}ms</div>
                    <div>Min: ${metrics.frameTime.min.toFixed(2)}ms | Max: ${metrics.frameTime.max.toFixed(2)}ms</div>
                    <div style="margin-top: 5px;"><strong>Systems:</strong></div>
            `;
            
            for (const [name, systemStats] of Object.entries(metrics.systems)) {
                html += `
                    <div style="margin-left: 10px; font-size: 11px;">
                        ${name}: ${systemStats.avgTime.toFixed(2)}ms (${systemStats.avgEntities.toFixed(0)} entities)
                    </div>
                `;
            }
        }
        
        html += `
                </div>
            </div>
        `;
        
        // ECS Stats
        if (stats) {
            html += `
                <div style="margin-bottom: 15px;">
                    <h4 style="margin: 0 0 5px 0; color: #0f0;">ECS Stats</h4>
                    <div style="margin-left: 10px;">
                        <div>Total Entities: ${stats.totalEntities}</div>
                        <div style="margin-top: 5px;"><strong>Components:</strong></div>
            `;
            
            for (const [name, count] of Object.entries(stats.componentCounts)) {
                html += `
                    <div style="margin-left: 10px; font-size: 11px;">${name}: ${count}</div>
                `;
            }
            
            html += `
                    </div>
                </div>
            `;
        }
        
        this.panel.innerHTML = html;
    }
    
    /**
     * Iniciar actualización automática
     */
    startAutoUpdate() {
        this.stopAutoUpdate(); // Asegurar que no hay múltiples intervals
        this.updateInterval = setInterval(() => this.update(), this.autoUpdateInterval);
    }
    
    /**
     * Detener actualización automática
     */
    stopAutoUpdate() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }
    
    /**
     * Destruir panel
     */
    destroy() {
        this.stopAutoUpdate();
        if (this.panel && this.panel.parentNode) {
            this.panel.parentNode.removeChild(this.panel);
        }
    }
}
```

**Integración en App:**
```javascript
// frontend/src/app.js
import { DebugPanel } from './debug/ui/debug-panel.js';

export class App {
    constructor(container) {
        // ... código existente ...
        
        // Inicializar herramientas de debugging (solo en desarrollo)
        if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {
            // ... otros inicializadores ...
            
            // Panel de debugging (opcional)
            this.debugPanel = new DebugPanel(this, this.ecs);
            if (this.inspector && this.debugMetrics) {
                this.debugPanel.setTools(this.inspector, this.debugMetrics);
            }
        }
    }
}
```

**Notas:**
- El panel debe ser completamente opcional
- Usar estilos inline para evitar conflictos con CSS del juego
- Actualizar panel periódicamente (cada segundo por defecto)
- **⚠️ READMEs:** Crear `frontend/src/debug/ui/README.md` explicando el panel

---

### Paso 9: Integrar Todas las Herramientas en App

**Descripción:**
Integrar todas las herramientas de debugging en `App` para que estén disponibles en desarrollo.

**Archivos a modificar/crear:**
- `frontend/src/app.js` (modificar)
- `frontend/src/debug/README.md` (actualizar)

**Detalles de implementación:**
```javascript
// frontend/src/app.js
import { debugLogger } from './debug/logger.js';
import { ECSInspector } from './debug/inspector.js';
import { DebugMetrics } from './debug/metrics.js';
import { stateValidator } from './debug/validator.js';
import { debugEvents } from './debug/events.js';
import { DebugPanel } from './debug/ui/debug-panel.js';

export class App {
    constructor(container) {
        // ... código existente ...
        
        // Inicializar herramientas de debugging (solo en desarrollo)
        const isDevelopment = typeof process !== 'undefined' && process.env?.NODE_ENV === 'development';
        
        if (isDevelopment) {
            // Logger (ya es singleton, solo habilitar)
            debugLogger.setEnabled(true);
            
            // Inspector
            this.inspector = new ECSInspector(this.ecs);
            this.inspector.setEnabled(true);
            
            // Métricas
            this.debugMetrics = new DebugMetrics(this.ecs);
            this.debugMetrics.setEnabled(true);
            this.ecs.setDebugMetrics(this.debugMetrics);
            
            // Validador (ya es singleton, solo habilitar)
            stateValidator.setEnabled(true);
            
            // Eventos (ya es singleton, solo habilitar)
            debugEvents.setEnabled(true);
            
            // Panel de debugging (opcional)
            this.debugPanel = new DebugPanel(this, this.ecs);
            this.debugPanel.setTools(this.inspector, this.debugMetrics);
            
            // Exponer herramientas globalmente para consola del navegador
            if (typeof window !== 'undefined') {
                window.developmentTools = {
                    logger: debugLogger,
                    inspector: this.inspector,
                    metrics: this.debugMetrics,
                    validator: stateValidator,
                    events: debugEvents,
                    panel: this.debugPanel
                };
            }
        }
    }
}
```

**Notas:**
- Todas las herramientas deben estar deshabilitadas por defecto en producción
- Exponer herramientas globalmente para facilitar debugging desde consola
- **⚠️ READMEs:** Actualizar `frontend/src/debug/README.md` con ejemplos de uso

---

### Paso 10: Crear Documentación Completa

**Descripción:**
Crear y actualizar READMEs con documentación completa del sistema de debugging.

**Archivos a modificar/crear:**
- `frontend/src/debug/README.md` (crear/actualizar)
- `frontend/src/debug/ui/README.md` (crear)

**Detalles de implementación:**
```markdown
# Sistema de Debugging

Sistema completo de debugging y herramientas de desarrollo para el juego.

## Estructura

```
debug/
├── config.js          # Configuración centralizada
├── logger.js           # Sistema de logging estructurado
├── inspector.js        # Inspector de estado ECS
├── metrics.js          # Métricas detalladas de performance
├── validator.js        # Validación de estado
├── events.js           # Sistema de eventos
└── ui/                 # Herramientas visuales
    └── debug-panel.js  # Panel de debugging en UI
```

## Uso

### Logger

```javascript
import { debugLogger } from './debug/logger.js';

// Logs con contexto
debugLogger.info('CombatSystem', 'Action started', { actionId: 'attack' });
debugLogger.warn('AnimationMixer', 'State not found', { stateId: 'invalid' });
debugLogger.error('System', 'Error occurred', { error });
```

### Inspector

```javascript
// En consola del navegador
window.developmentTools.inspector.inspectEntity(playerId);
window.developmentTools.inspector.findEntities({ hasComponent: 'Animation' });
window.developmentTools.inspector.getStats();
```

### Métricas

```javascript
// En consola del navegador
const stats = window.developmentTools.metrics.getStats();
console.log(stats);
```

### Eventos

```javascript
// Escuchar eventos
debugEvents.on('combat:action:started', (event) => {
    console.log('Action started:', event);
});

// Ver historial
debugEvents.getHistory('combat:action:started');
```

### Panel de Debugging

Presionar `F3` para mostrar/ocultar el panel de debugging.

## Configuración

Todas las herramientas se pueden habilitar/deshabilitar desde `debug/config.js` o en runtime:

```javascript
debugLogger.setEnabled(true);
stateValidator.setEnabled(true);
debugEvents.setEnabled(true);
```

## Performance

Todas las herramientas son completamente opcionales y no afectan el performance cuando están deshabilitadas. En producción, todas están deshabilitadas por defecto.
```

**Notas:**
- Documentar todos los módulos y sus APIs
- Incluir ejemplos de uso
- Explicar configuración y opciones

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-030_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance

- **Zero Overhead:** Todas las herramientas son opcionales y no afectan performance cuando están deshabilitadas
- **Sampling:** Métricas pueden usar sampling (solo cada N frames) para reducir overhead
- **Caches:** Inspector usa cache para evitar serializaciones repetidas
- **Lazy Evaluation:** Métricas solo se calculan cuando se solicitan

### Seguridad

- **No exponer en producción:** Todas las herramientas están deshabilitadas por defecto en producción
- **Validación segura:** Validación no modifica estado, solo muestra warnings

### Casos Edge

- **Entidades sin componentes:** Inspector maneja entidades sin componentes correctamente
- **Sistemas deshabilitados:** Métricas no miden sistemas deshabilitados
- **Eventos sin listeners:** Eventos se emiten incluso sin listeners (se guardan en historial)
- **Panel cerrado:** Panel no actualiza cuando está cerrado para ahorrar recursos

### Compatibilidad

- **Backward Compatible:** No rompe funcionalidad existente
- **Opcional:** Todas las herramientas son opcionales
- **Incremental:** Se puede habilitar/deshabilitar cada herramienta independientemente

## Patrones de Código a Usar

- **Singleton Pattern:** Logger, Validator y Events son singletons globales
- **Observer Pattern:** Logger y Events usan suscripción para notificar cambios
- **Factory Pattern:** Inspector y Metrics se crean con factory methods
- **Strategy Pattern:** Validación usa estrategias configurables

## Dependencias

### Nuevas Dependencias
Ninguna - todo usa APIs nativas del navegador y código existente.

### Variables de Entorno
- `NODE_ENV`: Determina si está en desarrollo o producción (default: 'development')

## Archivos Principales Involucrados

1. `frontend/src/debug/config.js` - Configuración centralizada
2. `frontend/src/debug/logger.js` - Sistema de logging
3. `frontend/src/debug/inspector.js` - Inspector de estado
4. `frontend/src/debug/metrics.js` - Métricas de performance
5. `frontend/src/debug/validator.js` - Validación de estado
6. `frontend/src/debug/events.js` - Sistema de eventos
7. `frontend/src/debug/ui/debug-panel.js` - Panel de debugging UI
8. `frontend/src/app.js` - Integración de herramientas
9. `frontend/src/ecs/manager.js` - Integración de métricas
10. `frontend/src/ecs/systems/animation-mixer-system.js` - Integración de logger/validator/events
11. `frontend/src/ecs/systems/combat-system.js` - Integración de logger/validator/events

## Testing

### Tests a Crear/Modificar
- Unit tests: `tests/debug/test_logger.js`
- Unit tests: `tests/debug/test_inspector.js`
- Unit tests: `tests/debug/test_metrics.js`
- Unit tests: `tests/debug/test_validator.js`
- Unit tests: `tests/debug/test_events.js`

### Escenarios de Prueba
1. **Logger:** Verificar que logs se emiten correctamente con diferentes niveles
2. **Inspector:** Verificar que puede inspeccionar entidades y buscar por query
3. **Métricas:** Verificar que métricas se recopilan correctamente y no afectan performance
4. **Validación:** Verificar que warnings aparecen cuando hay estados inválidos
5. **Eventos:** Verificar que eventos se emiten y se pueden escuchar
6. **Panel:** Verificar que panel se muestra/oculta con F3 y actualiza correctamente
7. **Performance:** Verificar que no hay overhead cuando herramientas están deshabilitadas

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos
2. Verificar en ambiente local con Docker Compose
3. Verificar que herramientas están deshabilitadas en producción

### Verificación Post-Deployment
- [ ] Verificar que logger funciona en desarrollo
- [ ] Verificar que inspector puede inspeccionar entidades
- [ ] Verificar que métricas se recopilan correctamente
- [ ] Verificar que validación muestra warnings cuando corresponde
- [ ] Verificar que eventos se emiten correctamente
- [ ] Verificar que panel se muestra con F3
- [ ] Verificar que no hay overhead en producción (herramientas deshabilitadas)
- [ ] Verificar logs de Docker para errores

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Las fases opcionales (Paso 7 y 8) pueden implementarse después si es necesario, pero están incluidas en el plan completo.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
