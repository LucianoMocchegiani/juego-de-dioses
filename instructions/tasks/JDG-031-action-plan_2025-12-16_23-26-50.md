# JDG-031 - Interfaz de Prueba de Animaciones

## Descripción de la Tarea

Implementar una interfaz de desarrollo para listar y probar animaciones del juego. La interfaz debe permitir ver todas las animaciones disponibles, mostrar su nombre y archivo GLB, y reproducirlas directamente en el personaje.

**Comportamiento actual:**
- Las animaciones están definidas en `ANIMATION_FILES` pero no hay forma visual de listarlas
- Para probar una animación, se necesita modificar código o usar la consola del navegador
- No hay forma de ver todas las animaciones disponibles de un vistazo
- No hay método público en `AnimationMixerSystem` para reproducir animaciones por nombre

**Comportamiento esperado:**
- Interfaz similar al debugger (F4) pero específica para animaciones
- Se activa con F6 (F5 está reservada para recargar página)
- Lista todas las animaciones de `ANIMATION_FILES`
- Muestra nombre de animación y nombre del archivo GLB
- Botón "Reproducir" para probar cada animación en el personaje
- Búsqueda opcional por nombre
- Solo funciona en modo desarrollo (localhost/127.0.0.1)

## Criterios de Aceptación

1. ❌ Existe una interfaz visual para probar animaciones (similar al debugger)
2. ❌ La interfaz se activa con F6 (F5 está reservada para recargar página)
3. ❌ La interfaz lista todas las animaciones de `ANIMATION_FILES`
4. ❌ Cada animación en la lista tiene un botón "Reproducir" para probarla
5. ❌ Al hacer click en "Reproducir", la animación se reproduce en el personaje del jugador
6. ❌ La interfaz muestra información de cada animación:
   - Nombre de la animación (key de `ANIMATION_FILES`)
   - Nombre del archivo GLB (valor de `ANIMATION_FILES`)
7. ❌ La interfaz permite buscar animaciones por nombre (opcional)
8. ❌ La interfaz solo funciona en modo desarrollo (localhost/127.0.0.1)
9. ❌ El código del debugger ha sido refactorizado para reutilizar componentes comunes
10. ❌ `AnimationMixerSystem` tiene un método público para reproducir animaciones por nombre
11. ❌ La interfaz está expuesta globalmente como `window.animationTester` en modo desarrollo

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI) - No requiere cambios
- [x] Frontend (Three.js) - Nueva interfaz y refactorización del debugger
- [ ] Base de Datos (PostgreSQL) - No afectado
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No requiere cambios

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js
- DOM API: Creación de elementos de interfaz
- Sistema ECS: Entity Component System personalizado

## Pasos de Implementación

### Paso 1: Refactorizar DebugInterface - Crear BaseInterface

**Descripción:**
Extraer código común de `DebugInterface` para crear una clase base `BaseInterface` que pueda ser reutilizada por otras interfaces de desarrollo. Esto incluye estructura base (header, sidebar, mainContent), estilos comunes, manejo de eventos de teclado, y utilidades compartidas.

**Archivos a crear:**
- `frontend/src/debug/ui/base-interface.js` - Clase base para interfaces de desarrollo

**Archivos a modificar:**
- `frontend/src/debug/ui/debug-interface.js` - Refactorizar para usar `BaseInterface`

**Detalles de implementación:**

1. **Crear `BaseInterface`** con los siguientes métodos comunes:
```javascript
export class BaseInterface {
    constructor(app, ecs, config) {
        this.app = app;
        this.ecs = ecs;
        this.config = config; // { enabled, toggleKey, title, color }
        this.visible = false;
        this.interfaceElement = null;
        this.inputBlocked = false;
    }
    
    // Métodos comunes
    init() { /* Crear estructura base */ }
    createBaseStructure() { /* Header, sidebar, mainContent */ }
    createHeader(title, color) { /* Header con título y botón cerrar */ }
    createTabs(sidebar, mainContent, tabs) { /* Sistema de tabs genérico */ }
    toggle() { /* Mostrar/ocultar interfaz */ }
    escapeHtml(text) { /* Escapar HTML para prevenir XSS */ }
    showInfo(element, message) { /* Mostrar mensaje de info */ }
    showError(element, message) { /* Mostrar mensaje de error */ }
    setupKeyboardListener() { /* Registrar listener para toggleKey */ }
}
```

2. **Refactorizar `DebugInterface`** para extender `BaseInterface`:
```javascript
import { BaseInterface } from './base-interface.js';
import { DEBUG_CONFIG } from '../config.js';

export class DebugInterface extends BaseInterface {
    constructor(app, ecs) {
        super(app, ecs, {
            enabled: DEBUG_CONFIG.ui.enabled && DEBUG_CONFIG.enabled,
            toggleKey: 'F4',
            title: 'Debug Tools',
            color: '#4CAF50'
        });
        // Propiedades específicas del debugger
        this.logHistory = [];
        this.maxLogHistory = 500;
        // ...
    }
    
    init() {
        super.init(); // Crear estructura base
        // Lógica específica del debugger
        this.createTabs(/* tabs del debugger */);
        this.setupLoggerSubscription();
    }
}
```

**Notas:**
- Mantener toda la funcionalidad existente de `DebugInterface`
- Los estilos deben ser consistentes (fondo oscuro, colores de acento configurables)
- El sistema de tabs debe ser genérico y reutilizable
- Verificar que el debugger sigue funcionando correctamente después de la refactorización
- **⚠️ READMEs:** Actualizar `frontend/src/debug/ui/README.md` si existe, o crear uno documentando `BaseInterface` y `DebugInterface`

**Recursos útiles:**
- `frontend/src/debug/ui/debug-interface.js` - Código actual del debugger para extraer

---

### Paso 2: Agregar Método Público en AnimationMixerSystem

**Descripción:**
Agregar método público `playAnimationByName()` en `AnimationMixerSystem` que permita reproducir una animación directamente por su nombre (key de `ANIMATION_FILES`). Este método será usado por la interfaz de prueba de animaciones.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**

```javascript
/**
 * Reproducir animación directamente por nombre
 * 
 * Método público para reproducir animaciones por nombre desde interfaces externas
 * (ej: interfaz de prueba de animaciones).
 * 
 * @param {number} entityId - ID de la entidad
 * @param {string} animationName - Nombre de la animación (key de ANIMATION_FILES)
 * @returns {boolean} True si se reprodujo correctamente, False si hubo error
 */
playAnimationByName(entityId, animationName) {
    // Validar parámetros
    if (!entityId || !animationName) {
        debugLogger.warn('AnimationMixer', 'playAnimationByName: entityId y animationName son requeridos', {
            entityId,
            animationName
        });
        return false;
    }
    
    // Obtener componentes necesarios
    const render = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.RENDER);
    if (!render || !render.mesh) {
        debugLogger.warn('AnimationMixer', 'playAnimationByName: Entidad no tiene RenderComponent o mesh', {
            entityId
        });
        return false;
    }
    
    const mesh = render.mesh;
    const mixer = mesh.userData.animationMixer;
    const clips = mesh.userData.animationClips;
    
    // Verificar que el mixer esté inicializado
    if (!mixer || !clips) {
        debugLogger.warn('AnimationMixer', 'playAnimationByName: Mixer no inicializado para entidad', {
            entityId,
            hasMixer: !!mixer,
            hasClips: !!clips
        });
        return false;
    }
    
    // Buscar clip por nombre
    let clip = clips[animationName];
    
    // Si no existe, intentar cargar la animación
    if (!clip) {
        const animationFile = ANIMATION_FILES[animationName];
        if (!animationFile) {
            debugLogger.warn('AnimationMixer', 'playAnimationByName: Animación no encontrada', {
                entityId,
                animationName,
                availableAnimations: Object.keys(clips)
            });
            return false;
        }
        
        // Cargar animación (asíncrono, pero retornamos false por ahora)
        // Nota: En el futuro se podría hacer esto asíncrono, pero por ahora
        // solo reproducimos animaciones ya cargadas
        debugLogger.warn('AnimationMixer', 'playAnimationByName: Animación no está en clips, necesita cargarse primero', {
            entityId,
            animationName,
            animationFile
        });
        return false;
    }
    
    // Detener animación actual si existe
    const currentAction = mesh.userData.currentAction;
    if (currentAction && currentAction.isRunning()) {
        currentAction.fadeOut(ANIMATION_MIXER.defaultTransitionDuration);
    }
    
    // Crear y reproducir nueva animación
    const action = mixer.clipAction(clip);
    action.reset();
    action.setLoop(THREE.LoopOnce);
    action.clampWhenFinished = true;
    action.play();
    
    // Guardar referencias
    mesh.userData.currentAction = action;
    mesh.userData.currentAnimationState = animationName;
    
    debugLogger.debug('AnimationMixer', 'playAnimationByName: Animación reproducida', {
        entityId,
        animationName
    });
    
    return true;
}
```

**Notas:**
- El método debe validar que la entidad existe y tiene mixer inicializado
- Solo reproducir animaciones que ya están en `clips` (ya cargadas)
- Detener animación actual antes de reproducir nueva
- Usar `debugLogger` para logging en lugar de `console.log`
- El método debe ser público (no `@private`)

**Recursos útiles:**
- `frontend/src/ecs/systems/animation-mixer-system.js` - Método `playAnimation()` existente como referencia

---

### Paso 3: Crear AnimationTester

**Descripción:**
Crear la interfaz `AnimationTester` que extiende `BaseInterface` y muestra todas las animaciones disponibles con su nombre y archivo GLB, permitiendo reproducirlas con un botón.

**Archivos a crear:**
- `frontend/src/debug/ui/animation-tester.js` - Interfaz de prueba de animaciones

**Detalles de implementación:**

```javascript
import { BaseInterface } from './base-interface.js';
import { ANIMATION_FILES } from '../../config/animation-config.js';
import { isDevelopment } from '../dev-exposure.js';
import { debugLogger } from '../logger.js';

export class AnimationTester extends BaseInterface {
    constructor(app, ecs) {
        super(app, ecs, {
            enabled: isDevelopment(),
            toggleKey: 'F6',
            title: 'Animation Tester',
            color: '#2196F3' // Azul para diferenciarlo del debugger (verde)
        });
        this.animations = ANIMATION_FILES;
        this.searchTerm = '';
    }
    
    init() {
        if (!this.config.enabled) {
            return;
        }
        
        super.init(); // Crear estructura base
        this.createAnimationList();
    }
    
    /**
     * Crear lista de animaciones
     */
    createAnimationList() {
        const mainContent = this.interfaceElement.querySelector('#debug-interface-content');
        if (!mainContent) return;
        
        // Limpiar contenido
        mainContent.innerHTML = '';
        
        // Título
        const title = document.createElement('h3');
        title.textContent = 'Lista de Animaciones';
        title.style.cssText = 'margin-top: 0; color: #2196F3;';
        mainContent.appendChild(title);
        
        // Campo de búsqueda
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'margin-bottom: 15px;';
        
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Buscar animación por nombre...';
        searchInput.style.cssText = `
            width: 100%;
            padding: 8px 12px;
            background: #2d2d2d;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 13px;
        `;
        searchInput.oninput = (e) => {
            this.searchTerm = e.target.value.toLowerCase();
            this.renderAnimationList();
        };
        
        searchContainer.appendChild(searchInput);
        mainContent.appendChild(searchContainer);
        
        // Contenedor de lista
        this.listContainer = document.createElement('div');
        this.listContainer.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';
        mainContent.appendChild(this.listContainer);
        
        // Renderizar lista inicial
        this.renderAnimationList();
    }
    
    /**
     * Renderizar lista de animaciones (filtrada por búsqueda)
     */
    renderAnimationList() {
        if (!this.listContainer) return;
        
        this.listContainer.innerHTML = '';
        
        // Filtrar animaciones por término de búsqueda
        const filteredAnimations = Object.entries(this.animations).filter(([name, file]) => {
            if (!this.searchTerm) return true;
            return name.toLowerCase().includes(this.searchTerm) || 
                   file.toLowerCase().includes(this.searchTerm);
        });
        
        if (filteredAnimations.length === 0) {
            const noResults = document.createElement('div');
            noResults.textContent = 'No se encontraron animaciones';
            noResults.style.cssText = 'color: #888; padding: 20px; text-align: center;';
            this.listContainer.appendChild(noResults);
            return;
        }
        
        // Crear item para cada animación
        filteredAnimations.forEach(([animationName, animationFile]) => {
            const item = document.createElement('div');
            item.style.cssText = `
                display: flex;
                align-items: center;
                gap: 15px;
                padding: 12px;
                background: rgba(45, 45, 45, 0.5);
                border: 1px solid #444;
                border-radius: 4px;
            `;
            
            // Nombre de la animación
            const nameDiv = document.createElement('div');
            nameDiv.textContent = animationName;
            nameDiv.style.cssText = 'flex: 0 0 200px; color: #fff; font-weight: bold;';
            item.appendChild(nameDiv);
            
            // Archivo GLB
            const fileDiv = document.createElement('div');
            fileDiv.textContent = animationFile;
            fileDiv.style.cssText = 'flex: 1; color: #aaa; font-family: monospace; font-size: 11px;';
            item.appendChild(fileDiv);
            
            // Botón Reproducir
            const playBtn = document.createElement('button');
            playBtn.textContent = 'Reproducir';
            playBtn.style.cssText = `
                background: #2196F3;
                color: white;
                border: none;
                padding: 6px 15px;
                cursor: pointer;
                border-radius: 4px;
                font-size: 12px;
                white-space: nowrap;
            `;
            playBtn.onclick = () => {
                this.playAnimation(animationName);
            };
            item.appendChild(playBtn);
            
            this.listContainer.appendChild(item);
        });
    }
    
    /**
     * Reproducir animación en el personaje
     * @param {string} animationName - Nombre de la animación
     */
    playAnimation(animationName) {
        if (!this.app || !this.app.playerId || !this.app.ecs) {
            this.showError(this.listContainer, 'Personaje no disponible. Asegúrate de que el juego esté cargado.');
            return;
        }
        
        // Obtener AnimationMixerSystem
        const animationMixerSystem = this.app.ecs.systems.find(
            system => system.constructor.name === 'AnimationMixerSystem'
        );
        
        if (!animationMixerSystem) {
            this.showError(this.listContainer, 'AnimationMixerSystem no encontrado.');
            return;
        }
        
        // Reproducir animación
        const success = animationMixerSystem.playAnimationByName(
            this.app.playerId,
            animationName
        );
        
        if (success) {
            this.showInfo(this.listContainer, `Reproduciendo: ${animationName}`);
        } else {
            this.showError(this.listContainer, `Error al reproducir animación: ${animationName}`);
        }
    }
}
```

**Notas:**
- La interfaz debe seguir el mismo estilo visual que el debugger
- Usar color azul (#2196F3) para diferenciarlo del debugger (verde)
- El campo de búsqueda filtra tanto por nombre como por archivo GLB
- Mostrar mensajes de error/info cuando se reproduce una animación
- Verificar que el personaje existe antes de intentar reproducir
- **⚠️ READMEs:** Actualizar `frontend/src/debug/ui/README.md` para documentar `AnimationTester`

**Recursos útiles:**
- `frontend/src/debug/ui/debug-interface.js` - Referencia de estilos y estructura
- `frontend/src/config/animation-config.js` - `ANIMATION_FILES` con todas las animaciones

---

### Paso 4: Integrar AnimationTester en dev-exposure.js

**Descripción:**
Integrar `AnimationTester` en el sistema de exposición de herramientas de desarrollo para que se inicialice automáticamente y se exponga globalmente en modo desarrollo.

**Archivos a modificar:**
- `frontend/src/debug/dev-exposure.js`
- `frontend/src/app.js`

**Detalles de implementación:**

1. **En `dev-exposure.js`**, agregar import y exposición:
```javascript
import { AnimationTester } from './ui/animation-tester.js';

// En initDebugTools(), agregar:
export function initDebugTools(app) {
    if (!isDevelopment()) {
        return null;
    }
    
    // ... código existente ...
    
    // Animation Tester
    const animationTester = new AnimationTester(app, app.ecs);
    
    return {
        inspector,
        metrics: debugMetrics,
        panel: debugPanel,
        interface: debugInterface,
        animationTester: animationTester // NUEVO
    };
}

// En exposeDevTools(), agregar:
export function exposeDevTools(app, options = {}) {
    // ... código existente ...
    
    if (debugTools) {
        window.developmentTools = {
            logger: debugLogger,
            inspector: debugTools.inspector,
            metrics: debugTools.metrics,
            validator: stateValidator,
            events: debugEvents,
            panel: debugTools.panel,
            interface: debugTools.interface,
            animationTester: debugTools.animationTester // NUEVO
        };
        
        // También exponer directamente para fácil acceso
        window.animationTester = debugTools.animationTester;
        
        console.log('[DebugTools] Herramientas de debugging inicializadas. Usa window.developmentTools para acceder.');
        console.log('[DebugTools] Animation Tester disponible: F6 para abrir/cerrar');
    }
}
```

2. **En `app.js`**, verificar que `initDebugTools` se llama correctamente (ya debería estar implementado).

**Notas:**
- `AnimationTester` se inicializa automáticamente cuando se llama `initDebugTools()`
- Se expone como `window.animationTester` y también en `window.developmentTools.animationTester`
- Solo funciona en modo desarrollo (verificado por `isDevelopment()`)

**Recursos útiles:**
- `frontend/src/debug/dev-exposure.js` - Código existente de exposición de herramientas

---

### Paso 5: Refactorización de Reutilización de Código

**Descripción:**
Refactorizar `debug-interface.js` y `animation-tester.js` para eliminar duplicación masiva de código mediante la implementación de helpers avanzados en `BaseInterface`. Esto reducirá el código en ~58% y mejorará significativamente la mantenibilidad.

**Archivos a modificar:**
- `frontend/src/debug/ui/base-interface.js` - Agregar helpers avanzados
- `frontend/src/debug/ui/debug-interface.js` - Refactorizar para usar helpers
- `frontend/src/debug/ui/animation-tester.js` - Refactorizar para usar helpers

**Detalles de implementación:**

#### Fase 5.1: Agregar Helpers Avanzados a BaseInterface

1. **Agregar `createSelect()` helper:**
   - Crear método que acepta opciones, valor seleccionado, onChange callback
   - Incluir estilos consistentes
   - Retornar elemento select configurado

2. **Agregar `createCheckbox()` helper:**
   - Crear método que acepta label, estado inicial, onChange callback
   - Incluir estilos consistentes
   - Retornar objeto con { checkbox, label, container }

3. **Agregar `createTextarea()` helper:**
   - Crear método similar a `createInput()` pero para textareas
   - Incluir estilos consistentes, soporte para resize, placeholder, onChange

4. **Agregar `createResultBox()` helper:**
   - Extraer lógica de `showResult()` a método reutilizable
   - Incluir título, contenido JSON, botón de copiar
   - Soporte para reemplazar resultado anterior

5. **Agregar `createListItem()` helper:**
   - Crear método para items de lista con estructura flexible
   - Soporte para múltiples columnas, acciones, hover effects

6. **Agregar `createSectionHeader()` helper:**
   - Crear método para headers de sección con título y botones opcionales

7. **Agregar helpers de formateo:**
   - `formatLogEntry()`: Formatear entrada de log
   - `formatJSON()`: Formatear JSON para mostrar

#### Fase 5.2: Refactorizar debug-interface.js

1. **Refactorizar `createInspectorTab()`:**
   - Reemplazar creación manual con helpers
   - **Reducción esperada**: De ~60 líneas → ~25 líneas

2. **Refactorizar `createMetricsTab()`:**
   - Usar `createCheckbox()` para auto-refresh
   - Reemplazar creación manual con helpers
   - **Reducción esperada**: De ~55 líneas → ~20 líneas

3. **Refactorizar `createEventsTab()`:**
   - Completar refactorización (ya parcialmente hecho)
   - **Reducción esperada**: De ~45 líneas → ~20 líneas

4. **Refactorizar `createLoggerTab()`:**
   - Reemplazar selects con `createSelect()`
   - Reemplazar checkboxes con `createCheckbox()`
   - Reemplazar inputs con `createInput()`
   - Usar `createSectionHeader()` para header de logs
   - **Reducción esperada**: De ~285 líneas → ~120 líneas

5. **Refactorizar `createCommandsTab()`:**
   - Reemplazar botones con `createButton()` en loop
   - Reemplazar textarea con `createTextarea()`
   - **Reducción esperada**: De ~105 líneas → ~40 líneas

6. **Refactorizar `showResult()`:**
   - Usar `createResultBox()` helper
   - **Reducción esperada**: De ~70 líneas → ~15 líneas

7. **Refactorizar métodos de logs:**
   - Usar `formatLogEntry()` en métodos de logs
   - **Reducción esperada**: De ~120 líneas → ~60 líneas

#### Fase 5.3: Refactorizar animation-tester.js

1. **Refactorizar `createAnimationList()`:**
   - Usar `createTitle()` y `createInput()`
   - **Reducción esperada**: De ~70 líneas → ~40 líneas

2. **Refactorizar `renderAnimationList()`:**
   - Usar `createListItem()` para items
   - **Reducción esperada**: De ~80 líneas → ~30 líneas

**Resultado esperado:**
- `debug-interface.js`: De 1047 líneas → ~400 líneas (62% reducción)
- `animation-tester.js`: De 266 líneas → ~150 líneas (44% reducción)
- Total: De 1313 líneas → ~550 líneas (58% reducción)

**Notas:**
- Mantener toda la funcionalidad existente
- Los helpers deben ser flexibles para permitir personalización cuando sea necesario
- Verificar que todas las interfaces siguen funcionando correctamente después de la refactorización

**Recursos útiles:**
- `instructions/analysis/JDG-031-2-architecture-analysis_2025-12-17_08-27-56.md` - Análisis exhaustivo de reutilización

---

### Paso 6: Verificar y Probar

**Descripción:**
Verificar que toda la implementación funciona correctamente: refactorización del debugger, método público en AnimationMixerSystem, interfaz de animaciones, e integración.

**Archivos a verificar:**
- Todos los archivos modificados y creados

**Pasos de verificación:**

1. **Verificar Debugger:**
   - Presionar F4 y verificar que el debugger se abre correctamente
   - Verificar que todas las funcionalidades del debugger siguen funcionando
   - Verificar que los estilos se mantienen consistentes

2. **Verificar AnimationMixerSystem:**
   - Desde consola del navegador, probar:
     ```javascript
     const system = app.ecs.systems.find(s => s.constructor.name === 'AnimationMixerSystem');
     system.playAnimationByName(app.playerId, 'walk');
     ```
   - Verificar que la animación se reproduce correctamente

3. **Verificar AnimationTester:**
   - Presionar F6 y verificar que la interfaz se abre
   - Verificar que lista todas las animaciones de `ANIMATION_FILES`
   - Verificar que muestra nombre y archivo GLB correctamente
   - Probar búsqueda por nombre
   - Hacer click en "Reproducir" en diferentes animaciones
   - Verificar que las animaciones se reproducen en el personaje
   - Verificar mensajes de error cuando el personaje no existe

4. **Verificar Modo Desarrollo:**
   - Verificar que la interfaz solo funciona en localhost/127.0.0.1
   - Verificar que `window.animationTester` está disponible en modo desarrollo

**Notas:**
- Si hay errores, revisar la consola del navegador
- Verificar que no hay errores de importación
- Verificar que los estilos se aplican correctamente

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-031_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance

- **Lista de animaciones**: Se genera una vez al abrir la interfaz, no se regenera constantemente
- **Búsqueda**: Filtrado en memoria, muy rápido incluso con muchas animaciones
- **Carga de animaciones**: Usa el cache existente de `AnimationMixerSystem`, no carga duplicados
- **Renderizado**: La interfaz no afecta FPS cuando está cerrada

### Seguridad

- **Modo desarrollo**: La interfaz solo funciona en localhost/127.0.0.1
- **Validación**: El método `playAnimationByName` valida parámetros antes de ejecutar
- **XSS**: Usar `escapeHtml()` para prevenir XSS en nombres de animaciones

### Casos Edge

- **Personaje no existe**: Mostrar mensaje de error apropiado
- **Mixer no inicializado**: Mostrar mensaje de error, no romper el juego
- **Animación no existe**: Mostrar mensaje de error, no romper el juego
- **Múltiples clicks rápidos**: El sistema maneja correctamente (detiene animación anterior)
- **Interfaz abierta durante animación del juego**: No interfiere, solo reproduce cuando se hace click

### Compatibilidad

- **Modo desarrollo**: Solo funciona en localhost/127.0.0.1
- **Refactorización del debugger**: Mantiene compatibilidad total con funcionalidad existente
- **AnimationMixerSystem**: El nuevo método no afecta la lógica existente

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Clases ES6 para organización
  - Herencia con `extends` para reutilización de código
  - Event listeners para interacciones
  - DOM API para creación de elementos de interfaz

- **Sistema ECS**: 
  - Métodos públicos para acceso externo
  - Validación de parámetros antes de ejecutar
  - Logging con `debugLogger` en lugar de `console.log`

- **Interfaces de Desarrollo**: 
  - Clase base para código común
  - Configuración mediante objetos de configuración
  - Estilos consistentes entre interfaces

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna - se reutilizan dependencias existentes

### Variables de Entorno (si aplica)
Ninguna nueva - se usa detección de modo desarrollo existente

## Archivos Principales Involucrados

1. `frontend/src/debug/ui/base-interface.js` - Clase base para interfaces de desarrollo (NUEVO)
2. `frontend/src/debug/ui/debug-interface.js` - Refactorizado para usar BaseInterface
3. `frontend/src/debug/ui/animation-tester.js` - Interfaz de prueba de animaciones (NUEVO)
4. `frontend/src/ecs/systems/animation-mixer-system.js` - Método público `playAnimationByName()`
5. `frontend/src/debug/dev-exposure.js` - Integración de AnimationTester
6. `frontend/src/config/animation-config.js` - `ANIMATION_FILES` con todas las animaciones

## Testing

### Tests a Crear/Modificar
- No se requieren tests automatizados para MVP (testing manual)

### Escenarios de Prueba

1. **Refactorización del Debugger:**
   - Abrir debugger con F4
   - Verificar que todas las funcionalidades siguen funcionando
   - Verificar que los estilos se mantienen

2. **Método playAnimationByName:**
   - Probar desde consola del navegador
   - Verificar que reproduce animaciones correctamente
   - Verificar manejo de errores (entidad no existe, animación no existe)

3. **Interfaz AnimationTester:**
   - Abrir con F6
   - Verificar que lista todas las animaciones
   - Verificar búsqueda por nombre
   - Probar reproducir diferentes animaciones
   - Verificar mensajes de error/info

4. **Modo Desarrollo:**
   - Verificar que solo funciona en localhost/127.0.0.1
   - Verificar que `window.animationTester` está disponible

## Deployment

### Orden de Deployment

1. Frontend: Rebuild Docker image y restart container
2. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment

- [ ] Verificar que el debugger sigue funcionando correctamente (F4)
- [ ] Verificar que la interfaz de animaciones funciona (F6)
- [ ] Verificar que lista todas las animaciones correctamente
- [ ] Verificar que se pueden reproducir animaciones
- [ ] Verificar que solo funciona en modo desarrollo
- [ ] Verificar logs de consola para errores

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
