# JDG-034 - Bloquear Movimiento WASD Durante Animaciones de Habilidades

## Descripción de la Tarea

Implementar bloqueo de movimiento WASD durante animaciones de habilidades cuando la acción no tiene `hasMovement: true`. Actualmente, el jugador puede moverse libremente con WASD durante cualquier animación de habilidad, lo cual rompe la inmersión, afecta el balance del combate y es inconsistente con el diseño de acciones que tienen `preventInterruption`.

**Comportamiento actual:**
- El jugador puede presionar WASD durante cualquier animación de habilidad
- `InputSystem` siempre calcula `input.moveDirection` basado en teclas presionadas, independientemente de si hay una acción activa
- `PhysicsSystem` aplica aceleración basada en `input.moveDirection` incluso cuando `combat.activeAction` está activa
- No hay verificación para bloquear el movimiento normal cuando hay una acción de combate activa

**Comportamiento esperado:**
- Cuando `combat.activeAction` está activa y la acción NO tiene `hasMovement: true`, el movimiento con WASD debe estar bloqueado
- El jugador NO debe poder moverse con WASD durante animaciones de ataque, habilidades especiales, parry, etc.
- Solo las habilidades que específicamente requieren movimiento (como dodge con `hasMovement: true`) deben permitir movimiento
- El movimiento de la habilidad (si tiene `hasMovement: true`) debe funcionar correctamente según su configuración
- Una vez que la animación termina (`combat.activeAction` es null), el movimiento normal debe volver a funcionar

## Criterios de Aceptación

1. ❌ Cuando `combat.activeAction` está activa y la acción NO tiene `hasMovement: true`, el jugador NO puede moverse con WASD
2. ❌ Cuando `combat.activeAction` está activa y la acción tiene `hasMovement: true` (como dodge), el movimiento funciona según configuración de la acción
3. ❌ Cuando `combat.activeAction` es null (animación terminó), el movimiento normal vuelve a funcionar
4. ❌ Los ataques básicos bloquean movimiento durante su animación
5. ❌ Las habilidades especiales bloquean movimiento durante su animación
6. ❌ Parry bloquea movimiento durante su animación
7. ❌ Dodge permite movimiento según su configuración (`hasMovement: true`)
8. ❌ No hay regresiones en otras funcionalidades de movimiento o combate

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js
- ECS (Entity Component System)
- Sistema de combate

## Pasos de Implementación

### Paso 1: Agregar Import de COMBAT_ACTIONS en InputSystem

**Descripción:**
Agregar el import necesario para acceder a la configuración de acciones de combate en `InputSystem`.

**Archivos a modificar:**
- `frontend/src/ecs/systems/input-system.js`

**Detalles de implementación:**
```javascript
// Agregar al inicio del archivo, después de los otros imports
import { COMBAT_ACTIONS } from '../../config/combat-actions-config.js';
```

**Notas:**
- Este import es necesario para acceder a `COMBAT_ACTIONS[combat.activeAction]` y verificar `hasMovement`
- Verificar que el import no cause dependencias circulares

---

### Paso 2: Agregar Verificación de Bloqueo de Movimiento en InputSystem

**Descripción:**
Modificar `InputSystem.update()` para verificar si hay una acción activa que bloquea movimiento antes de calcular `moveDirection`.

**Archivos a modificar:**
- `frontend/src/ecs/systems/input-system.js`

**Detalles de implementación:**
```javascript
update(_deltaTime) {
    const entities = this.getEntities();

    for (const entityId of entities) {
        const input = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.INPUT);
        const physics = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.PHYSICS);
        const combat = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.COMBAT);

        if (!input || !physics) continue;

        // Limpiar estados de frame anterior
        input.clearFrame();

        // ... código existente de actualización de teclas ...

        // Verificar si hay acción activa que bloquea movimiento
        let shouldBlockMovement = false;
        if (combat && combat.activeAction) {
            const actionConfig = COMBAT_ACTIONS[combat.activeAction];
            // Bloquear movimiento si la acción NO tiene hasMovement: true
            if (!actionConfig || !actionConfig.hasMovement) {
                shouldBlockMovement = true;
            }
        }

        // Obtener rotación de la cámara desde RenderComponent
        const render = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.RENDER);
        const cameraRotation = render && render.rotationY !== undefined ? render.rotationY : 0;

        // Calcular dirección de movimiento solo si no está bloqueado
        if (!shouldBlockMovement) {
            // ... código existente de cálculo de moveDirection (líneas 122-221) ...
        } else {
            // Bloquear movimiento: dejar moveDirection en 0
            input.moveDirection.x = ANIMATION_CONSTANTS.INPUT.DIRECTION.NONE;
            input.moveDirection.y = ANIMATION_CONSTANTS.INPUT.DIRECTION.NONE;
            if (!physics.isFlying) {
                input.moveDirection.z = ANIMATION_CONSTANTS.INPUT.DIRECTION.NONE;
            } else {
                input.moveDirection.z = 0;
            }
        }

        // ... resto del código existente (correr, saltar, combate, etc.) ...
    }
}
```

**Notas:**
- La verificación debe hacerse después de actualizar teclas pero antes de calcular `moveDirection`
- Si `shouldBlockMovement === true`, establecer `moveDirection` a 0 y saltar el cálculo normal
- Si `shouldBlockMovement === false`, ejecutar el cálculo normal de `moveDirection`
- Verificar que el código existente de cálculo de `moveDirection` (líneas 122-221) se mantiene intacto dentro del `if (!shouldBlockMovement)`

**Recursos útiles:**
- Análisis de arquitectura: `instructions/analysis/JDG-034-architecture-analysis_2026-01-14_18-24-26.md`

---

### Paso 3: Agregar Verificación de Bloqueo de Movimiento Normal en PhysicsSystem

**Descripción:**
Modificar `PhysicsSystem.updatePhysics()` para verificar si debemos bloquear la aceleración normal basada en `input.moveDirection` cuando hay una acción activa sin movimiento.

**Archivos a modificar:**
- `frontend/src/ecs/systems/physics-system.js`

**Detalles de implementación:**
```javascript
updatePhysics(timestep) {
    const entities = this.getEntities();
    
    for (const entityId of entities) {
        const physics = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.PHYSICS);
        const position = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.POSITION);
        const input = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.INPUT);
        const combat = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.COMBAT);
        
        if (!physics || !position) continue;
        
        // ... código existente de salto y vuelo (líneas 70-91) ...
        
        // Aplicar movimiento de acciones de combate (ya existe, líneas 93-143)
        if (input && combat && combat.activeAction) {
            const actionConfig = COMBAT_ACTIONS[combat.activeAction];
            
            if (actionConfig && actionConfig.hasMovement) {
                // ... código existente de movimiento de acción (líneas 100-137) ...
            }
        } else {
            // Si no hay acción activa, resetear flag
            if (render && render.mesh && render.mesh.userData) {
                render.mesh.userData.movementApplied = false;
            }
        }
        
        // Verificar si debemos bloquear movimiento normal
        let shouldBlockNormalMovement = false;
        if (combat && combat.activeAction) {
            const actionConfig = COMBAT_ACTIONS[combat.activeAction];
            // Bloquear movimiento normal si la acción NO tiene hasMovement: true
            if (!actionConfig || !actionConfig.hasMovement) {
                shouldBlockNormalMovement = true;
            }
        }
        
        // ... código existente de gravedad (líneas 145-148) ...
        
        // Actualizar velocidad con aceleración (líneas 150-153)
        physics.velocity.x += physics.acceleration.x * timestep;
        physics.velocity.y += physics.acceleration.y * timestep;
        physics.velocity.z += physics.acceleration.z * timestep;
        
        // ... código existente de fricción (líneas 155-167) ...
        
        // ... código existente de límites de velocidad (líneas 169-179) ...
        
        // Aplicar aceleración normal solo si no está bloqueado
        // NOTA: Esta sección reemplaza las líneas 233-249 del código actual
        if (!shouldBlockNormalMovement) {
            // Resetear aceleración antes de aplicar nuevo input (línea 226-231)
            physics.acceleration.x = ANIMATION_CONSTANTS.INPUT.DIRECTION.NONE;
            physics.acceleration.y = ANIMATION_CONSTANTS.INPUT.DIRECTION.NONE;
            if (physics.isFlying) {
                physics.acceleration.z = 0;
            }
            
            // Aplicar movimiento a física (código existente líneas 233-249)
            if (physics.isFlying) {
                if (input && (input.moveDirection.x !== 0 || input.moveDirection.y !== 0 || input.moveDirection.z !== 0)) {
                    const speed = physics.flySpeed;
                    physics.acceleration.x = input.moveDirection.x * speed;
                    physics.acceleration.y = input.moveDirection.y * speed;
                    physics.acceleration.z = input.moveDirection.z * speed;
                }
            } else if (input && (input.moveDirection.x !== 0 || input.moveDirection.y !== 0)) {
                const speed = input.isRunning ? ANIMATION_CONSTANTS.INPUT.RUN_SPEED : ANIMATION_CONSTANTS.INPUT.WALK_SPEED;
                physics.acceleration.x = input.moveDirection.x * speed;
                physics.acceleration.y = input.moveDirection.y * speed;
            }
        }
        // Si está bloqueado, no aplicar aceleración normal (ya está reseteada arriba)
        
        // ... resto del código existente (actualización de posición, resetear aceleración) ...
    }
}
```

**Notas:**
- **IMPORTANTE**: El código de aplicación de aceleración normal (líneas 233-249) debe moverse DENTRO del bloque `if (!shouldBlockNormalMovement)`
- El reset de aceleración (líneas 226-231) también debe estar dentro del bloque condicional
- Mantener el código existente de movimiento de acciones con `hasMovement: true` (ya implementado)
- La verificación debe hacerse después de aplicar movimiento de acciones de combate pero antes de aplicar aceleración normal

**Recursos útiles:**
- Análisis de arquitectura: `instructions/analysis/JDG-034-architecture-analysis_2026-01-14_18-24-26.md`

---

### Paso 4: Verificar Configuración de Acciones en combat-actions-config.js

**Descripción:**
Verificar que todas las acciones de combate tienen `hasMovement` configurado correctamente.

**Archivos a revisar:**
- `frontend/src/config/combat-actions-config.js`

**Detalles de implementación:**
Revisar que todas las acciones tienen `hasMovement` configurado:
- `attack`: `hasMovement: false` ✅
- `dodge`: `hasMovement: true` ✅
- `parry`: `hasMovement: false` ✅
- `specialAttack`: `hasMovement: false` ✅
- `heavyAttack`: `hasMovement: false` ✅
- `chargedAttack`: `hasMovement: false` ✅

**Notas:**
- Si alguna acción no tiene `hasMovement` configurado, agregarlo explícitamente
- Por defecto, si `hasMovement` no existe, se considera `false` (bloquea movimiento)
- Solo `dodge` debe tener `hasMovement: true`

---

### Paso 5: Testing Manual - Verificar Bloqueo de Movimiento

**Descripción:**
Probar manualmente que el bloqueo de movimiento funciona correctamente para todas las acciones.

**Archivos a modificar:**
- Ninguno (solo testing)

**Detalles de implementación:**

**Escenario 1 - Ataque básico:**
1. Presionar click izquierdo para atacar
2. Mientras la animación está en progreso, presionar WASD
3. **Verificar**: El jugador NO debe moverse

**Escenario 2 - Habilidad especial:**
1. Activar habilidad especial (tecla configurada)
2. Mientras la animación está en progreso, presionar WASD
3. **Verificar**: El jugador NO debe moverse

**Escenario 3 - Parry:**
1. Activar parry (tecla configurada)
2. Mientras la animación está en progreso, presionar WASD
3. **Verificar**: El jugador NO debe moverse

**Escenario 4 - Dodge:**
1. Activar dodge (Shift)
2. Mientras la animación está en progreso, presionar WASD
3. **Verificar**: El jugador SÍ debe moverse según configuración de dodge

**Escenario 5 - Fin de animación:**
1. Activar cualquier ataque
2. Esperar a que la animación termine completamente
3. Presionar WASD
4. **Verificar**: El movimiento normal debe volver a funcionar

**Escenario 6 - Movimiento normal sin acciones:**
1. No activar ninguna acción
2. Presionar WASD
3. **Verificar**: El movimiento normal debe funcionar correctamente

**Notas:**
- Probar cada escenario varias veces para asegurar consistencia
- Verificar que no hay regresiones en otras funcionalidades
- Si algún escenario falla, revisar el código del paso correspondiente

---

### Paso 6: Testing Manual - Verificar Casos Edge

**Descripción:**
Probar casos edge para asegurar que el bloqueo funciona correctamente en situaciones especiales.

**Archivos a modificar:**
- Ninguno (solo testing)

**Detalles de implementación:**

**Caso Edge 1 - Transiciones entre acciones:**
1. Activar un ataque
2. Inmediatamente después (antes de que termine), intentar activar otra acción
3. **Verificar**: El movimiento debe seguir bloqueado durante la primera animación

**Caso Edge 2 - Combos:**
1. Activar un combo (múltiples ataques en secuencia)
2. Durante el combo, presionar WASD
3. **Verificar**: El movimiento debe estar bloqueado durante todo el combo

**Caso Edge 3 - Cancelación de acciones:**
1. Activar un ataque
2. Si la acción se cancela de alguna manera, verificar que el movimiento vuelve a funcionar
3. **Verificar**: El movimiento debe volver a funcionar cuando `combat.activeAction` es null

**Caso Edge 4 - Vuelo durante acciones:**
1. Activar vuelo (triple salto)
2. Mientras está volando, activar un ataque
3. Presionar WASD durante la animación
4. **Verificar**: El movimiento debe estar bloqueado durante la animación, pero el vuelo debe seguir funcionando después

**Notas:**
- Estos casos edge son importantes para asegurar que el sistema funciona correctamente en todas las situaciones
- Si algún caso edge falla, puede requerir ajustes adicionales en el código

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-034_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Verificación de `combat.activeAction` es O(1) (acceso directo a componente)
- Acceso a `COMBAT_ACTIONS` es O(1) (objeto JavaScript)
- No hay impacto significativo en rendimiento
- Las verificaciones se hacen una vez por frame por entidad

### Seguridad
- No aplica - cambios puramente de lógica de juego en frontend

### Casos Edge
- **Transiciones entre acciones**: Asegurar que el bloqueo se aplica correctamente durante transiciones
- **Acciones con movimiento parcial**: Si hay acciones que requieren movimiento solo en ciertos momentos, verificar comportamiento
- **Cancelación de acciones**: Si una acción se cancela, el movimiento debe volver a funcionar inmediatamente
- **Acciones simultáneas**: Verificar comportamiento si hay múltiples sistemas intentando controlar movimiento
- **Vuelo durante acciones**: El bloqueo debe funcionar correctamente incluso cuando el jugador está volando

### Compatibilidad
- No rompe código existente
- Solo agrega verificaciones condicionales
- Mantiene comportamiento actual cuando no hay acciones activas
- Compatible con sistema de combate existente
- Compatible con sistema de vuelo existente

## Patrones de Código a Usar

- **Guard Clause Pattern**: Verificar condiciones temprano antes de procesar movimiento
- **Configuration Pattern**: Usar `COMBAT_ACTIONS[actionId].hasMovement` para determinar comportamiento
- **Separation of Concerns**: Mantener responsabilidades claras entre InputSystem, PhysicsSystem y CombatSystem

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna - solo usa dependencias existentes.

### Variables de Entorno (si aplica)
Ninguna.

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/input-system.js` - Agregar verificación de bloqueo de movimiento
2. `frontend/src/ecs/systems/physics-system.js` - Agregar verificación de bloqueo de aceleración normal
3. `frontend/src/config/combat-actions-config.js` - Verificar configuración de `hasMovement` (solo revisión)

## Testing

### Tests a Crear/Modificar
No se requieren tests unitarios para este cambio (testing manual es suficiente).

### Escenarios de Prueba
1. **Ataque básico**: Verificar que bloquea movimiento durante animación
2. **Habilidades especiales**: Verificar que bloquean movimiento durante animación
3. **Parry**: Verificar que bloquea movimiento durante animación
4. **Dodge**: Verificar que permite movimiento durante animación
5. **Fin de animación**: Verificar que movimiento vuelve a funcionar
6. **Movimiento normal**: Verificar que funciona cuando no hay acciones activas
7. **Combos**: Verificar que bloquea movimiento durante combos
8. **Transiciones**: Verificar que bloqueo funciona durante transiciones entre acciones

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos JavaScript (no requiere rebuild de Docker si se usa hot reload)
2. Verificar en ambiente local con Docker Compose
3. Verificar que no hay errores en consola del navegador

### Verificación Post-Deployment
- [ ] Verificar frontend en navegador
- [ ] Probar todas las acciones de combate y verificar bloqueo de movimiento
- [ ] Verificar que dodge sigue permitiendo movimiento
- [ ] Verificar que movimiento normal funciona cuando no hay acciones activas
- [ ] Verificar logs de consola del navegador (no debe haber errores)
- [ ] Verificar que no hay regresiones en otras funcionalidades

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
