# JDG-039 - Sistema de Temperatura Ambiental y Sistema Sol/Luna Gleason

## Descripción de la Tarea

Implementar el sistema de temperatura ambiental y el sistema de sol/luna con perspectiva Gleason para calcular la temperatura base de bloques espaciales. Este sistema permite que las partículas ajusten su temperatura hacia la temperatura ambiental, y es requisito previo para sistemas de disipación de temperatura y transiciones por temperatura.

**Comportamiento actual:**
- Los bloques espaciales (`WorldBloque`) existen pero no calculan temperatura ambiental
- No existe sistema de sol/luna para determinar posición solar y ciclo día/noche
- Las partículas tienen campo `temperatura` pero no hay sistema que calcule temperatura ambiental
- No hay factores ambientales (altitud, agua, albedo) que afecten la temperatura

**Comportamiento esperado:**
- Sistema de sol/luna implementado con proyección Gleason (centro = polo norte, borde = polo sur)
- Cálculo de temperatura solar según posición del sol y latitud (distancia del centro)
- Modificadores de temperatura ambiental: altitud, proximidad al agua, albedo (tipo de superficie)
- Integración con `WorldBloque` para calcular y almacenar temperatura base
- Funciones auxiliares para obtener temperatura ambiental en cualquier posición
- Ciclo día/noche funcional que afecta la temperatura

## Criterios de Aceptación

1. ✅ Sistema `SolSystem` implementado con movimiento circular alrededor del centro
2. ✅ Sistema `LunaSystem` implementado con movimiento circular y fases lunares
3. ✅ Función `calculate_solar_temperature()` calcula temperatura según latitud y posición del sol
4. ✅ Función `get_altitude_modifier()` calcula modificador por altitud (-6.5°C por cada 1000 unidades)
5. ✅ Función `get_water_modifier()` calcula modificador por proximidad al agua
6. ✅ Función `get_albedo_modifier()` calcula modificador por tipo de superficie
7. ✅ Función `calculate_cell_temperature()` integra todos los modificadores
8. ✅ `WorldBloque.calcular_temperatura()` actualizado para usar sistema celestial
9. ✅ Ciclo día/noche funcional (determina si es día o noche según posición del sol)
10. ✅ Funciones auxiliares documentadas y con ejemplos de uso

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [ ] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Cálculos matemáticos: Trigonometría, coordenadas polares
- NumPy (opcional, para optimización futura)

## Pasos de Implementación

### Paso 1: Crear Servicio de Tiempo Celestial (Backend)

**Descripción:**
Crear `CelestialTimeService` que gestiona el tiempo del juego y cálculos celestiales de forma autoritativa. El backend controla el tiempo, y el frontend solo renderiza visualmente basándose en este tiempo. El sistema está diseñado para ser extensible y soportar futuras funcionalidades (hechizos, estadísticas, eventos).

**Archivos a modificar/crear:**
- `backend/src/services/celestial_time_service.py` (nuevo)

**Detalles de implementación:**
```python
"""
Servicio de Tiempo del Juego (Autoritativo)

El backend controla el tiempo del juego como single source of truth.
El frontend recibe este tiempo y calcula posiciones visuales localmente.
"""

import math
from typing import Optional


class CelestialTimeService:
    """
    Servicio de Tiempo Celestial - Autoritativo
    
    El backend controla el tiempo del juego y proporciona cálculos celestiales.
    El frontend recibe este tiempo y calcula posiciones visuales localmente.
    
    Este servicio está diseñado para ser extensible y soportar:
    - Cálculos de temperatura (actual)
    - Modificadores de hechizos según fase lunar (futuro)
    - Estadísticas de personajes según ciclo solar/lunar (futuro)
    - Eventos especiales (eclipses, alineaciones) (futuro)
    """
    
    def __init__(
        self,
        tiempo_inicial: float = 0.0,
        velocidad_tiempo: float = 1.0
    ):
        """
        Args:
            tiempo_inicial: Tiempo inicial del juego en segundos
            velocidad_tiempo: Multiplicador de velocidad (1.0 = tiempo real, 60.0 = 60x más rápido)
        """
        self.tiempo_juego = tiempo_inicial  # Tiempo del juego en segundos (autoritativo)
        self.velocidad_tiempo = velocidad_tiempo
        self.tiempo_inicio = tiempo_inicial
    
    def update(self, delta_time: float):
        """
        Actualizar tiempo del juego
        
        Args:
            delta_time: Tiempo transcurrido en segundos (tiempo real)
        """
        self.tiempo_juego += delta_time * self.velocidad_tiempo
    
    def get_time(self) -> float:
        """
        Obtener tiempo actual del juego en segundos
        
        Returns:
            Tiempo del juego en segundos
        """
        return self.tiempo_juego
    
    def get_sun_angle(self) -> float:
        """
        Calcular ángulo del sol según tiempo del juego
        
        El sol gira en sentido horario alrededor del centro.
        Una rotación completa = 1 día del juego (24 horas reales).
        
        Returns:
            Ángulo en radianes (0 = norte, π/2 = este, π = sur, 3π/2 = oeste)
        """
        # Velocidad angular: 2π radianes en 24 horas
        velocidad_angular = (2 * math.pi) / (24 * 60 * 60)
        angulo = (self.tiempo_juego * velocidad_angular) % (2 * math.pi)
        return angulo
    
    def get_luna_angle(self) -> float:
        """
        Calcular ángulo de la luna según tiempo del juego
        
        La luna gira más lento que el sol (ciclo de ~28 días).
        
        Returns:
            Ángulo en radianes
        """
        # Velocidad angular: 2π radianes en 28 días
        velocidad_angular = (2 * math.pi) / (28 * 24 * 60 * 60)
        angulo = (self.tiempo_juego * velocidad_angular + math.pi) % (2 * math.pi)  # Empieza opuesta al sol
        return angulo
    
    def get_luna_phase(self) -> float:
        """
        Calcular fase lunar según tiempo del juego
        
        Returns:
            Fase lunar: 0.0 = luna nueva, 0.25 = cuarto creciente, 
                        0.5 = luna llena, 0.75 = cuarto menguante
        """
        angulo = self.get_luna_angle()
        return (angulo / (2 * math.pi)) % 1.0
    
    def get_current_hour(self) -> float:
        """
        Obtener hora actual del día (0-24)
        
        Returns:
            Hora del día (0.0 = medianoche, 12.0 = mediodía, 24.0 = medianoche siguiente)
        """
        angulo_sol = self.get_sun_angle()
        # Ajustar para que 0° = medianoche
        angulo_ajustado = (angulo_sol + math.pi) % (2 * math.pi)
        hora = (angulo_ajustado / (2 * math.pi)) * 24.0
        return hora
    
    def get_sun_intensity_at(self, celda_x: float, celda_y: float) -> float:
        """
        Obtener intensidad solar en una posición (0.0 a 1.0)
        
        Útil para cálculos de temperatura y futuros efectos (hechizos solares, etc.)
        
        Args:
            celda_x: Coordenada X de la celda
            celda_y: Coordenada Y de la celda
        
        Returns:
            Intensidad solar: 1.0 cuando el sol está directamente arriba, 
                             0.0 cuando está opuesto (noche)
        """
        import math
        radio = math.sqrt(celda_x * celda_x + celda_y * celda_y)
        angulo = math.atan2(celda_y, celda_x)
        angulo_sol = self.get_sun_angle()
        
        # Diferencia angular
        diferencia_angular = abs(angulo - angulo_sol)
        if diferencia_angular > math.pi:
            diferencia_angular = 2 * math.pi - diferencia_angular
        
        # Intensidad: coseno de la diferencia angular
        intensidad = math.cos(diferencia_angular)
        
        # Solo positivo (día)
        return max(0.0, intensidad)
    
    def is_daytime_at(self, celda_x: float, celda_y: float) -> bool:
        """
        Determinar si es de día en una posición
        
        Útil para cálculos de temperatura y futuros efectos (bonificaciones diurnas, etc.)
        
        Args:
            celda_x: Coordenada X de la celda
            celda_y: Coordenada Y de la celda
        
        Returns:
            True si es de día, False si es de noche
        """
        import math
        radio = math.sqrt(celda_x * celda_x + celda_y * celda_y)
        angulo = math.atan2(celda_y, celda_x)
        angulo_sol = self.get_sun_angle()
        
        # Diferencia angular entre el punto y el sol
        diferencia_angular = abs(angulo - angulo_sol)
        
        # Normalizar a 0-π
        if diferencia_angular > math.pi:
            diferencia_angular = 2 * math.pi - diferencia_angular
        
        # Si el sol está "cerca" del punto (dentro de 90°), es de día
        return diferencia_angular < math.pi / 2
    
    def get_celestial_state(self) -> dict:
        """
        Obtener estado completo celestial (para otros sistemas)
        
        Útil para sistemas futuros que necesiten información celestial completa
        (hechizos, estadísticas, eventos, etc.)
        
        Returns:
            Diccionario con estado celestial completo:
            {
                "time": float,              # Tiempo del juego en segundos
                "sun_angle": float,          # Ángulo del sol en radianes
                "luna_angle": float,        # Ángulo de la luna en radianes
                "luna_phase": float,         # Fase lunar (0.0 a 1.0)
                "current_hour": float,       # Hora del día (0-24)
                "is_daytime": bool           # Es de día (promedio mundial, simplificado)
            }
        """
        return {
            "time": self.tiempo_juego,
            "sun_angle": self.get_sun_angle(),
            "luna_angle": self.get_luna_angle(),
            "luna_phase": self.get_luna_phase(),
            "current_hour": self.get_current_hour(),
            "is_daytime": self.get_current_hour() >= 6.0 and self.get_current_hour() <= 18.0  # Simplificado
        }
```

**Notas:**
- El backend gestiona el tiempo del juego y cálculos celestiales (autoritativo)
- Las funciones calculan ángulos desde el tiempo (deterministas)
- El frontend usará estos ángulos para renderizar visualmente
- El sistema está diseñado para ser extensible:
  - `get_celestial_state()` proporciona estado completo para otros sistemas
  - `get_sun_intensity_at()` y `is_daytime_at()` preparados para efectos futuros
  - `get_luna_phase()` preparado para modificadores de hechizos
- **⚠️ READMEs:** Crear/actualizar `backend/src/services/README.md` para documentar el nuevo servicio y casos de uso futuros

**Recursos útiles:**
- Documentación: `Juego de Dioses/Ideas/32-Sistema-Sol-Luna-Gleason.md`

---

### Paso 2: Actualizar Funciones de Temperatura para Usar GameTimeService

**Descripción:**
Actualizar las funciones de temperatura para usar `GameTimeService` en lugar de un sistema celestial completo. Las funciones solo necesitan el tiempo del juego para calcular posiciones.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py` (modificar para usar GameTimeService)

**Detalles de implementación:**
```python
# En temperature_service.py, actualizar calculate_solar_temperature:

def calculate_solar_temperature(
    celda_x: float,
    celda_y: float,
    celestial_time_service: 'CelestialTimeService',  # Usar CelestialTimeService
    radio_maximo: float = 1000.0
) -> float:
    """
    Calcular temperatura base según latitud (distancia del centro) y posición del sol
    
    Args:
        celda_x: Coordenada X de la celda
        celda_y: Coordenada Y de la celda
        game_time_service: Servicio de tiempo del juego
        radio_maximo: Radio máximo del mundo (unidades)
    
    Returns:
        Temperatura base en grados Celsius
    """
    # ... (código de latitud igual que antes) ...
    
    # Obtener ángulo del sol desde tiempo del juego
    angulo_sol = game_time_service.get_sun_angle()
    
    # Calcular intensidad solar
    radio = math.sqrt(celda_x * celda_x + celda_y * celda_y)
    angulo = math.atan2(celda_y, celda_x)
    
    # Diferencia angular entre el punto y el sol
    diferencia_angular = abs(angulo - angulo_sol)
    if diferencia_angular > math.pi:
        diferencia_angular = 2 * math.pi - diferencia_angular
    
    # Intensidad solar: coseno de la diferencia angular
    intensidad_solar = max(0.0, math.cos(diferencia_angular))
    
    # ... (resto del código igual) ...
```

**Notas:**
- Las funciones de temperatura ahora usan `GameTimeService` en lugar de `CelestialSystem`
- El cálculo es determinista: mismo tiempo = misma temperatura
- El frontend no necesita conocer estas funciones, solo el tiempo del juego

---

### Paso 3: Integrar con WorldBloque (Actualizado)

**Descripción:**
Extender `WorldBloque` para calcular temperatura usando `GameTimeService` y `TemperatureService`.

**Archivos a modificar/crear:**
- `backend/src/services/world_bloque.py` (extender con calcular_temperatura)

**Detalles de implementación:**
```python
# En world_bloque.py, agregar método:

async def calcular_temperatura(
    self,
    celestial_time_service: 'CelestialTimeService',
    tipo_particula_superficie: Optional[str] = None
) -> float:
    """
    Calcular temperatura ambiental del bloque
    
    Args:
        celestial_time_service: Servicio de tiempo celestial (autoritativo)
        tipo_particula_superficie: Nombre del tipo de partícula dominante en la superficie
    
    Returns:
        Temperatura ambiental en grados Celsius
    """
    from src.services.temperature_service import calculate_cell_temperature
    
    # Calcular temperatura en el centro del bloque
    centro_x = (self.bloque_x + 0.5) * self.tamano_bloque
    centro_y = (self.bloque_y + 0.5) * self.tamano_bloque
    centro_z = (self.bloque_z + 0.5) * self.tamano_bloque
    
    temperatura = await calculate_cell_temperature(
        celda_x=centro_x,
        celda_y=centro_y,
        celda_z=centro_z,
        bloque_id=self.bloque_id,
        celestial_time_service=celestial_time_service,
        tipo_particula_superficie=tipo_particula_superficie
    )
    
    # Almacenar temperatura calculada (opcional, para cache)
    self._temperatura_cache = temperatura
    
    return temperatura
```

**Notas:**
- `CelestialSystem` orquesta ambos sistemas (sol y luna)
- Proporciona funciones de utilidad para día/noche e intensidad solar
- Permite ajustar velocidad del tiempo del juego

---

### Paso 4: Crear Funciones de Temperatura - Cálculo Solar (Ya actualizado en Paso 2)

**Descripción:**
Crear función para calcular temperatura solar según latitud (distancia del centro) y posición del sol.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py` (nuevo)

**Detalles de implementación:**
```python
"""
Servicio de Temperatura Ambiental

Calcula temperatura ambiental según múltiples factores:
- Temperatura solar (latitud + posición del sol)
- Modificador por altitud
- Modificador por proximidad al agua
- Modificador por albedo (tipo de superficie)
"""

import math
from typing import Optional
from src.services.celestial_system import CelestialSystem


def calculate_solar_temperature(
    celda_x: float,
    celda_y: float,
    celestial_system: CelestialSystem,
    radio_maximo: float = 1000.0
) -> float:
    """
    Calcular temperatura base según latitud (distancia del centro) y posición del sol
    
    Proyección Gleason:
    - Centro (radio 0) = Polo Norte = -20°C base
    - Ecuador (radio ~50%) = 30°C base (máximo)
    - Borde (radio 100%) = Polo Sur = -40°C base
    
    Args:
        celda_x: Coordenada X de la celda
        celda_y: Coordenada Y de la celda
        celestial_time_service: Servicio de tiempo celestial para obtener posición del sol
        radio_maximo: Radio máximo del mundo (unidades)
    
    Returns:
        Temperatura base en grados Celsius
    """
    # Convertir a coordenadas polares
    radio = math.sqrt(celda_x * celda_x + celda_y * celda_y)
    radio_ecuador = radio_maximo * 0.5  # Ecuador está a mitad del radio
    
    # Temperatura base según distancia del centro (latitud)
    if radio <= radio_ecuador:
        # Del centro al ecuador: -20°C a 30°C
        factor = radio / radio_ecuador if radio_ecuador > 0 else 0.0
        temp_base = -20.0 + (factor * 50.0)
    else:
        # Del ecuador al borde: 30°C a -40°C
        factor = (radio - radio_ecuador) / (radio_maximo - radio_ecuador) if (radio_maximo - radio_ecuador) > 0 else 0.0
        temp_base = 30.0 - (factor * 70.0)
    
    # Intensidad solar según posición del sol
    intensidad_solar = celestial_time_service.get_sun_intensity_at(celda_x, celda_y)
    
    # Ajuste día/noche: Día +15°C, Noche -10°C (diferencia de 25°C)
    ajuste_dia_noche = (intensidad_solar * 25.0) - 10.0
    
    # Temperatura final
    temperatura_final = temp_base + ajuste_dia_noche
    
    return temperatura_final
```

**Notas:**
- La temperatura base varía según la distancia del centro (latitud en proyección Gleason)
- El ajuste día/noche depende de la intensidad solar
- Los valores son configurables y pueden ajustarse según necesidades del juego

---

### Paso 5: Crear Funciones de Temperatura - Modificadores

**Descripción:**
Crear funciones para calcular modificadores de temperatura: altitud, agua, albedo.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py` (agregar funciones de modificadores)

**Detalles de implementación:**
```python
def get_altitude_modifier(altitud_z: float) -> float:
    """
    Calcular modificador de temperatura por altitud
    
    Gradiente adiabático: -6.5°C por cada 1000 unidades de altura
    
    Args:
        altitud_z: Altitud en unidades (celdas)
    
    Returns:
        Modificador de temperatura en grados Celsius
    """
    return -6.5 * (altitud_z / 1000.0)


async def get_water_modifier(
    celda_x: float,
    celda_y: float,
    celda_z: float,
    bloque_id: str,
    radio_busqueda: float = 10.0
) -> float:
    """
    Calcular modificador de temperatura por proximidad al agua
    
    El agua tiene efecto moderador: reduce extremos de temperatura.
    Más cerca del agua = temperatura más estable.
    
    Args:
        celda_x: Coordenada X de la celda
        celda_y: Coordenada Y de la celda
        celda_z: Coordenada Z (altura) de la celda
        bloque_id: ID del bloque
        radio_busqueda: Radio de búsqueda de agua (celdas)
    
    Returns:
        Modificador de temperatura en grados Celsius
        (positivo en invierno, negativo en verano, simplificado aquí)
    """
    from src.services.particula_service import get_particulas_vecinas
    
    # Buscar partículas de agua cercanas
    particulas_cercanas = await get_particulas_vecinas(
        bloque_id=bloque_id,
        celda_x=celda_x,
        celda_y=celda_y,
        celda_z=celda_z,
        radio=radio_busqueda
    )
    
    # Encontrar distancia mínima al agua
    distancia_agua_minima = float('inf')
    
    for particula in particulas_cercanas:
        tipo_nombre = particula.get('tipo_nombre', '').lower()
        if tipo_nombre in ['agua', 'oceano', 'agua_sucia']:
            # Calcular distancia
            dx = particula['celda_x'] - celda_x
            dy = particula['celda_y'] - celda_y
            dz = particula['celda_z'] - celda_z
            distancia = math.sqrt(dx*dx + dy*dy + dz*dz)
            distancia_agua_minima = min(distancia_agua_minima, distancia)
    
    if distancia_agua_minima == float('inf'):
        return 0.0  # No hay agua cerca
    
    # Efecto moderador: más cerca del agua = temperatura más estable
    # Máximo efecto dentro de 5 celdas
    factor = max(0.0, 1.0 - (distancia_agua_minima / 5.0))
    
    # Simplificado: efecto moderador de ±5°C
    # En implementación futura, debería variar por estación
    return factor * 5.0


def get_albedo_modifier(tipo_particula_nombre: Optional[str] = None) -> float:
    """
    Calcular modificador de temperatura por albedo (tipo de superficie)
    
    Albedo alto (superficies claras) = reflejan luz = más frío
    Albedo bajo (superficies oscuras) = absorben luz = más caliente
    
    Args:
        tipo_particula_nombre: Nombre del tipo de partícula (superficie)
    
    Returns:
        Modificador de temperatura en grados Celsius
    """
    # Valores de albedo por tipo (0.0 = absorbe todo, 1.0 = refleja todo)
    albedos = {
        'nieve': 0.9,      # Refleja 90% → -15°C
        'hielo': 0.8,      # Refleja 80% → -12°C
        'arena': 0.3,      # Refleja 30% → +5°C
        'tierra': 0.2,     # Refleja 20% → +3°C
        'piedra': 0.1,     # Refleja 10% → +8°C
        'roca': 0.1,       # Refleja 10% → +8°C
        'agua': 0.1,       # Refleja 10% (pero tiene capacidad calorífica)
        'vegetacion': 0.2,  # Refleja 20% → +2°C
        'hierba': 0.2,     # Refleja 20% → +2°C
        'hojas': 0.2,      # Refleja 20% → +2°C
        'madera': 0.2,     # Refleja 20% → +2°C
    }
    
    if tipo_particula_nombre is None:
        tipo_particula_nombre = 'tierra'  # Default
    
    tipo_lower = tipo_particula_nombre.lower()
    albedo = albedos.get(tipo_lower, 0.2)  # Default: albedo medio
    
    # Albedo alto = más frío, albedo bajo = más caliente
    # Escala: -10°C a +10°C
    return (0.5 - albedo) * 20.0
```

**Notas:**
- El modificador de altitud usa gradiente adiabático estándar (-6.5°C/1000m)
- El modificador de agua requiere consultar partículas cercanas (async)
- El modificador de albedo es una función pura (no requiere async)
- Los valores pueden ajustarse según necesidades del juego

---

### Paso 6: Crear Función Principal de Temperatura

**Descripción:**
Crear función principal que integra todos los modificadores para calcular temperatura final de una celda.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py` (agregar calculate_cell_temperature)

**Detalles de implementación:**
```python
async def calculate_cell_temperature(
    celda_x: float,
    celda_y: float,
    celda_z: float,
    bloque_id: str,
    celestial_time_service: 'CelestialTimeService',
    tipo_particula_superficie: Optional[str] = None,
    radio_maximo: float = 1000.0,
    radio_busqueda_agua: float = 10.0
) -> float:
    """
    Calcular temperatura ambiental final de una celda
    
    Integra todos los modificadores:
    - Temperatura solar (latitud + posición del sol)
    - Modificador por altitud
    - Modificador por proximidad al agua
    - Modificador por albedo (tipo de superficie)
    
    Args:
        celda_x: Coordenada X de la celda
        celda_y: Coordenada Y de la celda
        celda_z: Coordenada Z (altura) de la celda
        bloque_id: ID del bloque
        celestial_time_service: Servicio de tiempo celestial para obtener posición del sol
        tipo_particula_superficie: Nombre del tipo de partícula en la superficie (opcional)
        radio_maximo: Radio máximo del mundo
        radio_busqueda_agua: Radio de búsqueda de agua
    
    Returns:
        Temperatura ambiental final en grados Celsius
    """
    # 1. Temperatura base por latitud y posición del sol
    temp_solar = calculate_solar_temperature(
        celda_x=celda_x,
        celda_y=celda_y,
        celestial_time_service=celestial_time_service,
        radio_maximo=radio_maximo
    )
    
    # 2. Modificador por altitud
    mod_altitud = get_altitude_modifier(altitud_z=celda_z)
    
    # 3. Modificador por proximidad al agua
    mod_agua = await get_water_modifier(
        celda_x=celda_x,
        celda_y=celda_y,
        celda_z=celda_z,
        bloque_id=bloque_id,
        radio_busqueda=radio_busqueda_agua
    )
    
    # 4. Modificador por albedo (tipo de superficie)
    mod_albedo = get_albedo_modifier(tipo_particula_nombre=tipo_particula_superficie)
    
    # Temperatura final
    temperatura_final = temp_solar + mod_altitud + mod_agua + mod_albedo
    
    # Limitar a valores razonables
    temperatura_final = max(-50.0, min(60.0, temperatura_final))
    
    return temperatura_final
```

**Notas:**
- Esta función integra todos los modificadores
- Los límites de temperatura son configurables
- La función es async porque requiere consultar partículas cercanas (agua)

---

### Paso 5: Actualizar Exportaciones y __init__.py

**Detalles de implementación:**
```python
# En world_bloque.py, agregar método:

async def calcular_temperatura(
    self,
    celestial_system: 'CelestialSystem',
    tipo_particula_superficie: Optional[str] = None
) -> float:
    """
    Calcular temperatura ambiental del bloque
    
    Args:
        celestial_system: Sistema celestial para obtener posición del sol
        tipo_particula_superficie: Nombre del tipo de partícula dominante en la superficie
    
    Returns:
        Temperatura ambiental en grados Celsius
    """
    from src.services.temperature_service import calculate_cell_temperature
    
    # Calcular temperatura en el centro del bloque
    # El bloque representa una zona, usamos su centro como referencia
    centro_x = (self.bloque_x + 0.5) * self.tamano_bloque
    centro_y = (self.bloque_y + 0.5) * self.tamano_bloque
    centro_z = (self.bloque_z + 0.5) * self.tamano_bloque
    
    temperatura = await calculate_cell_temperature(
        celda_x=centro_x,
        celda_y=centro_y,
        celda_z=centro_z,
        bloque_id=self.bloque_id,
        celestial_system=celestial_system,
        tipo_particula_superficie=tipo_particula_superficie
    )
    
    # Almacenar temperatura calculada (opcional, para cache)
    self._temperatura_cache = temperatura
    
    return temperatura

def get_temperatura(self) -> Optional[float]:
    """
    Obtener temperatura cacheada del bloque
    
    Returns:
        Temperatura en grados Celsius, o None si no se ha calculado
    """
    return getattr(self, '_temperatura_cache', None)
```

**Notas:**
- El método calcula temperatura en el centro del bloque
- Almacena temperatura en cache para evitar recálculos
- Requiere `CelestialSystem` como parámetro
- **⚠️ READMEs:** Actualizar `backend/src/services/README.md` para documentar el nuevo método

---

### Paso 6: Crear Endpoint para Tiempo del Juego (Opcional)

**Descripción:**
Actualizar `__init__.py` del módulo services para exportar las nuevas clases y funciones.

**Archivos a modificar/crear:**
- `backend/src/services/__init__.py` (actualizar exportaciones)

**Detalles de implementación:**
```python
# Agregar al final del archivo __init__.py

# Servicio de Tiempo Celestial
from .celestial_time_service import CelestialTimeService

# Servicio de Temperatura
from .temperature_service import (
    calculate_solar_temperature,
    get_altitude_modifier,
    get_water_modifier,
    get_albedo_modifier,
    calculate_cell_temperature
)

__all__ = [
    # ... (exportaciones existentes)
    'CelestialTimeService',
    'calculate_solar_temperature',
    'get_altitude_modifier',
    'get_water_modifier',
    'get_albedo_modifier',
    'calculate_cell_temperature',
]
```

**Notas:**
- Exportar todas las clases y funciones nuevas
- Mantener compatibilidad con exportaciones existentes

---

### Paso 8: Crear/Actualizar Documentación

**Descripción:**
Crear o actualizar READMEs para documentar los nuevos sistemas.

**Archivos a modificar/crear:**
- `backend/src/services/README.md` (actualizar con nueva documentación)

**Detalles de implementación:**
Agregar secciones al README existente:

```markdown
## Servicio de Tiempo Celestial

**Archivo**: `celestial_time_service.py`

Servicio autoritativo que gestiona el tiempo del juego y cálculos celestiales. El backend controla el tiempo como single source of truth, y el frontend recibe este tiempo para calcular posiciones visuales.

Este servicio está diseñado para ser extensible y soportar:
- Cálculos de temperatura (actual)
- Modificadores de hechizos según fase lunar (futuro)
- Estadísticas de personajes según ciclo solar/lunar (futuro)
- Eventos especiales (eclipses, alineaciones) (futuro)

### Componentes

- **CelestialTimeService**: Gestiona tiempo del juego y calcula ángulos solares/lunares
- **get_celestial_state()**: Proporciona estado completo para otros sistemas
- **get_sun_intensity_at()**: Intensidad solar en posición (para temperatura y efectos futuros)
- **is_daytime_at()**: Determina si es de día (para efectos futuros)

**Ejemplo de uso**:
```python
from src.services import CelestialTimeService

celestial_service = CelestialTimeService(velocidad_tiempo=60.0)
celestial_service.update(delta_time=1.0)

# Obtener ángulo del sol
angulo_sol = celestial_service.get_sun_angle()

# Obtener fase lunar
fase_lunar = celestial_service.get_luna_phase()

# Obtener estado completo (para otros sistemas)
estado = celestial_service.get_celestial_state()

# Ejemplo futuro: Modificador de hechizos según fase lunar
def calcular_modificador_hechizo_agua(celestial_service):
    fase = celestial_service.get_luna_phase()
    if fase >= 0.45 and fase <= 0.55:  # Luna llena
        return 1.5  # +50% poder
    return 1.0
```

## Servicio de Temperatura

**Archivo**: `temperature_service.py`

Calcula temperatura ambiental según múltiples factores ambientales.

### Funciones

- **calculate_solar_temperature()**: Temperatura base según latitud y posición del sol
- **get_altitude_modifier()**: Modificador por altitud (-6.5°C/1000m)
- **get_water_modifier()**: Modificador por proximidad al agua
- **get_albedo_modifier()**: Modificador por tipo de superficie (albedo)
- **calculate_cell_temperature()**: Función principal que integra todos los modificadores

**Ejemplo de uso**:
```python
from src.services import calculate_cell_temperature, CelestialSystem

celestial_system = CelestialSystem()
temperatura = await calculate_cell_temperature(
    celda_x=100,
    celda_y=200,
    celda_z=50,
    bloque_id="bloque-uuid",
    celestial_system=celestial_system,
    tipo_particula_superficie="tierra"
)
```
```

**Notas:**
- Documentar todas las funciones y clases nuevas
- Incluir ejemplos de uso
- Explicar conceptos clave (proyección Gleason, modificadores)

---

### Paso 9: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-039_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Los cálculos de temperatura deben ser eficientes
- Considerar cache de temperaturas calculadas por bloque
- Las funciones de modificadores son puras (excepto agua que requiere consulta BD)
- Optimizar consultas de partículas cercanas (usar índices espaciales)

### Seguridad
- Validar entradas de coordenadas para evitar valores fuera de rango
- Usar consultas parametrizadas en `get_water_modifier()`
- Validar tipos de partícula en `get_albedo_modifier()`

### Casos Edge
- Coordenadas fuera del rango del mundo (radio máximo)
- Altitud negativa (bajo el nivel del mar)
- Sin partículas de agua cercanas (modificador = 0)
- Superficie sin tipo definido (usar albedo por defecto)
- Sol en posición extrema (medianoche/mediodía)

### Compatibilidad
- Mantener compatibilidad con sistema de bloques existente (JDG-038)
- No romper APIs existentes
- Extender sin modificar comportamiento actual

## Patrones de Código a Usar

- **Backend (FastAPI)**: 
  - Funciones async/await para operaciones I/O
  - Type hints en todas las funciones
  - Docstrings en formato Google
  - Manejo de errores apropiado

- **Cálculos**: 
  - Funciones puras cuando sea posible
  - Separar lógica de cálculo de lógica de I/O
  - Usar constantes para valores configurables

## Dependencias

### Nuevas Dependencias (si aplica)
```txt
# No se requieren nuevas dependencias
# Usar solo biblioteca estándar de Python (math)
```

### Variables de Entorno (si aplica)
- No se requieren nuevas variables de entorno

## Archivos Principales Involucrados

1. `backend/src/services/celestial_time_service.py` - Sistema celestial autoritativo (nuevo)
2. `backend/src/services/temperature_service.py` - Cálculo de temperatura (nuevo)
3. `backend/src/services/world_bloque.py` - Integración con bloques (modificar)
4. `backend/src/services/__init__.py` - Exportaciones (modificar)
5. `backend/src/services/README.md` - Documentación (actualizar)
6. `backend/src/api/routes/celestial.py` - Endpoints de tiempo celestial y temperatura (nuevo)
7. `backend/src/models/schemas.py` - Schemas Pydantic para tiempo celestial y temperatura (modificar)

## Deployment

### Orden de Deployment
1. Backend: Rebuild Docker image y restart container
2. Verificar en ambiente local con Docker Compose
3. No requiere cambios en base de datos
4. No requiere cambios en frontend

### Verificación Post-Deployment
- [ ] Verificar que CelestialTimeService se inicializa correctamente
- [ ] Verificar que calculate_cell_temperature retorna valores razonables
- [ ] Verificar que WorldBloque.calcular_temperatura funciona
- [ ] Verificar logs de Docker (sin errores)
- [ ] Probar endpoints `/api/v1/celestial/state` y `/api/v1/celestial/temperature`

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

