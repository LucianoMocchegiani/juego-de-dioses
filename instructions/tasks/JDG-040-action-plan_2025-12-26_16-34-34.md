# JDG-039 Frontend - Sistema de Temperatura Ambiental y Sistema Sol/Luna Gleason

## Descripción de la Tarea

Implementar la visualización del sistema celestial (sol/luna) y la integración con el sistema de iluminación dinámica en el frontend. El frontend recibe el estado celestial autoritativo del backend y calcula posiciones visuales para renderizar sol/luna en Three.js, además de actualizar la iluminación según el ciclo día/noche.

**Comportamiento actual:**
- No hay visualización de sol/luna en el cielo
- La iluminación es estática (no cambia según ciclo día/noche)
- No hay integración con el sistema celestial del backend
- No hay API client para endpoints celestiales

**Comportamiento esperado:**
- Sistema celestial del frontend que recibe estado del backend y calcula posiciones visuales
- Renderizado de sol/luna en Three.js con movimiento suave
- Iluminación dinámica que cambia según ciclo día/noche
- Sincronización periódica con el backend para mantener consistencia
- Interpolación suave de movimiento para evitar saltos visuales

## Criterios de Aceptación

1. [ ] API client para endpoints celestiales (`CelestialApi`)
2. [ ] Sistema celestial del frontend (`CelestialSystem`) que calcula posiciones visuales desde estado del backend
3. [ ] Renderizador de sol/luna (`CelestialRenderer`) con meshes en Three.js
4. [ ] Integración con sistema de iluminación para actualizar según ciclo día/noche
5. [ ] Sincronización periódica con backend (cada X segundos)
6. [ ] Interpolación suave de movimiento para evitar saltos
7. [ ] Integración en `app.js` y loop de animación
8. [ ] Documentación completa con ejemplos de uso

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js/JavaScript)
- [ ] Backend (FastAPI) - Ya completado
- [ ] Base de Datos (PostgreSQL) - No aplica
- [ ] Cache (Redis) - No aplica
- [ ] Docker/Infraestructura - No aplica

### Tecnologías Involucradas
- Frontend: JavaScript ES6+, Three.js
- API: Fetch API para comunicación con backend
- Matemáticas: Trigonometría para cálculos de posición visual

## Pasos de Implementación

### Paso 1: Crear API Client para Endpoints Celestiales

**Descripción:**
Crear `CelestialApi` para comunicarse con los endpoints `/api/v1/celestial/state` y `/api/v1/celestial/temperature`.

**Archivos a modificar/crear:**
- `frontend/src/api/endpoints/celestial.js` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Endpoints específicos para tiempo celestial y temperatura
 */
import { ApiClient } from '../client.js';

export class CelestialApi {
    /**
     * @param {ApiClient} client - Cliente API base
     */
    constructor(client) {
        this.client = client;
    }
    
    /**
     * Obtener estado completo del tiempo celestial
     * @returns {Promise<Object>} - Estado celestial:
     *   {
     *     time: number,              // Tiempo del juego en segundos
     *     sun_angle: number,          // Ángulo del sol en radianes
     *     luna_angle: number,        // Ángulo de la luna en radianes
     *     luna_phase: number,         // Fase lunar (0.0 a 1.0)
     *     current_hour: number,       // Hora del día (0-24)
     *     is_daytime: boolean         // Es de día
     *   }
     */
    async getState() {
        try {
            return await this.client.get('/celestial/state');
        } catch (error) {
            throw new Error(`Error al obtener estado celestial: ${error.message}`);
        }
    }
    
    /**
     * Calcular temperatura en una posición específica
     * @param {number} x - Coordenada X en celdas
     * @param {number} y - Coordenada Y en celdas
     * @param {number} z - Coordenada Z (altitud) en celdas
     * @param {string} bloqueId - ID del bloque
     * @param {string} [tipoParticulaSuperficie] - Tipo de partícula dominante (opcional)
     * @returns {Promise<Object>} - Temperatura calculada:
     *   {
     *     temperatura: number,  // Temperatura en grados Celsius
     *     x: number,
     *     y: number,
     *     z: number
     *   }
     */
    async calculateTemperature(x, y, z, bloqueId, tipoParticulaSuperficie = null) {
        try {
            const body = {
                x,
                y,
                z,
                bloque_id: bloqueId
            };
            if (tipoParticulaSuperficie) {
                body.tipo_particula_superficie = tipoParticulaSuperficie;
            }
            return await this.client.post('/celestial/temperature', body);
        } catch (error) {
            throw new Error(`Error al calcular temperatura: ${error.message}`);
        }
    }
}
```

**Notas:**
- Seguir el mismo patrón que `BloquesApi` y `ParticlesApi`
- Exportar en `frontend/src/api/endpoints/__init__.js`
- Agregar a `frontend/src/api/__init__.js` si es necesario

---

### Paso 2: Crear Sistema Celestial del Frontend

**Descripción:**
Crear `CelestialSystem` que recibe el estado celestial del backend y calcula posiciones visuales del sol/luna para renderizado.

**Archivos a modificar/crear:**
- `frontend/src/world/celestial-system.js` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Sistema Celestial del Frontend
 * 
 * Recibe el estado celestial autoritativo del backend y calcula posiciones visuales
 * para renderizado en Three.js. El backend controla el tiempo, el frontend solo renderiza.
 */
export class CelestialSystem {
    /**
     * @param {Object} [initialState] - Estado celestial inicial del backend
     */
    constructor(initialState = null) {
        // Estado celestial recibido del backend (autoritativo)
        this.celestialState = initialState || {
            time: 0,
            sun_angle: 0,
            luna_angle: 0,
            luna_phase: 0,
            current_hour: 12,
            is_daytime: true
        };
        
        // Estado anterior para interpolación
        this.previousState = null;
        
        // Radio del mundo para cálculos de posición (configurable)
        this.worldRadius = 1000.0;
        
        // Altura del sol/luna sobre el mundo (configurable)
        this.celestialHeight = 500.0;
    }
    
    /**
     * Actualizar estado celestial desde el backend
     * @param {Object} newState - Nuevo estado celestial del backend
     */
    update(newState) {
        // Guardar estado anterior para interpolación
        this.previousState = { ...this.celestialState };
        
        // Actualizar estado actual
        this.celestialState = { ...newState };
    }
    
    /**
     * Obtener posición visual del sol en coordenadas 3D
     * @param {number} [interpolationFactor] - Factor de interpolación (0.0 a 1.0) para movimiento suave
     * @returns {Object} - Posición {x, y, z}
     */
    getSunPosition(interpolationFactor = 0.0) {
        const state = this.getInterpolatedState(interpolationFactor);
        const angle = state.sun_angle;
        
        // Calcular posición en círculo alrededor del centro
        // El sol gira en sentido horario alrededor del centro
        const radius = this.worldRadius * 1.5; // Sol más lejos que el borde del mundo
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const z = this.celestialHeight;
        
        return { x, y, z };
    }
    
    /**
     * Obtener posición visual de la luna en coordenadas 3D
     * @param {number} [interpolationFactor] - Factor de interpolación (0.0 a 1.0) para movimiento suave
     * @returns {Object} - Posición {x, y, z}
     */
    getLunaPosition(interpolationFactor = 0.0) {
        const state = this.getInterpolatedState(interpolationFactor);
        const angle = state.luna_angle;
        
        // Calcular posición en círculo alrededor del centro
        // La luna gira más lento que el sol
        const radius = this.worldRadius * 1.5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const z = this.celestialHeight;
        
        return { x, y, z };
    }
    
    /**
     * Obtener fase lunar actual
     * @returns {number} - Fase lunar (0.0 = nueva, 0.5 = llena, 1.0 = nueva)
     */
    getLunaPhase() {
        return this.celestialState.luna_phase;
    }
    
    /**
     * Determinar si es de día (promedio mundial)
     * @returns {boolean} - True si es de día
     */
    isDaytime() {
        return this.celestialState.is_daytime;
    }
    
    /**
     * Obtener hora actual del día
     * @returns {number} - Hora del día (0-24)
     */
    getCurrentHour() {
        return this.celestialState.current_hour;
    }
    
    /**
     * Obtener intensidad solar promedio (para iluminación)
     * @returns {number} - Intensidad solar (0.0 a 1.0)
     */
    getSunIntensity() {
        const hour = this.getCurrentHour();
        // Intensidad máxima al mediodía (12:00), mínima a medianoche (0:00)
        if (hour >= 6 && hour <= 18) {
            // Día: intensidad basada en posición del sol
            const normalizedHour = (hour - 6) / 12; // 0.0 a 1.0
            return Math.sin(normalizedHour * Math.PI); // Curva senoidal suave
        } else {
            // Noche: intensidad mínima
            return 0.1; // Luz mínima de estrellas/luna
        }
    }
    
    /**
     * Obtener estado interpolado para movimiento suave
     * @param {number} factor - Factor de interpolación (0.0 = estado anterior, 1.0 = estado actual)
     * @returns {Object} - Estado interpolado
     */
    getInterpolatedState(factor) {
        if (!this.previousState || factor === 0.0) {
            return this.celestialState;
        }
        
        if (factor === 1.0) {
            return this.celestialState;
        }
        
        // Interpolar ángulos (usar shortest path)
        const interpolateAngle = (a1, a2, t) => {
            const diff = ((a2 - a1 + Math.PI) % (2 * Math.PI)) - Math.PI;
            return a1 + diff * t;
        };
        
        return {
            ...this.celestialState,
            sun_angle: interpolateAngle(this.previousState.sun_angle, this.celestialState.sun_angle, factor),
            luna_angle: interpolateAngle(this.previousState.luna_angle, this.celestialState.luna_angle, factor)
        };
    }
}
```

**Notas:**
- El sistema calcula posiciones visuales desde el estado del backend
- Incluye interpolación para movimiento suave entre actualizaciones
- Métodos helper para obtener información útil (fase lunar, intensidad solar, etc.)

---

### Paso 3: Crear Renderizador de Sol/Luna

**Descripción:**
Crear `CelestialRenderer` que renderiza el sol y la luna en Three.js usando las posiciones calculadas por `CelestialSystem`.

**Archivos a modificar/crear:**
- `frontend/src/world/celestial-renderer.js` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Renderizador de Sol y Luna en Three.js
 * 
 * Renderiza visualmente el sol y la luna en la escena usando las posiciones
 * calculadas por CelestialSystem.
 */
import * as THREE from 'three';
import { CelestialSystem } from './celestial-system.js';

export class CelestialRenderer {
    /**
     * @param {THREE.Scene} scene - Escena Three.js
     * @param {CelestialSystem} celestialSystem - Sistema celestial del frontend
     */
    constructor(scene, celestialSystem) {
        this.scene = scene;
        this.celestialSystem = celestialSystem;
        
        // Meshes del sol y luna
        this.solMesh = null;
        this.lunaMesh = null;
        
        // Configuración
        this.solRadius = 20.0;
        this.lunaRadius = 10.0;
        this.solColor = 0xFFD700; // Dorado
        this.lunaColor = 0xE6E6FA; // Lavanda
        
        // Crear meshes
        this.createMeshes();
    }
    
    /**
     * Crear meshes del sol y luna
     */
    createMeshes() {
        // Crear sol
        const solGeometry = new THREE.SphereGeometry(this.solRadius, 32, 32);
        const solMaterial = new THREE.MeshBasicMaterial({
            color: this.solColor,
            emissive: this.solColor,
            emissiveIntensity: 1.0
        });
        this.solMesh = new THREE.Mesh(solGeometry, solMaterial);
        this.scene.add(this.solMesh);
        
        // Crear luna
        const lunaGeometry = new THREE.SphereGeometry(this.lunaRadius, 32, 32);
        const lunaMaterial = new THREE.MeshBasicMaterial({
            color: this.lunaColor,
            emissive: this.lunaColor,
            emissiveIntensity: 0.3
        });
        this.lunaMesh = new THREE.Mesh(lunaGeometry, lunaMaterial);
        this.scene.add(this.lunaMesh);
        
        // Aplicar fase lunar inicial
        this.updateLunaPhase();
    }
    
    /**
     * Actualizar posición y apariencia del sol y luna
     * @param {number} [interpolationFactor] - Factor de interpolación para movimiento suave
     */
    update(interpolationFactor = 0.0) {
        // Actualizar posición del sol
        const solPos = this.celestialSystem.getSunPosition(interpolationFactor);
        this.solMesh.position.set(solPos.x, solPos.z, solPos.y); // Convertir a coordenadas Three.js (Y up)
        
        // Actualizar posición de la luna
        const lunaPos = this.celestialSystem.getLunaPosition(interpolationFactor);
        this.lunaMesh.position.set(lunaPos.x, lunaPos.z, lunaPos.y);
        
        // Actualizar fase lunar (apariencia)
        this.updateLunaPhase();
    }
    
    /**
     * Actualizar apariencia de la luna según su fase
     */
    updateLunaPhase() {
        const phase = this.celestialSystem.getLunaPhase();
        
        // Crear textura o material que muestre la fase lunar
        // Simplificado: ajustar opacidad o crear geometría que muestre la fase
        // Para implementación completa, se podría usar una textura o shader personalizado
        
        // Por ahora, ajustar intensidad emisiva según fase
        const intensity = phase < 0.5 
            ? phase * 2.0  // Creciente: 0.0 a 1.0
            : (1.0 - phase) * 2.0; // Menguante: 1.0 a 0.0
        
        this.lunaMesh.material.emissiveIntensity = intensity * 0.3;
    }
    
    /**
     * Remover meshes de la escena
     */
    dispose() {
        if (this.solMesh) {
            this.scene.remove(this.solMesh);
            this.solMesh.geometry.dispose();
            this.solMesh.material.dispose();
            this.solMesh = null;
        }
        
        if (this.lunaMesh) {
            this.scene.remove(this.lunaMesh);
            this.lunaMesh.geometry.dispose();
            this.lunaMesh.material.dispose();
            this.lunaMesh = null;
        }
    }
}
```

**Notas:**
- Los meshes se crean una vez y se actualizan en cada frame
- La fase lunar se refleja visualmente (simplificado, puede mejorarse con texturas/shaders)
- Los meshes se agregan a la escena y se actualizan en el loop de animación

---

### Paso 4: Integrar con Sistema de Iluminación

**Descripción:**
Extender `Lights` para actualizar la iluminación según el ciclo día/noche usando información de `CelestialSystem`.

**Archivos a modificar/crear:**
- `frontend/src/core/lights.js` (modificar)

**Detalles de implementación:**
```javascript
// Agregar método a la clase Lights:

/**
 * Actualizar iluminación según ciclo día/noche
 * @param {CelestialSystem} celestialSystem - Sistema celestial del frontend
 */
updateLighting(celestialSystem) {
    if (!this.ambientLight || !this.directionalLight) {
        return;
    }
    
    const sunIntensity = celestialSystem.getSunIntensity();
    const isDaytime = celestialSystem.isDaytime();
    const hour = celestialSystem.getCurrentHour();
    
    // Actualizar luz ambiente según intensidad solar
    // Día: más brillante, Noche: más oscuro
    const ambientIntensity = 0.3 + (sunIntensity * 0.4); // 0.3 a 0.7
    this.ambientLight.intensity = ambientIntensity;
    
    // Actualizar luz direccional según posición del sol
    const directionalIntensity = sunIntensity * 1.5; // 0.0 a 1.5
    this.directionalLight.intensity = directionalIntensity;
    
    // Actualizar color de la luz direccional según hora
    if (isDaytime) {
        // Día: luz blanca/amarilla cálida
        if (hour >= 6 && hour <= 10) {
            // Amanecer: naranja/rojo
            this.directionalLight.color.setHex(0xFFA500);
        } else if (hour >= 10 && hour <= 16) {
            // Mediodía: blanco
            this.directionalLight.color.setHex(0xFFFFFF);
        } else if (hour >= 16 && hour <= 18) {
            // Atardecer: naranja/rojo
            this.directionalLight.color.setHex(0xFF6347);
        } else {
            this.directionalLight.color.setHex(0xFFFFFF);
        }
    } else {
        // Noche: luz azul/plateada (luna)
        this.directionalLight.color.setHex(0xE6E6FA);
    }
    
    // Actualizar posición de la luz direccional según posición del sol
    const solPos = celestialSystem.getSunPosition();
    this.directionalLight.position.set(
        solPos.x,
        solPos.z, // Altura (Y en Three.js)
        solPos.y
    );
    
    // Asegurar que la luz apunte hacia el centro del mundo
    this.directionalLight.lookAt(0, 0, 0);
}
```

**Notas:**
- La iluminación se actualiza en cada frame o periódicamente
- Los colores cambian según la hora del día (amanecer, mediodía, atardecer, noche)
- La posición de la luz direccional sigue al sol

---

### Paso 5: Integrar en App.js y Loop de Animación

**Descripción:**
Integrar `CelestialSystem`, `CelestialRenderer` y `CelestialApi` en `app.js`, configurar sincronización periódica con el backend y actualizar en el loop de animación.

**Archivos a modificar/crear:**
- `frontend/src/app.js` (modificar)

**Detalles de implementación:**
```javascript
// En el constructor de App, agregar:

// Inicializar API celestial
this.celestialApi = new CelestialApi(apiClient);

// Inicializar sistema celestial del frontend
import { CelestialSystem } from './world/celestial-system.js';
import { CelestialRenderer } from './world/celestial-renderer.js';

this.celestialSystem = new CelestialSystem();
this.celestialRenderer = new CelestialRenderer(this.scene.scene, this.celestialSystem);

// Configuración de sincronización
this.celestialSyncInterval = 5.0; // Sincronizar cada 5 segundos
this.lastCelestialSync = 0;
this.celestialInterpolationTime = 0; // Tiempo desde última sincronización

// En el método loadDemo o después de cargar el bloque, agregar:

// Sincronizar estado celestial inicial
await this.syncCelestialState();

// En el método animate, agregar:

// Sincronizar estado celestial periódicamente
const currentTime = performance.now() / 1000; // Tiempo en segundos
if (currentTime - this.lastCelestialSync >= this.celestialSyncInterval) {
    this.syncCelestialState().catch(err => {
        console.error('Error sincronizando estado celestial:', err);
    });
    this.lastCelestialSync = currentTime;
    this.celestialInterpolationTime = 0;
}

// Actualizar interpolación
this.celestialInterpolationTime += deltaTime;
const interpolationFactor = Math.min(
    this.celestialInterpolationTime / this.celestialSyncInterval,
    1.0
);

// Actualizar renderizador celestial
this.celestialRenderer.update(interpolationFactor);

// Actualizar iluminación
this.scene.lights.updateLighting(this.celestialSystem);

// Agregar método para sincronizar estado celestial:

/**
 * Sincronizar estado celestial con el backend
 */
async syncCelestialState() {
    try {
        const state = await this.celestialApi.getState();
        this.celestialSystem.update(state);
    } catch (error) {
        console.error('Error sincronizando estado celestial:', error);
    }
}
```

**Notas:**
- La sincronización se hace periódicamente (cada 5 segundos por defecto)
- La interpolación suaviza el movimiento entre sincronizaciones
- El renderizador y la iluminación se actualizan en cada frame

---

### Paso 6: Actualizar Exportaciones y Documentación

**Descripción:**
Actualizar exportaciones en `__init__.js` y crear/actualizar documentación.

**Archivos a modificar/crear:**
- `frontend/src/api/endpoints/__init__.js` (modificar)
- `frontend/src/world/__init__.js` (crear o modificar)
- `frontend/src/world/README.md` (actualizar)

**Detalles de implementación:**
```javascript
// En frontend/src/api/endpoints/__init__.js:
export { CelestialApi } from './celestial.js';

// En frontend/src/api/__init__.js (si existe):
export { CelestialApi } from './endpoints/celestial.js';

// En frontend/src/world/__init__.js:
export { CelestialSystem } from './celestial-system.js';
export { CelestialRenderer } from './celestial-renderer.js';
```

**Documentación:**
- Actualizar `frontend/src/world/README.md` con información sobre `CelestialSystem` y `CelestialRenderer`
- Incluir ejemplos de uso
- Explicar sincronización con backend

---

## Consideraciones Técnicas

### Performance
- La sincronización con el backend debe ser eficiente (no bloquear el loop de animación)
- La interpolación debe ser suave sin causar lag
- Los meshes del sol/luna deben ser optimizados (geometrías simples)

### Sincronización
- El backend es autoritativo: el frontend solo renderiza
- Sincronización periódica (cada 5 segundos) para mantener consistencia
- Interpolación entre sincronizaciones para movimiento suave

### Extensibilidad
- El sistema está preparado para futuras mejoras (texturas de fase lunar, efectos de partículas, etc.)
- Fácil agregar más cuerpos celestes si es necesario

### Compatibilidad
- Mantener compatibilidad con sistema de iluminación existente
- No romper funcionalidad existente
- Integrar sin modificar comportamiento actual

## Archivos Principales Involucrados

1. `frontend/src/api/endpoints/celestial.js` - API client para endpoints celestiales (nuevo)
2. `frontend/src/world/celestial-system.js` - Sistema celestial del frontend (nuevo)
3. `frontend/src/world/celestial-renderer.js` - Renderizador de sol/luna (nuevo)
4. `frontend/src/core/lights.js` - Sistema de iluminación (modificar)
5. `frontend/src/app.js` - Aplicación principal (modificar)
6. `frontend/src/api/endpoints/__init__.js` - Exportaciones (modificar)
7. `frontend/src/world/README.md` - Documentación (actualizar)

## Testing

### Escenarios de Prueba
1. Verificar que `CelestialApi` obtiene estado correctamente del backend
2. Verificar que `CelestialSystem` calcula posiciones correctas
3. Verificar que `CelestialRenderer` renderiza sol/luna en la escena
4. Verificar que la iluminación cambia según ciclo día/noche
5. Verificar que la sincronización periódica funciona
6. Verificar que la interpolación suaviza el movimiento
7. Verificar que no hay lag o problemas de performance

### Casos Edge a Considerar
- Backend no disponible (manejo de errores)
- Estado celestial inválido o faltante
- Sincronización fallida (continuar con último estado conocido)
- Cambios bruscos de tiempo (saltos grandes en el tiempo del juego)

## Deployment

### Cambios Requeridos
- [ ] No requiere cambios en Docker/Infraestructura
- [ ] No requiere cambios en backend (ya completado)
- [ ] Solo cambios en frontend (archivos JavaScript)

### Verificación Post-Deployment
- [ ] Verificar que el sol y luna se renderizan correctamente
- [ ] Verificar que la iluminación cambia según ciclo día/noche
- [ ] Verificar que la sincronización con backend funciona
- [ ] Verificar que no hay errores en consola
- [ ] Verificar performance (FPS no debe bajar significativamente)

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. El backend ya está completado y los endpoints están disponibles.

**⚠️ IMPORTANTE:** Después de completar todos los pasos, generar la descripción del Pull Request usando `@pr-description.mdc`.

