# JDG-041 - Sistema de Conservación de Calor para Partículas

## Descripción de la Tarea

Implementar sistema que permite que partículas con `inercia_termica` (agua, hielo, lava) absorban temperatura del ambiente y la conserven, afectando la temperatura del bloque.

**Comportamiento actual:**
- El agua solo se considera por proximidad (distancia)
- No se lee `particula.temperatura` del agua
- Modificador fijo de ±5°C sin considerar temperatura real
- No hay sistema que actualice temperatura de partículas
- El agua no absorbe temperatura del sol/ambiente

**Comportamiento esperado:**
- Partículas con `inercia_termica > 0` absorben temperatura del ambiente
- El agua absorbe temperatura del sol/aire y la conserva (alta inercia)
- El hielo también funciona (sistema genérico)
- La temperatura del agua/hielo afecta la temperatura del bloque
- Sistema genérico que funciona para cualquier tipo de partícula

## Criterios de Aceptación

1. ✅ El agua absorbe temperatura del ambiente periódicamente
2. ✅ El agua conserva temperatura según su `inercia_termica`
3. ✅ El hielo también funciona (sistema genérico)
4. ✅ La temperatura del agua/hielo afecta la temperatura del bloque
5. ✅ Sistema funciona para cualquier partícula con `inercia_termica > 0`
6. ✅ Background task actualiza temperatura cada X minutos
7. ✅ No se rompe código existente (compatibilidad mantenida)

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [ ] Frontend (Three.js) - Sin cambios
- [x] Base de Datos (PostgreSQL) - UPDATE de temperatura

### Tecnologías Involucradas
- Backend: Python 3.11, FastAPI, Uvicorn, asyncpg
- Base de datos: PostgreSQL 16
- Patrones: Background tasks, Strategy pattern

## Pasos de Implementación

### Paso 1: Crear función genérica `update_particle_temperature()`

**Descripción:**
Crear función genérica que actualiza la temperatura de una partícula individual basándose en la temperatura ambiental y su `inercia_termica`.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py`

**Detalles de implementación:**
```python
async def update_particle_temperature(
    particula_id: str,
    temp_ambiente: float,
    tipo_particula: dict,
    conn: asyncpg.Connection
) -> float:
    """
    Actualizar temperatura de una partícula según temperatura ambiental.
    
    El cambio de temperatura depende de la inercia_termica:
    - Alta inercia (agua: 4.0) → cambia lentamente
    - Baja inercia (metal: 0.5) → cambia rápidamente
    
    Args:
        particula_id: ID de la partícula
        temp_ambiente: Temperatura ambiental (del bloque)
        tipo_particula: Diccionario con propiedades del tipo (inercia_termica)
        conn: Conexión a la base de datos
    
    Returns:
        Nueva temperatura de la partícula
    """
    # 1. Obtener temperatura actual de la partícula
    temp_actual = await conn.fetchval(
        "SELECT temperatura FROM juego_dioses.particulas WHERE id = $1",
        particula_id
    )
    
    # 2. Calcular diferencia
    diferencia = temp_ambiente - temp_actual
    
    # 3. Factor de cambio según inercia_termica
    inercia = float(tipo_particula.get('inercia_termica', 1.0))
    if inercia <= 0:
        return temp_actual  # No cambia si inercia es 0 o negativa
    
    factor_cambio = 1.0 / inercia  # Ejemplo: inercia 4.0 → factor 0.25
    
    # 4. Calcular nueva temperatura
    nueva_temp = temp_actual + (diferencia * factor_cambio)
    
    # 5. Limitar a valores razonables
    nueva_temp = max(-50.0, min(1000.0, nueva_temp))
    
    # 6. Actualizar en BD
    await conn.execute(
        "UPDATE juego_dioses.particulas SET temperatura = $1 WHERE id = $2",
        nueva_temp, particula_id
    )
    
    return nueva_temp
```

**Notas:**
- Función genérica: funciona para cualquier partícula con `inercia_termica`
- No requiere código específico por tipo (agua, hielo, lava)
- Respeta propiedades físicas del tipo de partícula

---

### Paso 2: Mejorar `get_water_modifier()` para leer temperatura

**Descripción:**
Modificar `get_water_modifier()` para leer la temperatura real de las partículas de agua/hielo y calcular el modificador basado en la diferencia de temperatura.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py`

**Detalles de implementación:**
```python
async def get_water_modifier(
    celda_x: float,
    celda_y: float,
    celda_z: float,
    bloque_id: str,
    temp_ambiente: float,  # NUEVO: temperatura ambiental
    radio_busqueda: float = 10.0
) -> float:
    """
    Calcular modificador de temperatura por proximidad al agua/hielo.
    
    MEJORADO: Ahora lee temperatura real del agua/hielo y calcula
    modificador basado en diferencia de temperatura.
    
    Args:
        celda_x: Coordenada X de la celda
        celda_y: Coordenada Y de la celda
        celda_z: Coordenada Z (altura) de la celda
        bloque_id: ID del bloque
        temp_ambiente: Temperatura ambiental (para calcular diferencia)
        radio_busqueda: Radio de búsqueda de agua (celdas)
    
    Returns:
        Modificador de temperatura en grados Celsius
    """
    from .particula_service import get_particulas_vecinas, calcular_distancia
    from .particula_service import get_tipo_particula_por_nombre
    
    # Buscar partículas de agua/hielo cercanas
    particulas_cercanas = await get_particulas_vecinas(
        bloque_id=bloque_id,
        celda_x=int(celda_x),
        celda_y=int(celda_y),
        celda_z=int(celda_z),
        radio=int(radio_busqueda)
    )
    
    modificador_total = 0.0
    
    for particula in particulas_cercanas:
        tipo_nombre = particula.get('tipo_nombre', '').lower()
        if tipo_nombre in ['agua', 'oceano', 'agua_sucia', 'hielo']:
            # NUEVO: Leer temperatura real de la partícula
            temp_particula = particula.get('temperatura', 20.0)
            
            # Calcular diferencia de temperatura
            diferencia = temp_particula - temp_ambiente
            
            # Calcular distancia
            distancia = calcular_distancia(
                celda_x, celda_y, celda_z,
                particula['celda_x'], particula['celda_y'], particula['celda_z']
            )
            
            # Obtener propiedades del tipo de partícula
            tipo_particula = await get_tipo_particula_por_nombre(tipo_nombre)
            conductividad = float(tipo_particula.get('conductividad_termica', 1.0)) if tipo_particula else 1.0
            
            # Propagación de calor (ley del cuadrado inverso)
            factor_distancia = 1.0 / (1.0 + distancia ** 2)
            
            # Máximo efecto dentro de 5 celdas
            factor_proximidad = max(0.0, 1.0 - (distancia / 5.0))
            
            # Modificador: diferencia * factor_distancia * conductividad * factor_proximidad
            modificador = diferencia * factor_distancia * conductividad * factor_proximidad
            modificador_total += modificador
    
    return modificador_total
```

**Notas:**
- Mantiene compatibilidad: misma firma de función (agregar parámetro opcional `temp_ambiente`)
- Lee temperatura real de partículas
- Funciona para agua Y hielo (sistema genérico)
- Respeta `conductividad_termica` del tipo

---

### Paso 3: Crear función genérica `get_particle_temperature_modifier()`

**Descripción:**
Crear función genérica que busca partículas de tipos específicos y calcula modificador de temperatura basado en su temperatura real.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py`

**Detalles de implementación:**
```python
async def get_particle_temperature_modifier(
    celda_x: float,
    celda_y: float,
    celda_z: float,
    bloque_id: str,
    temp_ambiente: float,
    tipos_particulas: List[str],
    radio_busqueda: float = 10.0
) -> float:
    """
    Calcular modificador de temperatura por partículas de tipos específicos.
    
    Función genérica que funciona para cualquier tipo de partícula
    (agua, hielo, lava, etc.).
    
    Args:
        celda_x: Coordenada X de la celda
        celda_y: Coordenada Y de la celda
        celda_z: Coordenada Z (altura) de la celda
        bloque_id: ID del bloque
        temp_ambiente: Temperatura ambiental
        tipos_particulas: Lista de nombres de tipos a buscar (ej: ['agua', 'hielo'])
        radio_busqueda: Radio de búsqueda (celdas)
    
    Returns:
        Modificador de temperatura en grados Celsius
    """
    from .particula_service import get_particulas_vecinas, calcular_distancia
    from .particula_service import get_tipo_particula_por_nombre
    
    # Buscar partículas cercanas
    particulas_cercanas = await get_particulas_vecinas(
        bloque_id=bloque_id,
        celda_x=int(celda_x),
        celda_y=int(celda_y),
        celda_z=int(celda_z),
        radio=int(radio_busqueda)
    )
    
    modificador_total = 0.0
    
    for particula in particulas_cercanas:
        tipo_nombre = particula.get('tipo_nombre', '').lower()
        if tipo_nombre in [t.lower() for t in tipos_particulas]:
            # Leer temperatura real
            temp_particula = particula.get('temperatura', 20.0)
            
            # Calcular diferencia
            diferencia = temp_particula - temp_ambiente
            
            # Calcular distancia
            distancia = calcular_distancia(
                celda_x, celda_y, celda_z,
                particula['celda_x'], particula['celda_y'], particula['celda_z']
            )
            
            # Obtener propiedades del tipo
            tipo_particula = await get_tipo_particula_por_nombre(tipo_nombre)
            conductividad = float(tipo_particula.get('conductividad_termica', 1.0)) if tipo_particula else 1.0
            
            # Propagación de calor
            factor_distancia = 1.0 / (1.0 + distancia ** 2)
            factor_proximidad = max(0.0, 1.0 - (distancia / 5.0))
            
            modificador = diferencia * factor_distancia * conductividad * factor_proximidad
            modificador_total += modificador
    
    return modificador_total
```

**Notas:**
- Función genérica: funciona para cualquier tipo de partícula
- Reutilizable: puede usarse para agua, hielo, lava, fuego, etc.
- Extensible: fácil agregar nuevos tipos

---

### Paso 4: Actualizar `calculate_cell_temperature()` para usar nuevas funciones

**Descripción:**
Modificar `calculate_cell_temperature()` para usar `get_particle_temperature_modifier()` en lugar de `get_water_modifier()` mejorado, y pasar `temp_ambiente` como parámetro.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py`

**Detalles de implementación:**
```python
async def calculate_cell_temperature(
    celda_x: float,
    celda_y: float,
    celda_z: float,
    bloque_id: str,
    celestial_time_service: 'CelestialTimeService',
    tipo_particula_superficie: Optional[str] = None,
    radio_maximo: Optional[float] = None,
    radio_busqueda_agua: float = 10.0
) -> float:
    """
    Calcular temperatura ambiental final de una celda
    
    MEJORADO: Ahora considera temperatura real de partículas (agua, hielo).
    """
    # ... código existente para temp_solar, mod_altitud, mod_albedo ...
    
    # Calcular temperatura ambiental base (sin modificadores de partículas)
    temp_ambiente_base = temp_solar + mod_altitud + mod_albedo
    
    # NUEVO: Modificador por partículas (agua, hielo, lava)
    mod_particulas = await get_particle_temperature_modifier(
        celda_x=celda_x,
        celda_y=celda_y,
        celda_z=celda_z,
        bloque_id=bloque_id,
        temp_ambiente=temp_ambiente_base,
        tipos_particulas=['agua', 'oceano', 'agua_sucia', 'hielo'],
        radio_busqueda=radio_busqueda_agua
    )
    
    # Mantener get_water_modifier() mejorado para compatibilidad
    # (puede eliminarse en el futuro si no se usa)
    mod_agua = await get_water_modifier(
        celda_x=celda_x,
        celda_y=celda_y,
        celda_z=celda_z,
        bloque_id=bloque_id,
        temp_ambiente=temp_ambiente_base,  # NUEVO: pasar temperatura ambiental
        radio_busqueda=radio_busqueda_agua
    )
    
    # Usar mod_particulas (más genérico) o mod_agua (compatibilidad)
    # Por ahora usar mod_particulas
    temperatura_final = temp_ambiente_base + mod_particulas
    
    # Limitar a valores razonables
    temperatura_final = max(-50.0, min(60.0, temperatura_final))
    
    return temperatura_final
```

**Notas:**
- Mantiene compatibilidad con código existente
- Usa función genérica `get_particle_temperature_modifier()`
- Puede mantener `get_water_modifier()` mejorado para compatibilidad

---

### Paso 5: Crear función para obtener partículas con inercia_termica

**Descripción:**
Crear función helper que obtiene partículas de un bloque que tienen `inercia_termica > 0` (necesitan actualización de temperatura).

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py` o `backend/src/services/particula_service.py`

**Detalles de implementación:**
```python
async def get_particulas_con_inercia(
    bloque_id: str,
    conn: asyncpg.Connection,
    inercia_minima: float = 0.1
) -> List[dict]:
    """
    Obtener partículas de un bloque que tienen inercia_termica > 0.
    
    Estas partículas necesitan actualización periódica de temperatura.
    
    Args:
        bloque_id: ID del bloque
        conn: Conexión a la base de datos
        inercia_minima: Valor mínimo de inercia_termica para incluir
    
    Returns:
        Lista de partículas con sus tipos y propiedades
    """
    rows = await conn.fetch("""
        SELECT 
            p.id,
            p.celda_x,
            p.celda_y,
            p.celda_z,
            p.temperatura,
            tp.nombre as tipo_nombre,
            tp.inercia_termica,
            tp.conductividad_termica
        FROM juego_dioses.particulas p
        JOIN juego_dioses.tipos_particulas tp ON p.tipo_particula_id = tp.id
        WHERE p.bloque_id = $1
          AND p.extraida = false
          AND tp.inercia_termica > $2
    """, bloque_id, inercia_minima)
    
    return [dict(row) for row in rows]
```

**Notas:**
- Función helper para obtener partículas que necesitan actualización
- Filtra por `inercia_termica > 0` (solo partículas que conservan calor)
- Retorna información necesaria para actualización

---

### Paso 6: Crear background task para actualizar temperaturas

**Descripción:**
Crear background task similar a `CelestialTimeService` que actualiza temperatura de partículas periódicamente.

**Archivos a modificar/crear:**
- `backend/src/api/routes/celestial.py`

**Detalles de implementación:**
```python
# Agregar al inicio del archivo
from src.services.temperature_service import (
    update_particle_temperature,
    get_particulas_con_inercia
)
from src.services import WorldBloqueManager, CelestialTimeService
from src.database.connection import get_connection

# Variable global para el task
_particle_temperature_update_task: Optional[asyncio.Task] = None

async def update_particle_temperatures_periodically():
    """
    Actualizar temperatura de partículas periódicamente.
    
    Se ejecuta cada 5 minutos (configurable) y actualiza partículas
    con inercia_termica > 0 en bloques activos.
    """
    global _particle_temperature_update_task
    
    while True:
        try:
            await asyncio.sleep(300)  # 5 minutos
            
            # Obtener servicio celestial
            celestial_service = get_celestial_service()
            
            # Obtener bloques activos (desde WorldBloqueManager si existe)
            # Por ahora, actualizar todas las partículas de todos los bloques
            # (optimización futura: solo bloques activos)
            
            async with get_connection() as conn:
                # Obtener todos los bloques únicos
                bloques = await conn.fetch("""
                    SELECT DISTINCT bloque_id
                    FROM juego_dioses.particulas
                    WHERE extraida = false
                """)
                
                for bloque_row in bloques:
                    bloque_id = str(bloque_row['bloque_id'])
                    
                    # Obtener partículas con inercia_termica
                    particulas = await get_particulas_con_inercia(bloque_id, conn)
                    
                    if not particulas:
                        continue
                    
                    # Calcular temperatura ambiental del bloque (centro)
                    # Usar WorldBloqueManager si está disponible
                    # Por ahora, calcular temperatura en posición (0, 0, 0) del bloque
                    # (simplificado, puede mejorarse)
                    
                    for particula in particulas:
                        # Calcular temperatura ambiental en la posición de la partícula
                        temp_ambiente = await calculate_cell_temperature(
                            celda_x=float(particula['celda_x']),
                            celda_y=float(particula['celda_y']),
                            celda_z=float(particula['celda_z']),
                            bloque_id=bloque_id,
                            celestial_time_service=celestial_service
                        )
                        
                        # Actualizar temperatura de la partícula
                        await update_particle_temperature(
                            particula_id=str(particula['id']),
                            temp_ambiente=temp_ambiente,
                            tipo_particula={
                                'inercia_termica': float(particula['inercia_termica'])
                            },
                            conn=conn
                        )
                        
        except asyncio.CancelledError:
            logger.info("Tarea de actualización de temperatura de partículas cancelada")
            break
        except Exception as e:
            logger.error(f"Error actualizando temperatura de partículas: {e}")

async def start_particle_temperature_update_task():
    """
    Iniciar background task para actualizar temperatura de partículas.
    """
    global _particle_temperature_update_task
    if _particle_temperature_update_task is None or _particle_temperature_update_task.done():
        _particle_temperature_update_task = asyncio.create_task(
            update_particle_temperatures_periodically()
        )
        logger.info("Tarea de actualización de temperatura de partículas iniciada")
```

**Notas:**
- Similar a `CelestialTimeService` (mismo patrón)
- Se ejecuta cada 5 minutos (configurable)
- Actualiza partículas con `inercia_termica > 0`
- Manejo de errores para no romper el task

---

### Paso 7: Integrar background task en startup de FastAPI

**Descripción:**
Iniciar el background task cuando FastAPI arranca, similar a `CelestialTimeService`.

**Archivos a modificar/crear:**
- `backend/src/main.py`

**Detalles de implementación:**
```python
# En la función lifespan o startup
from src.api.routes.celestial import (
    start_celestial_service_background_task,
    start_particle_temperature_update_task  # NUEVO
)

@app.on_event("startup")
async def startup_event():
    # ... código existente ...
    
    # Iniciar background task de temperatura de partículas
    await start_particle_temperature_update_task()
```

**Notas:**
- Similar a cómo se inicia `CelestialTimeService`
- Se ejecuta en segundo plano sin bloquear

---

### Paso 8: Actualizar exports y documentación

**Descripción:**
Actualizar `__init__.py` para exportar nuevas funciones y actualizar READMEs.

**Archivos a modificar/crear:**
- `backend/src/services/__init__.py`
- `backend/src/services/README.md`

**Detalles de implementación:**
```python
# En __init__.py
from .temperature_service import (
    # ... exports existentes ...
    update_particle_temperature,  # NUEVO
    get_particle_temperature_modifier,  # NUEVO
    get_particulas_con_inercia  # NUEVO
)
```

**Notas:**
- Actualizar exports para que otras partes del código puedan usar las funciones
- Actualizar README con documentación de nuevas funciones

---

### Paso 9: Actualizar `get_water_modifier()` para pasar temp_ambiente

**Descripción:**
Actualizar todas las llamadas a `get_water_modifier()` para pasar el nuevo parámetro `temp_ambiente`.

**Archivos a modificar/crear:**
- `backend/src/services/temperature_service.py`
- `backend/src/services/world_bloque.py` (si usa get_water_modifier)

**Detalles de implementación:**
```python
# En calculate_cell_temperature()
# Calcular temp_ambiente_base primero
temp_ambiente_base = temp_solar + mod_altitud + mod_albedo

# Pasar temp_ambiente_base a get_water_modifier()
mod_agua = await get_water_modifier(
    celda_x=celda_x,
    celda_y=celda_y,
    celda_z=celda_z,
    bloque_id=bloque_id,
    temp_ambiente=temp_ambiente_base,  # NUEVO
    radio_busqueda=radio_busqueda_agua
)
```

**Notas:**
- Actualizar todas las llamadas existentes
- Mantener compatibilidad (parámetro opcional con default)

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-041_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance

- **Actualización periódica:** Cada 5 minutos (configurable), no en cada request
- **Batch updates:** Actualizar múltiples partículas en una transacción
- **Solo bloques activos:** Optimización futura: solo actualizar partículas de bloques con jugadores
- **Índices:** Asegurar que hay índices en `particulas.bloque_id` y `tipos_particulas.inercia_termica`

### Seguridad

- **Validación de entrada:** Pydantic valida parámetros
- **SQL parametrizado:** Todas las queries usan parámetros ($1, $2, etc.)
- **Límites de temperatura:** Valores entre -50°C y 1000°C (razonables)

### Casos Edge

- **Partículas sin inercia_termica:** Se ignoran (no se actualizan)
- **Bloques sin partículas:** No hay error, simplemente no hay nada que actualizar
- **Temperatura fuera de rango:** Se limita a valores razonables
- **Conexión a BD perdida:** El background task maneja errores y continúa

### Compatibilidad

- **Código existente:** No se rompe, nuevas funciones son adicionales
- **get_water_modifier():** Mantiene misma firma (parámetro opcional)
- **APIs:** No hay cambios en endpoints existentes
- **Frontend:** No requiere cambios

## Patrones de Código a Usar

- **Backend (FastAPI):**
  - Funciones async/await para operaciones I/O
  - Type hints en todas las funciones
  - Docstrings en formato Google
  - Manejo de errores con logging
  - Background tasks con asyncio

- **Base de Datos:**
  - asyncpg para conexiones asíncronas
  - Queries parametrizadas (prevención SQL injection)
  - UPDATE batch para performance
  - Transacciones cuando sea necesario

## Dependencias

### Nuevas Dependencias (si aplica)
```txt
# No se requieren nuevas dependencias
# Se usan librerías ya existentes: asyncpg, asyncio
```

### Variables de Entorno (si aplica)
- `PARTICLE_TEMPERATURE_UPDATE_INTERVAL`: Intervalo de actualización en segundos (default: 300 = 5 minutos)

## Archivos Principales Involucrados

1. `backend/src/services/temperature_service.py` - Funciones de temperatura (mejoras y nuevas)
2. `backend/src/api/routes/celestial.py` - Background task de actualización
3. `backend/src/main.py` - Startup de background task
4. `backend/src/services/__init__.py` - Exports de nuevas funciones
5. `backend/src/services/README.md` - Documentación actualizada

## Testing

### Tests a Crear/Modificar
- Unit tests: `tests/test_temperature_service.py` (nuevas funciones)
- Integration tests: Verificar que background task actualiza temperaturas

### Escenarios de Prueba
1. **Agua absorbe temperatura:** Verificar que temperatura del agua cambia lentamente hacia temperatura ambiental
2. **Hielo funciona:** Verificar que hielo también absorbe temperatura (sistema genérico)
3. **Modificador dinámico:** Verificar que temperatura del agua afecta temperatura del bloque
4. **Background task:** Verificar que se ejecuta periódicamente y actualiza partículas

## Deployment

### Orden de Deployment
1. Backend: Rebuild Docker image y restart container
2. Verificar logs: Background task debe iniciarse correctamente
3. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar que background task se inicia (logs)
- [ ] Verificar que temperatura de partículas se actualiza (consultar BD)
- [ ] Verificar que temperatura del bloque considera temperatura de partículas (F3 en frontend)
- [ ] Verificar logs de errores (no debe haber errores críticos)

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.

