# JDG-042 - Reflejo Realista de la Luna

## Descripción de la Tarea

Implementar reflejo realista de la luna: la luna debe reflejar la luz del sol en lugar de emitir luz propia. Three.js calculará automáticamente qué parte está iluminada y qué parte está oscura.

**Comportamiento actual:**
- La luna emite luz propia (`emissive` configurado) en lugar de reflejar la luz del sol
- Por eso se ve completa siempre, sin importar la fase

**Comportamiento esperado:**
- La luna NO emite luz propia (sin `emissive`)
- La luna refleja la luz del sol automáticamente
- La parte iluminada por el sol se ve brillante
- La parte oscura se ve oscura (casi invisible)
- Three.js calcula esto automáticamente según la posición del sol

## Criterios de Aceptación

1. ❌ La luna NO emite luz propia (`emissive = 0x000000`, `emissiveIntensity = 0.0`)
2. ❌ La luna refleja la luz del sol automáticamente (usando `MeshStandardMaterial`)
3. ❌ La parte iluminada por el sol se ve brillante, la parte oscura se ve oscura
4. ❌ La fase visual coincide con la fase calculada por el modelo de Gleason
5. ❌ No se rompe código existente (compatibilidad mantenida)

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI) - Sin cambios
- [x] Frontend (Three.js) - Modificaciones en renderizado lunar
- [ ] Base de Datos (PostgreSQL) - Sin cambios

### Tecnologías Involucradas
- Frontend: JavaScript ES6+, Three.js
- Materiales: MeshStandardMaterial con propiedades de reflexión

## Pasos de Implementación

### Paso 1: Quitar Emissive del Material Lunar

**Descripción:**
Modificar el material de la luna para que NO emita luz propia. Quitar `emissive` y dejar que Three.js calcule automáticamente el reflejo de la luz del sol.

**Archivos a modificar/crear:**
- `frontend/src/world/celestial-renderer.js`

**Detalles de implementación:**
```javascript
createMeshes() {
    try {
        // ... código existente para sol ...
        
        // Crear luna
        const lunaGeometry = new THREE.SphereGeometry(this.lunaRadius, 32, 32);
        const lunaMaterial = new THREE.MeshStandardMaterial({
            color: this.lunaColor,        // Color base de la luna
            emissive: 0x000000,          // ✅ NO emite luz (era: this.lunaColor)
            emissiveIntensity: 0.0,      // ✅ Sin emisión (era: 0.3)
            metalness: 0.2,              // ✅ Poco metálico (roca lunar)
            roughness: 0.8               // ✅ Muy rugoso (superficie lunar)
        });
        this.lunaMesh = new THREE.Mesh(lunaGeometry, lunaMaterial);
        this.scene.add(this.lunaMesh);
        
        // Aplicar fase lunar inicial
        this.updateLunaPhase();
    } catch (error) {
        debugLogger.error('CelestialRenderer', 'Error creando meshes', { error });
    }
}
```

**Notas:**
- Al quitar `emissive`, Three.js automáticamente calculará qué parte está iluminada por el sol
- La luz direccional (sol) ya está configurada y se mueve según la posición del sol
- No se necesita shader ni texturas, Three.js lo hace automáticamente

---

### Paso 2: Verificar que la Iluminación Funciona Correctamente

**Descripción:**
Verificar que la luz direccional (sol) ya está configurada correctamente y se mueve según la posición del sol. Three.js calculará automáticamente qué parte de la luna está iluminada basándose en la posición del sol.

**Archivos a verificar:**
- `frontend/src/core/lights.js` - Ya tiene la luz direccional configurada
- `frontend/src/world/celestial-renderer.js` - Ya actualiza la posición del sol

**Notas:**
- **NO es necesario modificar nada** - La luz direccional ya está configurada
- La luz direccional se mueve según la posición del sol (en `lights.js`, método `updateLighting()`)
- Three.js automáticamente calcula qué parte de la luna está iluminada según la dirección de la luz
- La fase visual se verá automáticamente porque la luz viene del sol y se mueve según el modelo de Gleason
- **Importante:** No ajustar `metalness` o `roughness` según la fase - el material de la luna no cambia, solo cambia qué parte está iluminada según la posición del sol relativa al observador

---

### Paso 3: Actualizar Documentación (Opcional)

**Descripción:**
Actualizar la documentación del módulo `world/` si existe, para reflejar que la luna ahora refleja la luz del sol en lugar de emitir luz propia.

**Archivos a modificar/crear:**
- `frontend/src/world/README.md` (actualizar si existe, opcional)

**Notas:**
- Este paso es opcional
- Solo necesario si existe documentación del módulo

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-042_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- No hay impacto en rendimiento (solo cambio de propiedades del material)
- Three.js calcula el reflejo automáticamente (muy eficiente)

### Seguridad
- No aplica (solo frontend, sin entrada de usuario)

### Casos Edge
- **Fase 0.0 o 1.0 (luna nueva):** La luna será casi invisible (parte oscura) - esto es correcto según el modelo de Gleason
- **Fase 0.5 (luna llena):** Máxima visibilidad (parte iluminada completa) - esto es correcto según el modelo de Gleason
- **Transiciones entre fases:** Automáticamente suaves (Three.js lo calcula según posición del sol)
- **Posición del sol no disponible:** La luz direccional ya maneja esto (usa posición del sol del backend)
- **Modelo de Gleason:** La fase depende de la posición del observador relativa al sol y la luna - Three.js calcula esto automáticamente según la dirección de la luz

### Compatibilidad
- Mantener compatibilidad con sistema celestial existente
- No romper iluminación actual
- Cambio mínimo (solo propiedades del material)

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Clases ES6 para organización
  - `MeshStandardMaterial` para reflejo automático de luz
  - Propiedades de material (`metalness`, `roughness`) para controlar reflejo
  - Separación de responsabilidades (renderizador separado del sistema celestial)

## Dependencias

### Nuevas Dependencias (si aplica)
```txt
# No se requieren nuevas dependencias
# Three.js ya incluye soporte para materiales estándar
```

### Variables de Entorno (si aplica)
- No se requieren nuevas variables de entorno

## Archivos Principales Involucrados

1. `frontend/src/world/celestial-renderer.js` - Renderizador de sol/luna (modificar)
2. `frontend/src/world/celestial-system.js` - Sistema celestial (sin cambios, solo lectura)

## Testing

### Tests a Crear/Modificar
- No se requieren tests unitarios (testing visual)
- Testing manual visual de fases lunares

### Escenarios de Prueba
1. **Luna nueva (fase 0.0):** Verificar que la luna es casi invisible (parte oscura) - según modelo de Gleason
2. **Luna creciente (fase 0.25):** Verificar que se muestra parte iluminada por el sol - según posición del sol
3. **Luna llena (fase 0.5):** Verificar máxima visibilidad (parte iluminada completa) - según modelo de Gleason
4. **Luna menguante (fase 0.75):** Verificar que se muestra parte iluminada opuesta - según posición del sol
5. **Movimiento del sol:** Verificar que la parte iluminada cambia automáticamente según posición del sol (calculado por Three.js)
6. **Modelo de Gleason:** Verificar que la fase visual coincide con la fase calculada por el backend (modelo de Gleason)

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos (renderizador)
2. Verificar en ambiente local con Docker Compose
3. No requiere cambios en backend o base de datos

### Verificación Post-Deployment
- [ ] Verificar que la luna NO emite luz propia (parte oscura visible)
- [ ] Verificar que la luna refleja la luz del sol (parte iluminada brillante)
- [ ] Verificar que la parte iluminada cambia automáticamente según posición del sol (Three.js lo calcula)
- [ ] Verificar que la fase visual coincide con la fase del modelo de Gleason (backend)
- [ ] Verificar que el material de la luna no cambia (solo cambia qué parte está iluminada)
- [ ] Verificar rendimiento (FPS no degradado)
- [ ] Verificar que no se rompe iluminación existente

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
