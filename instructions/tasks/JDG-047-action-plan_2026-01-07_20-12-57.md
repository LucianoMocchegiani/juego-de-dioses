# JDG-047 - Optimizaciones de Bajo Riesgo para Mejorar FPS (Fase 1)

## Descripción de la Tarea

Implementar optimizaciones de bajo riesgo para mejorar FPS sin cambiar funcionalidad. Estas optimizaciones incluyen: object pooling para objetos temporales Three.js, cachear ordenamiento de sistemas ECS, y usar dirty flags para actualizar el color del cielo solo cuando es necesario.

**Comportamiento actual:**
- Se crean nuevos objetos `Vector3`, `Quaternion`, `Euler` en cada frame para cálculos temporales
- El ECS Manager ordena sistemas cada frame innecesariamente
- El color del cielo se recalcula cada frame aunque no cambie

**Comportamiento esperado:**
- Objetos temporales se reutilizan desde un pool
- Ordenamiento de sistemas se cachea y solo se recalcula cuando cambian
- Color del cielo solo se actualiza cuando el estado celestial cambia significativamente

## Criterios de Aceptación

1. ✅ Se implementa un sistema de object pooling reutilizable para objetos Three.js
2. ✅ `weapon-equip-system.js` usa object pooling para todos sus objetos temporales
3. ✅ El ECS Manager cachea el ordenamiento de sistemas
4. ✅ El color del cielo solo se actualiza cuando cambia significativamente
5. ✅ Se observa mejora de +5-10 FPS después de implementar object pooling
6. ✅ Se observa mejora de +1-2 FPS después de cachear ordenamiento
7. ✅ Se observa mejora de +1-2 FPS después de dirty flag para cielo
8. ✅ Las optimizaciones no cambian la funcionalidad visible del juego
9. ✅ No hay memory leaks

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)
- [ ] Backend (FastAPI)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js
- Patrones: Object Pool, Dirty Flag
- Containerización: Docker + Docker Compose

## Pasos de Implementación

### Paso 1: Crear Sistema de Object Pooling

**Descripción:**
Crear un sistema reutilizable de object pooling para objetos Three.js temporales (Vector3, Quaternion, Euler).

**Archivos a modificar/crear:**
- `frontend/src/core/optimizations/object-pool.js` (nuevo)
- `frontend/src/core/optimizations/README.md` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Sistema de Object Pooling para objetos reutilizables
 * Reduce garbage collection reutilizando objetos temporales
 */
export class ObjectPool {
    constructor(createFn, resetFn, initialSize = 10) {
        this.pool = [];
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.totalCreated = 0;
        this.totalReused = 0;
        
        // Pre-crear objetos iniciales
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(createFn());
            this.totalCreated++;
        }
    }
    
    /**
     * Obtener un objeto del pool (o crear uno nuevo si el pool está vacío)
     * @returns {*} Objeto del pool
     */
    acquire() {
        if (this.pool.length > 0) {
            this.totalReused++;
            return this.pool.pop();
        }
        this.totalCreated++;
        return this.createFn();
    }
    
    /**
     * Devolver un objeto al pool
     * @param {*} obj - Objeto a devolver
     */
    release(obj) {
        if (this.resetFn) {
            this.resetFn(obj);
        }
        this.pool.push(obj);
    }
    
    /**
     * Limpiar el pool (liberar todos los objetos)
     */
    clear() {
        this.pool.length = 0;
    }
    
    /**
     * Obtener estadísticas del pool
     * @returns {Object} Estadísticas
     */
    getStats() {
        return {
            poolSize: this.pool.length,
            totalCreated: this.totalCreated,
            totalReused: this.totalReused,
            reuseRate: this.totalCreated > 0 ? (this.totalReused / (this.totalCreated + this.totalReused)) * 100 : 0
        };
    }
}
```

**Notas:**
- El pool debe poder crecer dinámicamente si se agotan los objetos
- Implementar función de reset para limpiar objetos antes de reutilizarlos
- Agregar estadísticas para monitorear efectividad del pool
- **⚠️ READMEs:** Crear README.md en `core/optimizations/` explicando el sistema de optimizaciones

---

### Paso 2: Integrar Object Pool en App Principal

**Descripción:**
Inicializar pools de objetos en `app.js` y exponerlos para uso en sistemas.

**Archivos a modificar/crear:**
- `frontend/src/app.js`

**Detalles de implementación:**
```javascript
// En constructor o método de inicialización:
import { ObjectPool } from './core/optimizations/object-pool.js';
import * as THREE from 'three';

// Crear pools de objetos
// Nota: Los tamaños iniciales deben ser suficientes para el caso de uso más común
// weapon-equip-system puede necesitar ~4 objetos por objeto en jerarquía del modelo
this.objectPool = {
    vector3: new ObjectPool(
        () => new THREE.Vector3(),
        (v) => v.set(0, 0, 0),
        50  // Pool inicial de 50 objetos (suficiente para jerarquías complejas)
    ),
    quaternion: new ObjectPool(
        () => new THREE.Quaternion(),
        (q) => q.set(0, 0, 0, 1),
        25  // Pool inicial de 25 objetos
    ),
    euler: new ObjectPool(
        () => new THREE.Euler(),
        (e) => e.set(0, 0, 0),
        25  // Pool inicial de 25 objetos
    ),
    matrix4: new ObjectPool(
        () => new THREE.Matrix4(),
        (m) => m.identity(),
        10  // Pool para Matrix4 (usado en particle-renderer y otros lugares)
    )
};

// Exponer pools globalmente para fácil acceso
if (window.app) {
    window.app.objectPool = this.objectPool;
}
```

**Notas:**
- Los tamaños iniciales deben ser suficientes para el caso de uso más común (jerarquías de modelos con muchos objetos)
- Los pools pueden crecer dinámicamente si se agotan (el pool crea nuevos objetos automáticamente)
- Se agregó pool para Matrix4 porque también se usa frecuentemente (particle-renderer, culling, etc.)

---

### Paso 3: Refactorizar Weapon-Equip-System para Usar Object Pool

**Descripción:**
Refactorizar `weapon-equip-system.js` para usar object pooling en los lugares donde se crean objetos temporales Three.js.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/weapon-equip-system.js`

**Ubicaciones específicas donde se crean objetos temporales:**

1. **Líneas 86-89: `buildHierarchy()` - Función recursiva que analiza estructura de modelos de armas**
   - **Cuándo se ejecuta:** Cuando se carga un nuevo modelo de arma (no cada frame, pero sí frecuentemente durante gameplay)
   - **Función:** `inspectWeaponModel()` → `buildHierarchy()`
   - **Objetos creados:**
     - `worldPos = new THREE.Vector3()` - Para obtener posición mundial del objeto
     - `worldQuat = new THREE.Quaternion()` - Para obtener rotación mundial (quaternion)
     - `worldRot = new THREE.Euler()` - Para convertir quaternion a Euler para logging
     - `worldScale = new THREE.Vector3()` - Para obtener escala mundial del objeto
   - **Para qué se usan:**
     - `object.getWorldPosition(worldPos)` - Llena el vector con la posición mundial acumulada (incluye transformaciones de padres)
     - `object.getWorldQuaternion(worldQuat)` - Llena el quaternion con la rotación mundial acumulada
     - `worldRot.setFromQuaternion(worldQuat)` - Convierte quaternion a Euler para mostrar en logs de debugging
     - `object.getWorldScale(worldScale)` - Llena el vector con la escala mundial acumulada
   - **Frecuencia:** Se ejecuta recursivamente para cada objeto en la jerarquía del modelo:
     - Cada objeto 3D en el modelo (Mesh, Group, etc.)
     - Típicamente 5-20 objetos por modelo de arma
     - Se llama una vez cuando se carga el modelo (cuando se equipa el arma)
   - **Impacto:** Aunque no es cada frame, cuando se carga un arma se crean **4 objetos × número de objetos en jerarquía**, lo que puede ser 20-80 objetos temporales que luego se destruyen (causando GC)
   - **Uso de los valores:** Se guardan en `objInfo.worldTransform` para análisis de la estructura del modelo y debugging

**Otros lugares a considerar (opcional en esta fase):**
- **`camera-controller.js` líneas 201 y 214:** Crea `Vector3` cada frame para suavizado de cámara
- **`particle-renderer.js` línea 271:** Crea `Matrix4` para instancias de partículas
- **`terrain/utils/culling.js` líneas 18 y 26:** Crea `Matrix4` y `Vector3` para frustum culling
- **`terrain/optimizations/particle-limiter.js` líneas 42 y 94:** Crea `Vector3` para calcular distancias de partículas

**Detalles de implementación:**

```javascript
// En weapon-equip-system.js, modificar método inspectWeaponModel():
inspectWeaponModel(model, url) {
    // ... código existente ...
    
    // Obtener referencia al object pool (debe estar disponible en app)
    const objectPool = window.app?.objectPool;
    
    // Función recursiva para construir la jerarquía
    const buildHierarchy = (object, parent = null, depth = 0, path = []) => {
        const currentPath = [...path, object.name || object.type || 'unnamed'];
        
        // Obtener objetos del pool o crear nuevos si el pool no está disponible
        const worldPos = objectPool?.vector3?.acquire() || new THREE.Vector3();
        const worldQuat = objectPool?.quaternion?.acquire() || new THREE.Quaternion();
        const worldRot = objectPool?.euler?.acquire() || new THREE.Euler();
        const worldScale = objectPool?.vector3?.acquire() || new THREE.Vector3();
        
        try {
            // Calcular posición mundial acumulada
            object.getWorldPosition(worldPos);
            object.getWorldQuaternion(worldQuat);
            worldRot.setFromQuaternion(worldQuat); // Convertir quaternion a euler
            object.getWorldScale(worldScale);
            
            // ... resto del código usando worldPos, worldQuat, worldRot, worldScale ...
            
            const objInfo = {
                // ... usar worldPos.x, worldPos.y, worldPos.z, etc. ...
                worldTransform: {
                    position: {
                        x: worldPos.x,
                        y: worldPos.y,
                        z: worldPos.z
                    },
                    rotation: {
                        x: worldRot.x,
                        y: worldRot.y,
                        z: worldRot.z
                    },
                    scale: {
                        x: worldScale.x,
                        y: worldScale.y,
                        z: worldScale.z
                    }
                }
                // ... resto del código ...
            };
            
            // ... resto del código ...
            
            // Recursión para hijos
            object.children.forEach(child => {
                buildHierarchy(child, object, depth + 1, currentPath);
            });
        } finally {
            // SIEMPRE devolver objetos al pool después de usarlos
            if (objectPool) {
                objectPool.vector3?.release(worldPos);
                objectPool.quaternion?.release(worldQuat);
                objectPool.euler?.release(worldRot);
                objectPool.vector3?.release(worldScale);
            }
        }
    };
    
    // Construir jerarquía completa
    buildHierarchy(model);
    
    // ... resto del código ...
}
```

**Notas:**
- Usar try/finally para garantizar que los objetos siempre se devuelvan al pool, incluso si hay errores
- Mantener fallback a crear nuevos objetos si el pool no está disponible (para compatibilidad)
- La función `buildHierarchy` es recursiva, así que cada llamada debe obtener y liberar objetos del pool

---

### Paso 4: Cachear Ordenamiento de Sistemas ECS

**Descripción:**
Modificar `manager.js` para cachear el ordenamiento de sistemas y solo recalcular cuando cambian.

**Ubicación específica del problema:**
- **Archivo:** `frontend/src/ecs/manager.js`
- **Línea 241:** `const sortedSystems = [...this.systems].sort((a, b) => a.priority - b.priority);`
- **Cuándo se ejecuta:** Cada frame (60 veces por segundo)
- **Para qué se usa:** Ordenar sistemas por prioridad para ejecutarlos en el orden correcto
- **Problema:** El array se ordena cada frame aunque los sistemas raramente cambian
- **Impacto:** O(n log n) innecesario cada frame (donde n = número de sistemas, típicamente 8-12)

**Archivos a modificar/crear:**
- `frontend/src/ecs/manager.js`

**Detalles de implementación:**
```javascript
// En ECSManager:
constructor() {
    // ... código existente ...
    this.sortedSystems = null; // Cache del ordenamiento
    this.systemsDirty = true;  // Flag para indicar que necesita reordenar
}

registerSystem(system) {
    this.systems.push(system);
    system.setECSManager(this);
    this.systemsDirty = true; // Marcar como sucio para reordenar
}

unregisterSystem(system) {
    const index = this.systems.indexOf(system);
    if (index !== -1) {
        this.systems.splice(index, 1);
        system.setECSManager(null);
        this.systemsDirty = true; // Marcar como sucio para reordenar
    }
}

update(deltaTime) {
    // Reordenar solo si es necesario
    if (this.systemsDirty || !this.sortedSystems) {
        this.sortedSystems = [...this.systems].sort((a, b) => a.priority - b.priority);
        this.systemsDirty = false;
    }
    
    // ... resto del código usando this.sortedSystems en lugar de ordenar cada vez ...
    
    // Iniciar medición de frame
    if (this.debugMetrics) {
        this.debugMetrics.startFrame();
    }
    
    for (const system of this.sortedSystems) {
        // ... resto del código ...
    }
    
    // ... resto del código ...
}
```

**Notas:**
- El flag `systemsDirty` debe marcarse cuando se agregan o remueven sistemas
- Verificar que el cache se invalida correctamente

---

### Paso 5: Implementar Dirty Flag para Color del Cielo

**Descripción:**
Modificar `renderer.js` para solo actualizar el color del cielo cuando el estado celestial cambia significativamente.

**Ubicación específica del problema:**
- **Archivo:** `frontend/src/core/renderer.js`
- **Líneas 46-107:** Método `updateSkyColor()`
- **Cuándo se ejecuta:** Cada frame desde `app.js` línea 457: `this.scene.renderer.updateSkyColor(this.celestialSystem, this.scene.lights);`
- **Para qué se usa:** Calcular y aplicar el color del cielo basado en la posición e intensidad del sol
  - Durante el día: cielo azul (dispersión de Rayleigh)
  - Durante amanecer/atardecer: cielo cálido que refleja el color del sol
  - Durante la noche: cielo oscuro
- **Problema:** Se ejecuta cada frame (60 veces por segundo) aunque el estado celestial no cambie significativamente
- **Operaciones costosas que se ejecutan innecesariamente:**
  - Líneas 70-72: Extraer componentes RGB del color del sol (`sunColor.r * 255`, etc.)
  - Líneas 76-88: Cálculos de cielo cálido con interpolaciones y operaciones matemáticas
  - Líneas 96-98: Cálculo de brillo y ajuste con `adjustBrightness()`
  - Líneas 115-120: `adjustBrightness()` realiza operaciones bitwise (shift left/right) para manipular color hexadecimal
- **Impacto:** Operaciones matemáticas complejas y bitwise 60 veces por segundo cuando solo debería ejecutarse cuando el sol cambia de posición/intensidad (que puede ser cada varios segundos)

**Archivos a modificar/crear:**
- `frontend/src/core/renderer.js`

**Detalles de implementación:**
```javascript
// En Renderer class:
constructor(container) {
    // ... código existente ...
    this.lastSkyColor = null;
    this.lastSunIntensity = null;
    this.skyColorDirty = true;
    this.skyColorChangeThreshold = 0.05; // Threshold para cambios significativos (5% de cambio)
    // Este threshold significa que el color/intensidad debe cambiar al menos 5% para recalcular
}

updateSkyColor(celestialSystem, lights) {
    if (!celestialSystem || !lights || !lights.directionalLight) {
        return;
    }
    
    const sunIntensity = celestialSystem.getSunIntensity();
    const directionalLight = lights.directionalLight;
    const sunColor = directionalLight.color;
    
    // Verificar si hay cambio significativo en intensidad
    const intensityChanged = this.lastSunIntensity === null || 
        Math.abs(sunIntensity - this.lastSunIntensity) > this.skyColorChangeThreshold;
    
    // Verificar si hay cambio significativo en color RGB
    const colorChanged = this.lastSkyColor === null ||
        Math.abs(sunColor.r - this.lastSkyColor.r) > this.skyColorChangeThreshold ||
        Math.abs(sunColor.g - this.lastSkyColor.g) > this.skyColorChangeThreshold ||
        Math.abs(sunColor.b - this.lastSkyColor.b) > this.skyColorChangeThreshold;
    
    // Solo actualizar si hay cambio significativo O si está marcado como dirty
    if (!intensityChanged && !colorChanged && !this.skyColorDirty) {
        return; // No hay cambio significativo, no recalcular (AHORRO DE PERFORMANCE)
    }
    
    // Marcar como limpio
    this.skyColorDirty = false;
    
    // Guardar valores actuales para comparación en el próximo frame
    this.lastSunIntensity = sunIntensity;
    this.lastSkyColor = {
        r: sunColor.r,
        g: sunColor.g,
        b: sunColor.b
    };
    
    // AHORA ejecutar los cálculos costosos solo cuando es necesario
    // (resto del código existente de updateSkyColor, líneas 62-107)
    
    let skyColor;
    
    if (sunIntensity > 0.1) {
        // Hay luz solar: calcular color del cielo basado en el color del sol
        const sunR = sunColor.r * 255;
        const sunG = sunColor.g * 255;
        const sunB = sunColor.b * 255;
        
        const isWarmSun = sunR > sunB && sunR > 150;
        
        if (isWarmSun) {
            // Amanecer/Atardecer: cielo cálido
            const warmFactor = Math.min(1.0, (sunR - 150) / 100);
            const baseSkyBlue = { r: 135, g: 206, b: 235 };
            const warmSky = {
                r: Math.round(baseSkyBlue.r + (sunR - baseSkyBlue.r) * warmFactor * 0.5),
                g: Math.round(baseSkyBlue.g + (sunG - baseSkyBlue.g) * warmFactor * 0.5),
                b: Math.round(baseSkyBlue.b + (sunB - baseSkyBlue.b) * warmFactor * 0.3)
            };
            skyColor = (warmSky.r << 16) | (warmSky.g << 8) | warmSky.b;
        } else {
            // Día normal: cielo azul
            skyColor = 0x87CEEB;
        }
        
        const brightness = 0.3 + (sunIntensity * 0.7);
        skyColor = this.adjustBrightness(skyColor, brightness);
    } else {
        // Noche: cielo oscuro
        const nightBrightness = Math.max(0.05, sunIntensity * 0.2);
        skyColor = this.adjustBrightness(0x191970, nightBrightness);
    }
    
    this.renderer.setClearColor(skyColor);
}

// Método para forzar actualización (útil si hay cambios externos al estado celestial)
forceSkyColorUpdate() {
    this.skyColorDirty = true;
}
```

**Notas:**
- El threshold puede ajustarse según necesidades
- Mantener método para forzar actualización si es necesario
- Verificar que el color se actualiza correctamente cuando cambia

---

### Paso 6: Testing y Verificación

**Descripción:**
Verificar que las optimizaciones funcionan correctamente y miden el impacto en FPS.

**Archivos a modificar/crear:**
- Ninguno (solo testing)

**Detalles de implementación:**
1. **Testing de Object Pool:**
   - Verificar que el juego funciona igual visualmente
   - Abrir Chrome DevTools → Performance → Memory
   - Grabar un profile durante gameplay
   - Verificar que hay menos allocations
   - Verificar que no hay memory leaks
   - Medir FPS antes y después usando `window.app.performanceManager`

2. **Testing de Cache de Sistemas:**
   - Verificar que los sistemas se ejecutan en el orden correcto
   - Agregar un sistema nuevo y verificar que se reordena
   - Verificar que el cache se invalida correctamente

3. **Testing de Dirty Flag:**
   - Verificar que el color del cielo cambia correctamente cuando cambia el estado celestial
   - Verificar que no se actualiza innecesariamente
   - Probar con diferentes estados (día, noche, amanecer, atardecer)

4. **Medición de Impacto:**
   - Usar F4 → Métricas para ver FPS en tiempo real
   - Comparar FPS antes y después de cada optimización
   - Verificar que se alcanzan los objetivos (+5-10 FPS object pooling, +1-2 FPS cache, +1-2 FPS dirty flag)

**Notas:**
- Testing manual es suficiente para esta fase
- Medir impacto de cada optimización individualmente
- Documentar resultados en comentarios o README

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-047_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Object pooling reduce garbage collection significativamente
- Cachear ordenamiento reduce overhead O(n log n) cada frame
- Dirty flags evitan cálculos innecesarios
- El impacto combinado esperado es de +7-14 FPS

### Seguridad
- No aplica directamente
- Verificar que no hay memory leaks con object pooling

### Casos Edge
- **Pool agotado:** El pool debe crear nuevos objetos si es necesario
- **Sistemas que cambian frecuentemente:** El cache debe invalidarse correctamente
- **Cambios mínimos en estado celestial:** El threshold debe funcionar correctamente

### Compatibilidad
- Las optimizaciones no cambian la API pública
- Todo debe funcionar igual desde el punto de vista del usuario

## Patrones de Código a Usar

- **Object Pool Pattern:** Reutilizar objetos en lugar de crearlos y destruirlos
- **Dirty Flag Pattern:** Marcar objetos como "sucios" y solo actualizar cuando es necesario
- **Cache Pattern:** Guardar resultados de cálculos costosos

## Dependencias

### Nuevas Dependencias
Ninguna

### Variables de Entorno
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/core/optimizations/object-pool.js` - Sistema de object pooling
2. `frontend/src/core/optimizations/README.md` - Documentación de optimizaciones
3. `frontend/src/app.js` - Inicialización de pools
4. `frontend/src/ecs/systems/weapon-equip-system.js` - Uso de object pooling
5. `frontend/src/ecs/manager.js` - Cache de ordenamiento de sistemas
6. `frontend/src/core/renderer.js` - Dirty flag para color del cielo

## Testing

### Tests a Crear/Modificar
- Testing manual es suficiente para esta fase
- Usar Chrome DevTools Performance y Memory para verificar mejoras
- Medir FPS usando sistema de métricas existente (F4)

### Escenarios de Prueba
1. Object pooling funciona correctamente sin memory leaks
2. Cache de sistemas se invalida cuando cambian sistemas
3. Color del cielo solo se actualiza cuando cambia significativamente
4. Mejoras de FPS medibles y documentadas

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos JavaScript
2. Verificar en ambiente local con Docker Compose
3. Verificar métricas de FPS en diferentes escenarios

### Verificación Post-Deployment
- [ ] Verificar que el juego funciona igual visualmente
- [ ] Verificar que hay mejora de FPS medible
- [ ] Verificar que no hay memory leaks
- [ ] Verificar que no hay errores en consola
