# JDG-048 - Optimizaciones de Medio Riesgo para Mejorar FPS (Fase 2)

## Descripción de la Tarea

Implementar optimizaciones de medio riesgo que proporcionen mejoras significativas de FPS: frustum culling para solo renderizar entidades visibles, sistema de LOD (Level of Detail) para reducir complejidad de entidades lejanas, y render batching para agrupar operaciones similares.

**Comportamiento actual:**
- Todas las entidades se actualizan cada frame, incluso si están fuera de vista
- Todas las entidades se renderizan con el mismo nivel de detalle
- No hay agrupación de actualizaciones similares

**Comportamiento esperado:**
- Solo se actualizan y renderizan entidades visibles dentro del frustum
- Entidades lejanas usan menor calidad (menos polígonos, animaciones simplificadas)
- Las actualizaciones se agrupan por material o tipo similar

## Criterios de Aceptación

1. ✅ Se implementa frustum culling que verifica visibilidad de entidades
2. ✅ El Render System solo actualiza entidades visibles
3. ✅ Se observa mejora de +10-20 FPS con muchas entidades
4. ✅ Se implementa sistema LOD básico con al menos 2 niveles
5. ✅ Entidades lejanas usan menor calidad
6. ✅ Se observa mejora de +5-15 FPS después de LOD
7. ✅ Se implementa render batching que agrupa por material
8. ✅ Se observa mejora de +3-8 FPS después de batching
9. ✅ Las optimizaciones no causan artefactos visuales
10. ✅ La transición LOD es suave

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)
- [ ] Backend (FastAPI)
- [ ] Base de Datos (PostgreSQL)

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js (Frustum, InstancedMesh)
- Spatial Partitioning para frustum culling eficiente
- LOD System patterns

## Pasos de Implementación

### Paso 1: Crear Sistema de Frustum Culling

**Descripción:**
Crear un sistema de frustum culling que verifica qué entidades están visibles dentro del frustum de la cámara.

**Archivos a modificar/crear:**
- `frontend/src/core/optimizations/frustum-culling.js` (nuevo)

**Detalles de implementación:**
```javascript
import * as THREE from 'three';

/**
 * Sistema de Frustum Culling
 * Determina qué objetos están visibles dentro del frustum de la cámara
 */
export class FrustumCuller {
    constructor(camera) {
        this.camera = camera;
        this.frustum = new THREE.Frustum();
        this.matrix = new THREE.Matrix4();
    }
    
    /**
     * Actualizar frustum (debe llamarse una vez por frame antes de verificar visibilidad)
     */
    update() {
        this.matrix.multiplyMatrices(
            this.camera.projectionMatrix,
            this.camera.matrixWorldInverse
        );
        this.frustum.setFromProjectionMatrix(this.matrix);
    }
    
    /**
     * Verificar si un objeto está visible dentro del frustum
     * @param {THREE.Object3D} object - Objeto a verificar
     * @returns {boolean} True si está visible
     */
    isVisible(object) {
        if (!object || !object.visible) {
            return false;
        }
        
        // Verificar si el objeto o alguno de sus hijos está en el frustum
        return this.frustum.intersectsObject(object);
    }
    
    /**
     * Filtrar array de objetos para obtener solo los visibles
     * @param {Array<THREE.Object3D>} objects - Array de objetos
     * @returns {Array<THREE.Object3D>} Array de objetos visibles
     */
    filterVisible(objects) {
        return objects.filter(obj => this.isVisible(obj));
    }
}
```

**Notas:**
- Debe actualizarse una vez por frame antes de verificar visibilidad
- Usa THREE.Frustum de Three.js para cálculos eficientes
- **⚠️ READMEs:** Actualizar README.md de optimizations/ con documentación del frustum culling

---

### Paso 2: Integrar Frustum Culling en Render System

**Descripción:**
Modificar `render-system.js` para solo actualizar entidades visibles usando frustum culling.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/render-system.js`

**Detalles de implementación:**
```javascript
// En RenderSystem:
constructor(cellSize, frustumCuller = null) {
    super();
    // ... código existente ...
    this.frustumCuller = frustumCuller;
}

update(_deltaTime) {
    const entities = this.getEntities();
    
    // Si hay frustum culling disponible, filtrar entidades visibles
    let entitiesToProcess = entities;
    if (this.frustumCuller) {
        // Convertir entidades a meshes y filtrar visibles
        entitiesToProcess = Array.from(entities).filter(entityId => {
            const render = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.RENDER);
            if (!render || !render.mesh) return false;
            return this.frustumCuller.isVisible(render.mesh);
        });
    }
    
    for (const entityId of entitiesToProcess) {
        // ... resto del código existente ...
    }
}
```

**Notas:**
- Mantener compatibilidad si frustumCuller es null (comportamiento original)
- Verificar que todas las entidades se procesan correctamente cuando están visibles

---

### Paso 3: Integrar Frustum Culling en App Principal

**Descripción:**
Inicializar frustum culler en `app.js` y pasarlo a sistemas que lo necesitan.

**Archivos a modificar/crear:**
- `frontend/src/app.js`

**Detalles de implementación:**
```javascript
// En constructor o método de inicialización:
import { FrustumCuller } from './core/optimizations/frustum-culling.js';

// Después de inicializar scene y camera:
if (this.scene && this.scene.camera) {
    this.frustumCuller = new FrustumCuller(this.scene.camera.camera);
}

// En startAnimation(), antes de actualizar ECS:
const animate = () => {
    // ... código existente ...
    
    // Actualizar frustum culling (una vez por frame)
    if (this.frustumCuller) {
        this.frustumCuller.update();
    }
    
    // Actualizar sistemas ECS (ahora con frustum culling)
    if (this.ecs) {
        this.ecs.update(deltaTime);
    }
    
    // ... resto del código ...
};

// Pasar frustumCuller al RenderSystem cuando se crea:
// (en loadDimension o donde se crea RenderSystem)
if (!this.renderSystem) {
    this.renderSystem = new RenderSystem(
        demoDimension.tamano_celda,
        this.frustumCuller  // Pasar frustum culler
    );
    this.ecs.registerSystem(this.renderSystem);
}
```

**Notas:**
- El frustum culler debe actualizarse cada frame antes de que los sistemas lo usen
- Pasar frustum culler a sistemas que lo necesiten

---

### Paso 4: Crear Sistema de LOD (Level of Detail)

**Descripción:**
Crear un sistema básico de LOD que reduce calidad de entidades lejanas.

**Archivos a modificar/crear:**
- `frontend/src/core/optimizations/lod-manager.js` (nuevo)

**Detalles de implementación:**
```javascript
import * as THREE from 'three';

/**
 * Sistema de Level of Detail (LOD)
 * Reduce calidad de entidades lejanas para mejorar rendimiento
 */
export class LODManager {
    constructor(camera) {
        this.camera = camera;
        this.nearDistance = 20;    // Distancia cercana (alta calidad)
        this.farDistance = 50;     // Distancia lejana (baja calidad)
        this.lodLevels = {
            HIGH: 'high',    // Alta calidad: animaciones completas, todos los polígonos
            LOW: 'low'       // Baja calidad: animaciones simplificadas, menos polígonos
        };
    }
    
    /**
     * Calcular nivel de LOD basado en distancia a la cámara
     * @param {THREE.Vector3} position - Posición del objeto
     * @returns {string} Nivel de LOD ('high' o 'low')
     */
    getLODLevel(position) {
        if (!this.camera) return this.lodLevels.HIGH;
        
        const cameraPos = this.camera.position;
        const distance = position.distanceTo(cameraPos);
        
        if (distance <= this.nearDistance) {
            return this.lodLevels.HIGH;
        } else if (distance <= this.farDistance) {
            // Interpolar entre HIGH y LOW
            const t = (distance - this.nearDistance) / (this.farDistance - this.nearDistance);
            return t < 0.5 ? this.lodLevels.HIGH : this.lodLevels.LOW;
        } else {
            return this.lodLevels.LOW;
        }
    }
    
    /**
     * Actualizar LOD para una entidad
     * @param {number} entityId - ID de la entidad
     * @param {Object} renderComponent - Componente Render de la entidad
     * @param {Object} animationComponent - Componente Animation de la entidad (opcional)
     */
    updateLOD(entityId, renderComponent, animationComponent = null) {
        if (!renderComponent || !renderComponent.mesh) return;
        
        const mesh = renderComponent.mesh;
        const position = mesh.position;
        const lodLevel = this.getLODLevel(position);
        
        // Aplicar LOD según nivel
        if (lodLevel === this.lodLevels.LOW) {
            // Baja calidad: simplificar renderizado
            mesh.visible = true; // Mantener visible pero simplificar
            
            // Reducir calidad de animación si hay componente de animación
            if (animationComponent && animationComponent.mixer) {
                // Reducir velocidad de actualización de animación (cada 2 frames)
                animationComponent.updateFrequency = 2;
            }
        } else {
            // Alta calidad: renderizado completo
            mesh.visible = true;
            
            if (animationComponent && animationComponent.mixer) {
                animationComponent.updateFrequency = 1; // Cada frame
            }
        }
        
        // Guardar nivel de LOD actual
        mesh.userData.lodLevel = lodLevel;
    }
}
```

**Notas:**
- Implementar LOD básico primero (2 niveles)
- Puede extenderse a más niveles en el futuro
- Ajustar distancias según necesidades del juego

---

### Paso 5: Integrar LOD en Animation Mixer System

**Descripción:**
Modificar `animation-mixer-system.js` para respetar frecuencia de actualización según LOD.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// En AnimationMixerSystem:
constructor(lodManager = null) {
    super();
    // ... código existente ...
    this.lodManager = lodManager;
    this.frameCounter = 0; // Para LOD update frequency
}

update(deltaTime) {
    this.frameCounter++;
    const entities = this.getEntities();
    
    for (const entityId of entities) {
        // ... código existente para obtener componentes ...
        
        // Verificar LOD si está disponible
        let shouldUpdate = true;
        if (this.lodManager && animationComponent) {
            animationComponent.updateFrequency = animationComponent.updateFrequency || 1;
            shouldUpdate = (this.frameCounter % animationComponent.updateFrequency === 0);
        }
        
        if (!shouldUpdate) continue;
        
        // ... resto del código de actualización del mixer ...
    }
}
```

**Notas:**
- Respeter frecuencia de actualización si está configurada por LOD
- Mantener compatibilidad si LOD no está disponible

---

### Paso 6: Integrar LOD Manager en App Principal

**Descripción:**
Inicializar LOD manager y conectarlo con sistemas relevantes.

**Archivos a modificar/crear:**
- `frontend/src/app.js`

**Detalles de implementación:**
```javascript
// Importar y crear LOD manager:
import { LODManager } from './core/optimizations/lod-manager.js';

// Después de inicializar scene y camera:
if (this.scene && this.scene.camera) {
    this.lodManager = new LODManager(this.scene.camera.camera);
}

// Pasar LOD manager a sistemas cuando se crean:
// (ajustar según cómo se crean los sistemas)
```

---

### Paso 7: Crear Sistema de Render Batching

**Descripción:**
Crear sistema para agrupar actualizaciones de renderizado por material.

**Archivos a modificar/crear:**
- `frontend/src/core/optimizations/render-batcher.js` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Sistema de Render Batching
 * Agrupa actualizaciones de renderizado para mejor rendimiento
 */
export class RenderBatcher {
    constructor() {
        this.batches = new Map(); // material UUID -> meshes[]
        this.needsUpdate = false;
    }
    
    /**
     * Agregar mesh a un batch
     * @param {THREE.Mesh} mesh - Mesh a agregar
     */
    add(mesh) {
        if (!mesh || !mesh.material) return;
        
        const materialKey = mesh.material.uuid || 'default';
        if (!this.batches.has(materialKey)) {
            this.batches.set(materialKey, []);
        }
        this.batches.get(materialKey).push(mesh);
        this.needsUpdate = true;
    }
    
    /**
     * Limpiar batches (llamar al final de cada frame)
     */
    clear() {
        this.batches.clear();
        this.needsUpdate = false;
    }
    
    /**
     * Obtener batches agrupados por material
     * @returns {Map} Map de material UUID -> meshes[]
     */
    getBatches() {
        return this.batches;
    }
}
```

**Notas:**
- El batching puede integrarse en el Render System o usarse antes del render final
- Agrupar por material reduce cambios de estado de GPU

---

### Paso 8: Testing y Verificación

**Descripción:**
Verificar que todas las optimizaciones funcionan correctamente y miden el impacto.

**Archivos a modificar/crear:**
- Ninguno (solo testing)

**Detalles de implementación:**
1. **Testing de Frustum Culling:**
   - Verificar que entidades visibles se renderizan
   - Verificar que entidades fuera de vista no se procesan
   - Probar con cámara moviéndose
   - Medir FPS con muchas entidades (50+)

2. **Testing de LOD:**
   - Verificar que entidades cercanas tienen alta calidad
   - Verificar que entidades lejanas tienen menor calidad
   - Probar transición entre niveles
   - Verificar que no hay artefactos visuales

3. **Testing de Render Batching:**
   - Verificar que el renderizado funciona correctamente
   - Medir draw calls con y sin batching
   - Verificar que no hay bugs visuales

4. **Medición de Impacto:**
   - Medir FPS antes y después de cada optimización
   - Documentar resultados

**Notas:**
- Testing manual con diferentes escenarios
- Verificar que no hay regresiones

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos, genera la descripción del PR usando `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-048_pr-description_[FECHA-HORA].md`
- Descripción completa del PR lista para Git

---

## Consideraciones Técnicas

### Performance
- Frustum culling: +10-20 FPS con muchas entidades
- LOD: +5-15 FPS
- Render batching: +3-8 FPS
- Impacto combinado: +18-43 FPS

### Casos Edge
- Entidades parcialmente visibles
- Cámara rotando rápidamente
- Transición LOD suave
- Muchas entidades del mismo material

## Dependencias

### Dependencias
- Depende de: JDG-047 (Fase 1)

## Archivos Principales Involucrados

1. `frontend/src/core/optimizations/frustum-culling.js` - Sistema de frustum culling
2. `frontend/src/core/optimizations/lod-manager.js` - Sistema de LOD
3. `frontend/src/core/optimizations/render-batcher.js` - Sistema de batching
4. `frontend/src/ecs/systems/render-system.js` - Integración de frustum culling
5. `frontend/src/ecs/systems/animation-mixer-system.js` - Integración de LOD
6. `frontend/src/app.js` - Inicialización de sistemas
