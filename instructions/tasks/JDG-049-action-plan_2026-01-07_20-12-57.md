# JDG-049 - Optimizaciones Avanzadas para Mejorar FPS (Fase 3)

## Descripción de la Tarea

Implementar optimizaciones avanzadas para maximizar rendimiento: instancing para entidades similares usando `InstancedMesh`, frame scheduling para distribuir trabajo, y spatial partitioning para optimizar queries espaciales.

**Comportamiento actual:**
- Cada entidad tiene su propio mesh individual
- Todas las entidades se actualizan cada frame
- No hay estructura espacial para queries eficientes

**Comportamiento esperado:**
- Entidades similares se agrupan en InstancedMesh
- Entidades lejanas se actualizan cada 2-3 frames
- Spatial partitioning para queries eficientes

## Criterios de Aceptación

1. ✅ Se implementa instancing que agrupa entidades similares
2. ✅ Draw calls se reducen 50-70%
3. ✅ Se observa +20-40 FPS con muchas entidades similares
4. ✅ Frame scheduling distribuye trabajo correctamente
5. ✅ Se observa +5-10 FPS después de frame scheduling
6. ✅ Spatial partitioning funciona para queries espaciales
7. ✅ Se observa +3-7 FPS después de spatial partitioning
8. ✅ No hay bugs o artefactos visuales

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)
- [ ] Backend (FastAPI)

### Tecnologías Involucradas
- Three.js (InstancedMesh, BufferGeometry)
- Spatial Partitioning (Octree o Grid)
- Frame scheduling patterns

## Pasos de Implementación

### Paso 1: Crear Instancing Manager

**Descripción:**
Crear sistema para agrupar entidades similares en InstancedMesh.

**Archivos a modificar/crear:**
- `frontend/src/core/optimizations/instancing-manager.js` (nuevo)

**Detalles de implementación:**
```javascript
import * as THREE from 'three';

/**
 * Gestor de Instancing para entidades similares
 * Agrupa entidades con mismo mesh/material en InstancedMesh
 */
export class InstancingManager {
    constructor(scene) {
        this.scene = scene;
        this.instanceGroups = new Map(); // meshKey -> InstancedMesh
    }
    
    /**
     * Crear o obtener instancia agrupada
     * @param {string} meshKey - Clave única para el tipo de mesh (ej: "tree_01")
     * @param {THREE.BufferGeometry} geometry - Geometría del mesh
     * @param {THREE.Material} material - Material del mesh
     * @param {number} maxInstances - Máximo de instancias (default: 1000)
     * @returns {THREE.InstancedMesh} Instancia agrupada
     */
    getOrCreateInstanceGroup(meshKey, geometry, material, maxInstances = 1000) {
        if (this.instanceGroups.has(meshKey)) {
            return this.instanceGroups.get(meshKey);
        }
        
        const instancedMesh = new THREE.InstancedMesh(geometry, material, maxInstances);
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instanceGroups.set(meshKey, instancedMesh);
        this.scene.add(instancedMesh);
        
        return instancedMesh;
    }
    
    /**
     * Actualizar transformación de una instancia
     * @param {THREE.InstancedMesh} instancedMesh - Mesh instanciado
     * @param {number} instanceId - ID de la instancia
     * @param {THREE.Matrix4} matrix - Matriz de transformación
     */
    updateInstanceTransform(instancedMesh, instanceId, matrix) {
        instancedMesh.setMatrixAt(instanceId, matrix);
        instancedMesh.instanceMatrix.needsUpdate = true;
    }
    
    /**
     * Limpiar instancias no usadas
     */
    cleanup() {
        // Implementar limpieza de instancias no usadas si es necesario
    }
}
```

**Notas:**
- Identificar entidades con mismo geometry/material
- Agrupar en InstancedMesh
- Actualizar matrices de instancia cada frame

---

### Paso 2: Integrar Instancing en Render System

**Descripción:**
Modificar Render System para usar instancing cuando sea apropiado.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/render-system.js`

**Detalles de implementación:**
- Identificar entidades con mismo mesh/material
- Agrupar en instancias
- Actualizar matrices de instancia

---

### Paso 3: Crear Frame Scheduler

**Descripción:**
Crear sistema para distribuir trabajo a lo largo de múltiples frames.

**Archivos a modificar/crear:**
- `frontend/src/core/optimizations/frame-scheduler.js` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Frame Scheduler
 * Distribuye trabajo pesado a lo largo de múltiples frames
 */
export class FrameScheduler {
    constructor() {
        this.updateQueues = new Map(); // frequency -> entityIds[]
        this.frameCounter = 0;
    }
    
    /**
     * Registrar entidad para actualización con frecuencia específica
     * @param {number} entityId - ID de la entidad
     * @param {number} frequency - Cada cuántos frames actualizar (1 = cada frame, 2 = cada 2 frames, etc.)
     */
    register(entityId, frequency = 1) {
        if (!this.updateQueues.has(frequency)) {
            this.updateQueues.set(frequency, new Set());
        }
        this.updateQueues.get(frequency).add(entityId);
    }
    
    /**
     * Desregistrar entidad
     * @param {number} entityId - ID de la entidad
     */
    unregister(entityId) {
        for (const queue of this.updateQueues.values()) {
            queue.delete(entityId);
        }
    }
    
    /**
     * Obtener entidades que deben actualizarse este frame
     * @returns {Set<number>} Set de entity IDs
     */
    getEntitiesToUpdate() {
        const entitiesToUpdate = new Set();
        this.frameCounter++;
        
        for (const [frequency, entityIds] of this.updateQueues.entries()) {
            if (this.frameCounter % frequency === 0) {
                entityIds.forEach(id => entitiesToUpdate.add(id));
            }
        }
        
        return entitiesToUpdate;
    }
    
    /**
     * Reset frame counter (si es necesario)
     */
    reset() {
        this.frameCounter = 0;
    }
}
```

**Notas:**
- Usar distancia para determinar frecuencia de actualización
- Entidades cercanas: cada frame
- Entidades lejanas: cada 2-3 frames

---

### Paso 4: Integrar Frame Scheduler en ECS Manager

**Descripción:**
Modificar ECS Manager para usar frame scheduling.

**Archivos a modificar/crear:**
- `frontend/src/ecs/manager.js`

**Detalles de implementación:**
- Integrar frame scheduler
- Filtrar entidades a actualizar según frecuencia

---

### Paso 5: Crear Spatial Partition (Grid)

**Descripción:**
Crear estructura de spatial partitioning usando grid para organizar entidades/partículas.

**Archivos a modificar/crear:**
- `frontend/src/core/optimizations/spatial-partition.js` (nuevo)

**Detalles de implementación:**
```javascript
/**
 * Spatial Partition usando Grid
 * Organiza entidades/partículas en grid para queries eficientes
 */
export class SpatialGrid {
    constructor(cellSize = 10) {
        this.cellSize = cellSize;
        this.grid = new Map(); // "x,y,z" -> Set<entityId>
    }
    
    /**
     * Obtener clave de celda para posición
     * @param {number} x - Posición X
     * @param {number} y - Posición Y
     * @param {number} z - Posición Z
     * @returns {string} Clave de celda
     */
    getCellKey(x, y, z) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        const cz = Math.floor(z / this.cellSize);
        return `${cx},${cy},${cz}`;
    }
    
    /**
     * Insertar entidad en grid
     * @param {number} entityId - ID de la entidad
     * @param {number} x - Posición X
     * @param {number} y - Posición Y
     * @param {number} z - Posición Z
     */
    insert(entityId, x, y, z) {
        const key = this.getCellKey(x, y, z);
        if (!this.grid.has(key)) {
            this.grid.set(key, new Set());
        }
        this.grid.get(key).add(entityId);
    }
    
    /**
     * Obtener entidades en rango
     * @param {number} x - Posición X
     * @param {number} y - Posición Y
     * @param {number} z - Posición Z
     * @param {number} radius - Radio de búsqueda
     * @returns {Set<number>} Set de entity IDs
     */
    queryRange(x, y, z, radius) {
        const results = new Set();
        const minCell = this.getCellKey(x - radius, y - radius, z - radius);
        const maxCell = this.getCellKey(x + radius, y + radius, z + radius);
        
        // Obtener celdas en rango (simplificado)
        // En implementación completa, iterar sobre todas las celdas en el rango
        
        return results;
    }
    
    /**
     * Limpiar grid
     */
    clear() {
        this.grid.clear();
    }
}
```

**Notas:**
- Implementar grid básico primero
- Puede extenderse a octree en el futuro
- Usar para frustum culling y colisiones

---

### Paso 6: Integrar Spatial Partition en Collision System

**Descripción:**
Modificar Collision System para usar spatial partitioning.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/collision-system.js`

**Detalles de implementación:**
- Usar spatial grid para queries de colisión
- Reducir número de entidades a verificar

---

### Paso 7: Testing y Verificación

**Descripción:**
Verificar que todas las optimizaciones avanzadas funcionan correctamente.

**Detalles:**
1. Testing de instancing
2. Testing de frame scheduling
3. Testing de spatial partitioning
4. Medición de impacto total

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Generar descripción del PR usando `@pr-description.mdc`.

**Comando:**
```
@pr-description.mdc
```

---

## Consideraciones Técnicas

### Performance
- Instancing: +20-40 FPS, -50-70% draw calls
- Frame scheduling: +5-10 FPS
- Spatial partitioning: +3-7 FPS
- Impacto combinado: +28-57 FPS

### Complejidad
- Instancing requiere gestión cuidadosa de instancias
- Frame scheduling puede causar lag visual si no se implementa bien
- Spatial partitioning requiere mantenimiento de estructura

## Dependencias

- Depende de: JDG-047 (Fase 1), JDG-048 (Fase 2)

## Archivos Principales Involucrados

1. `frontend/src/core/optimizations/instancing-manager.js`
2. `frontend/src/core/optimizations/frame-scheduler.js`
3. `frontend/src/core/optimizations/spatial-partition.js`
4. `frontend/src/ecs/systems/render-system.js`
5. `frontend/src/ecs/systems/collision-system.js`
6. `frontend/src/ecs/manager.js`
