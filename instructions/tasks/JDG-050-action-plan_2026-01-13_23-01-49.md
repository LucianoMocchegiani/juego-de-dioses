# JDG-050 - Refactorizar renderParticles() en Métodos Más Pequeños

## Descripción de la Tarea

Refactorizar el método `renderParticles()` del `ParticleRenderer` dividiéndolo en 6 métodos helper privados más pequeños y enfocados, siguiendo el principio de responsabilidad única. Esto mejorará la mantenibilidad, legibilidad y testabilidad del código sin cambiar la funcionalidad.

**Comportamiento actual:**
- El método `renderParticles()` tiene aproximadamente 330 líneas de código (líneas 179-508)
- Realiza múltiples responsabilidades en un solo método:
  - Aplicar frustum culling
  - Aplicar optimización LOD
  - Aplicar ajuste adaptativo de límite
  - Aplicar limitación por densidad
  - Agrupar partículas por geometría+material
  - Separar grupos opacos de transparentes
  - Crear instanced meshes
  - Construir índice de partículas
- Todo el flujo está mezclado en un solo método grande
- Dificulta la comprensión, testing y mantenimiento

**Comportamiento esperado:**
- `renderParticles()` refactorizado como orquestador que llama a métodos helper
- 6 métodos helper privados (prefijo `_`) cada uno con responsabilidad única:
  1. `_applyFrustumCulling()` - Aplicar frustum culling
  2. `_applyLODOptimization()` - Aplicar LOD
  3. `_applyAdaptiveLimiting()` - Ajustar límite según FPS
  4. `_applyParticleLimiting()` - Aplicar limitación por densidad
  5. `_buildParticleGroups()` - Agrupar por geometría
  6. `_createInstancedMeshes()` - Crear instanced meshes
- Funcionalidad idéntica al código anterior (sin regresiones)
- Código más legible, mantenible y testable
- Todos los logs se mantienen

## Criterios de Aceptación

1. ❌ Método `renderParticles()` refactorizado en 6 métodos helper privados
2. ❌ Cada método helper tiene una responsabilidad única y clara
3. ❌ El método `renderParticles()` actúa como orquestador
4. ❌ Funcionalidad idéntica al código anterior (sin regresiones)
5. ❌ Todos los logs se mantienen en los lugares correctos
6. ❌ Código más legible y fácil de entender
7. ❌ Sin errores de compilación o linting
8. ❌ Verificado que el renderizado funciona correctamente

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (InstancedMesh, Vector3, Matrix4, Camera)
- Refactorización siguiendo principios SOLID

### Archivos Principales
- `frontend/src/terrain/renderers/particle-renderer.js` - Archivo a refactorizar

## Pasos de Implementación

### Paso 1: Extraer _applyFrustumCulling()

**Descripción:**
Extraer la lógica de frustum culling (líneas 195-214) a un método privado `_applyFrustumCulling()`.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**

1. Crear el método privado `_applyFrustumCulling()` después del método `renderParticles()` (o antes, según organización de la clase):
```javascript
/**
 * Aplicar frustum culling si está habilitado
 * @private
 * @param {Array} particles - Partículas a filtrar
 * @param {THREE.Camera|null} camera - Cámara para frustum culling
 * @param {number} cellSize - Tamaño de celda
 * @returns {Array} - Partículas visibles
 */
_applyFrustumCulling(particles, camera, cellSize) {
    if (!this.enableFrustumCulling || !camera) {
        return particles;
    }
    
    // Lazy-load frustumCache solo si está habilitado
    if (!this._frustumCache) {
        this._frustumCache = new FrustumCache();
    }
    
    const particlesBefore = particles.length;
    const visible = this._frustumCache.getVisible(particles, camera, cellSize);
    
    debugLogger.info('ParticleRenderer', 'Frustum culling aplicado', {
        antes: particlesBefore,
        despues: visible.length,
        filtradas: particlesBefore - visible.length,
        porcentajeFiltrado: particlesBefore > 0 
            ? ((particlesBefore - visible.length) / particlesBefore * 100).toFixed(1) + '%'
            : '0%'
    });
    
    return visible;
}
```

2. Reemplazar las líneas 195-214 en `renderParticles()` con:
```javascript
// 1. Aplicar frustum culling si está habilitado
let particlesToRender = this._applyFrustumCulling(particles, camera, cellSize);
```

**Notas:**
- Mantener exactamente la misma lógica y logs
- El método debe retornar las partículas sin modificar si frustum culling está deshabilitado
- Verificar que el comportamiento sea idéntico

**Testing:**
- Verificar que frustum culling funciona igual que antes
- Probar con frustum culling habilitado y deshabilitado
- Probar con cámara nula
- Verificar que los logs aparecen correctamente

---

### Paso 2: Extraer _applyLODOptimization()

**Descripción:**
Extraer la lógica de optimización LOD (líneas 216-254) a un método privado `_applyLODOptimization()`.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**

1. Crear el método privado `_applyLODOptimization()`:
```javascript
/**
 * Aplicar optimización LOD si está habilitado
 * @private
 * @param {Array} particles - Partículas a procesar
 * @param {THREE.Vector3|Object|null} playerPosition - Posición del jugador
 * @param {THREE.Camera|null} camera - Cámara
 * @param {number} cellSize - Tamaño de celda
 * @returns {Array} - Partículas con metadata LOD aplicada
 */
_applyLODOptimization(particles, playerPosition, camera, cellSize) {
    const particlesBefore = particles.length;
    
    if (!this.enableLOD || (!playerPosition && !camera)) {
        return particles;
    }
    
    // Usar posición del jugador para LOD si está disponible, sino usar cámara
    const { position: lodReferencePosition, source: lodSourceRaw } = this._getReferencePosition(playerPosition, camera);
    const lodSource = lodSourceRaw === 'player' ? 'jugador' : lodSourceRaw === 'camera' ? 'cámara' : 'none';
    
    if (lodReferencePosition && particles.length > 0) {
        debugLogger.info('ParticleRenderer', 'Aplicando LOD', {
            antes: particlesBefore,
            referencia: lodSource,
            referenciaPos: {
                x: lodReferencePosition.x?.toFixed(2),
                y: lodReferencePosition.y?.toFixed(2),
                z: lodReferencePosition.z?.toFixed(2)
            }
        });
        
        const result = this.lodManager.applyLOD(
            particles,
            lodReferencePosition,
            cellSize
        );
        
        debugLogger.info('ParticleRenderer', 'LOD aplicado', {
            antes: particlesBefore,
            despues: result.length,
            filtradas: particlesBefore - result.length,
            referencia: lodSource
        });
        
        return result;
    } else if (this.enableLOD) {
        debugLogger.warn('ParticleRenderer', 'LOD habilitado pero sin referencia o sin partículas', {
            hasReference: !!lodReferencePosition,
            particlesBefore: particlesBefore,
            referencia: lodSource
        });
    }
    
    return particles;
}
```

2. Reemplazar las líneas 216-254 en `renderParticles()` con:
```javascript
// 2. Aplicar LOD si está habilitado
particlesToRender = this._applyLODOptimization(particlesToRender, playerPosition, camera, cellSize);
```

**Notas:**
- Mantener exactamente la misma lógica de referencia (jugador vs cámara)
- Mantener todos los logs existentes
- El método debe retornar las partículas sin modificar si LOD está deshabilitado

**Testing:**
- Verificar que LOD funciona igual que antes
- Probar con LOD habilitado y deshabilitado
- Probar con posición de jugador, solo cámara, y sin ninguno
- Verificar que los logs aparecen correctamente

---

### Paso 3: Extraer _applyAdaptiveLimiting()

**Descripción:**
Extraer la lógica de ajuste adaptativo de límite (líneas 256-273) a un método privado `_applyAdaptiveLimiting()`.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**

1. Crear el método privado `_applyAdaptiveLimiting()`:
```javascript
/**
 * Aplicar ajuste dinámico de límite según FPS
 * @private
 */
_applyAdaptiveLimiting() {
    if (!this.enableAdaptiveLimiting || !this.adaptiveLimiter) {
        if (this.enableAdaptiveLimiting) {
            debugLogger.warn('ParticleRenderer', 'Adaptación dinámica habilitada pero AdaptiveLimiter no está disponible');
        }
        return;
    }
    
    const adaptiveLimit = this.adaptiveLimiter.getCurrentLimit();
    const previousLimit = this.particleLimiter.maxParticles;
    
    // Aplicar límite adaptativo
    this.particleLimiter.setMaxParticles(adaptiveLimit);
    
    // Log solo cuando cambia el límite (para no saturar)
    if (adaptiveLimit !== previousLimit) {
        const fps = this.adaptiveLimiter.performanceManager?.getMetrics()?.fps || 0;
        debugLogger.info('ParticleRenderer', 'Límite adaptativo aplicado', {
            fps: fps,
            limiteAdaptivo: adaptiveLimit,
            limiteAnterior: previousLimit
        });
    }
}
```

2. Reemplazar las líneas 256-273 en `renderParticles()` con:
```javascript
// 2.5. Ajustar límite dinámicamente según FPS si está habilitado
this._applyAdaptiveLimiting();
```

**Notas:**
- Este método no retorna nada, solo ajusta el límite del `particleLimiter`
- El método debe retornar temprano si adaptive limiting está deshabilitado
- Mantener el log solo cuando cambia el límite (para evitar saturación)

**Testing:**
- Verificar que adaptive limiting funciona igual que antes
- Probar con adaptive limiting habilitado y deshabilitado
- Verificar que los logs aparecen solo cuando cambia el límite
- Verificar que el límite se aplica correctamente al `particleLimiter`

---

### Paso 4: Extraer _applyParticleLimiting()

**Descripción:**
Extraer la lógica de limitación por densidad (líneas 275-340) a un método privado `_applyParticleLimiting()`.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**

1. Crear el método privado `_applyParticleLimiting()`:
```javascript
/**
 * Aplicar limitación por densidad si está habilitado
 * @private
 * @param {Array} particles - Partículas a limitar
 * @param {THREE.Vector3|Object|null} playerPosition - Posición del jugador
 * @param {THREE.Camera|null} camera - Cámara
 * @param {number} cellSize - Tamaño de celda
 * @returns {Array} - Partículas limitadas
 */
_applyParticleLimiting(particles, playerPosition, camera, cellSize) {
    if (!this.enableParticleLimiting || (!playerPosition && !camera)) {
        if (this.enableParticleLimiting && !camera) {
            debugLogger.warn('ParticleRenderer', 'Limitación con densidad DESHABILITADA: sin cámara. Las optimizaciones no se aplicarán.', {
                particulasInput: particles.length,
                limiteActual: this.particleLimiter.maxParticles
            }, { throttleMs: 1000 });
        } else if (!this.enableParticleLimiting) {
            debugLogger.warn('ParticleRenderer', 'Limitación de partículas DESHABILITADA', {
                particulasInput: particles.length
            });
        }
        return particles;
    }
    
    // Priorizar posición del jugador si está disponible, sino usar cámara
    const { position: referencePosition, source: positionSource } = this._getReferencePosition(playerPosition, camera);
    
    if (!referencePosition) {
        debugLogger.warn('ParticleRenderer', 'Limitación habilitada pero no hay posición de referencia (jugador o cámara)');
        return particles;
    }
    
    const particlesBeforeLimit = particles.length;
    
    if (particlesBeforeLimit === 0) {
        debugLogger.warn('ParticleRenderer', 'No hay partículas para limitar (todas fueron filtradas antes)', {
            particulasAntesLimit: particlesBeforeLimit
        });
        return particles;
    }
    
    debugLogger.info('ParticleRenderer', 'Aplicando limitación por densidad', {
        positionSource: positionSource,
        referencePosition: {
            x: referencePosition.x?.toFixed(2),
            y: referencePosition.y?.toFixed(2),
            z: referencePosition.z?.toFixed(2)
        },
        particlesBeforeLimit: particlesBeforeLimit,
        limiteMax: this.particleLimiter.maxParticles,
        nearDistance: this.densityDistances.near,
        farDistance: this.densityDistances.far
    });
    
    const limited = this.particleLimiter.limitParticlesWithDensity(
        particles,
        referencePosition, // Usar posición del jugador (no cámara)
        cellSize,
        this.densityDistances.near,  // nearDistance (metros)
        this.densityDistances.far,    // farDistance (metros)
        WATER_OPTIMIZATION_OPTIONS
    );
    
    debugLogger.info('ParticleRenderer', 'Limitación por densidad aplicada', {
        particlesBefore: particlesBeforeLimit,
        particlesAfter: limited.length,
        reduccion: particlesBeforeLimit > 0
            ? ((1 - limited.length / particlesBeforeLimit) * 100).toFixed(1) + '%'
            : '0%',
        limiteMax: this.particleLimiter.maxParticles
    });
    
    return limited;
}
```

2. Reemplazar las líneas 275-340 en `renderParticles()` con:
```javascript
// 2.6. Aplicar limitación agresiva de partículas con densidad reducida si está habilitado
particlesToRender = this._applyParticleLimiting(particlesToRender, playerPosition, camera, cellSize);
```

**Notas:**
- Mantener exactamente la misma lógica de referencia (jugador vs cámara)
- Mantener todos los logs existentes (incluyendo los warnings)
- El método debe retornar las partículas sin modificar si limitación está deshabilitada
- Nota: Los logs de "después de frustum/LOD" se quitarán porque esa información ya no está disponible en este método (se puede calcular desde el input si es necesario)

**Testing:**
- Verificar que limitación por densidad funciona igual que antes
- Probar con limitación habilitada y deshabilitada
- Probar con posición de jugador, solo cámara, y sin ninguno
- Verificar que los logs aparecen correctamente
- Verificar que las partículas se limitan correctamente

---

### Paso 5: Extraer _buildParticleGroups()

**Descripción:**
Extraer la lógica de agrupación de partículas por geometría (líneas 342-438) a un método privado `_buildParticleGroups()`.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**

1. Crear el método privado `_buildParticleGroups()`:
```javascript
/**
 * Construir grupos de partículas por geometría+material
 * @private
 * @param {Array} particles - Partículas ya optimizadas
 * @param {Map} tiposEstilos - Estilos por tipo
 * @param {Map} agrupacionesGeometria - Geometrías por agrupación
 * @param {number} cellSize - Tamaño de celda
 * @returns {Object} - Objeto con {opaqueGroups, transparentGroups}
 */
_buildParticleGroups(particles, tiposEstilos, agrupacionesGeometria, cellSize) {
    // Ordenar partículas por profundidad (celda_z) de mayor a menor
    const sortedParticles = sortParticlesByDepth(particles);
    
    // Agrupar partículas por geometría+material para instanced rendering
    const particlesByGeometry = new Map();
    
    sortedParticles.forEach((particle) => {
        const tipoEstilos = tiposEstilos.get(particle.tipo);
        const agrupacionGeom = agrupacionesGeometria?.get(particle.agrupacion_id);
        
        // Obtener estilo
        const estilo = this.getStyle(particle, tipoEstilos);
        const opacity = estilo.opacity !== undefined ? estilo.opacity : 1.0;
        
        // Saltar partículas invisibles
        if (opacity === 0.0) {
            return;
        }
        
        // Obtener tipo y parámetros de geometría para la clave
        let geometryType = 'box';
        let geometryParams = {};
        
        if (particle.agrupacion_id && agrupacionGeom) {
            const parteEntidad = particle.propiedades?.parte_entidad;
            if (parteEntidad && agrupacionGeom.partes && agrupacionGeom.partes[parteEntidad]) {
                const parteDef = agrupacionGeom.partes[parteEntidad];
                if (parteDef.geometria) {
                    geometryType = parteDef.geometria.tipo;
                    geometryParams = parteDef.geometria.parametros || {};
                }
            }
        } else if (tipoEstilos?.geometria) {
            // Nueva estructura: geometria directa
            geometryType = tipoEstilos.geometria.tipo;
            geometryParams = tipoEstilos.geometria.parametros || {};
        } else if (tipoEstilos?.visual?.geometria) {
            // Estructura antigua: visual.geometria (compatibilidad)
            geometryType = tipoEstilos.visual.geometria.tipo;
            geometryParams = tipoEstilos.visual.geometria.parametros || {};
        }
        
        // Obtener nivel LOD de la partícula (si fue aplicado)
        const lodLevel = particle._lodLevel || 'high';
        
        // Obtener geometría con LOD desde cache
        const geometry = this.geometryCacheLOD.getGeometry(
            geometryType,
            geometryParams,
            lodLevel,
            cellSize
        );
        
        // Crear clave única para geometría+material+LOD
        const geometryKey = this.getGeometryKey(geometryType, geometryParams, estilo, lodLevel);
        
        if (!particlesByGeometry.has(geometryKey)) {
            particlesByGeometry.set(geometryKey, {
                geometry: geometry,
                estilo: estilo,
                particles: []
            });
        }
        
        particlesByGeometry.get(geometryKey).particles.push(particle);
    });
    
    // Separar grupos opacos de transparentes
    const opaqueGroups = [];
    const transparentGroups = [];
    
    particlesByGeometry.forEach((group, geometryKey) => {
        const opacity = group.estilo.opacity !== undefined ? group.estilo.opacity : 1.0;
        const isTransparent = group.estilo.isError || opacity < 1.0;
        
        // Calcular profundidad promedio del grupo (para ordenamiento)
        const avgDepth = group.particles.reduce((sum, p) => sum + p.celda_z, 0) / group.particles.length;
        
        const groupData = { group, geometryKey, avgDepth };
        
        if (isTransparent) {
            transparentGroups.push(groupData);
        } else {
            opaqueGroups.push(groupData);
        }
    });
    
    // Ordenar grupos opacos por profundidad (más profundos primero)
    opaqueGroups.sort((a, b) => b.avgDepth - a.avgDepth);
    
    // OPTIMIZACIÓN: Ordenar grupos transparentes solo si hay muchos (evitar costo innecesario)
    if (transparentGroups.length > 1) {
        // Ordenar grupos transparentes por profundidad (más profundos primero)
        transparentGroups.sort((a, b) => b.avgDepth - a.avgDepth);
    }
    
    return { opaqueGroups, transparentGroups };
}
```

2. Reemplazar las líneas 342-438 en `renderParticles()` con:
```javascript
// 3. Construir grupos de partículas por geometría
const groups = this._buildParticleGroups(particlesToRender, tiposEstilos, agrupacionesGeometria, cellSize);
```

**Notas:**
- El método retorna un objeto con `opaqueGroups` y `transparentGroups`
- Mantener exactamente la misma lógica de agrupación y ordenamiento
- Mantener todas las optimizaciones existentes (ordenamiento condicional de transparentes)

**Testing:**
- Verificar que las partículas se agrupan correctamente
- Verificar que los grupos opacos y transparentes se separan correctamente
- Verificar que el ordenamiento funciona correctamente
- Verificar que las partículas invisibles se saltan

---

### Paso 6: Extraer _createInstancedMeshes()

**Descripción:**
Extraer la lógica de creación de instanced meshes (líneas 440-508) a un método privado `_createInstancedMeshes()`.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**

1. Crear el método privado `_createInstancedMeshes()`:
```javascript
/**
 * Crear instanced meshes para los grupos
 * @private
 * @param {Object} groups - Grupos {opaqueGroups, transparentGroups}
 * @param {number} cellSize - Tamaño de celda
 * @param {THREE.Scene} scene - Escena Three.js
 * @param {number} totalInputParticles - Número total de partículas de entrada (para logs)
 * @returns {Map<string, THREE.InstancedMesh>} - Map de meshes creados
 */
_createInstancedMeshes(groups, cellSize, scene, totalInputParticles) {
    // Limpiar índice anterior
    this.particleIndex.clear();
    
    // Crear instanced meshes para cada grupo
    const instancedMeshes = new Map();
    
    // Renderizar primero grupos opacos, luego transparentes
    const groupsToRender = [...groups.opaqueGroups, ...groups.transparentGroups];
    
    groupsToRender.forEach(({ group, geometryKey }) => {
        const count = group.particles.length;
        
        // Obtener material desde pool (reutilizar materiales)
        const material = this.getMaterial(group.estilo);
        
        // Dividir en múltiples instanced meshes si es necesario
        const numMeshes = Math.ceil(count / MAX_INSTANCES_PER_MESH);
        
        for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {
            const start = meshIndex * MAX_INSTANCES_PER_MESH;
            const end = Math.min(start + MAX_INSTANCES_PER_MESH, count);
            const particlesChunk = group.particles.slice(start, end);
            
            // Crear instanced mesh para este chunk
            const instancedMesh = new THREE.InstancedMesh(
                group.geometry,
                material,
                particlesChunk.length
            );
            
            // Configurar posiciones de instancias y construir índice
            const matrix = new THREE.Matrix4();
            const meshKey = numMeshes > 1 ? `${geometryKey}_${meshIndex}` : geometryKey;
            
            particlesChunk.forEach((particle, chunkIndex) => {
                const pos = this._calculateParticlePosition(particle, cellSize);
                matrix.setPosition(pos.x, pos.y, pos.z);
                instancedMesh.setMatrixAt(chunkIndex, matrix);
                
                // Guardar en índice: particleId -> {meshKey, instanceIndex}
                this.particleIndex.set(particle.id, {
                    meshKey: meshKey,
                    instanceIndex: chunkIndex
                });
            });
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            
            // Guardar referencia con índice único
            instancedMeshes.set(meshKey, instancedMesh);
            scene.add(instancedMesh);
        }
    });
    
    // Log final
    const totalMeshes = instancedMeshes.size;
    let totalInstances = 0;
    instancedMeshes.forEach(mesh => {
        totalInstances += mesh.count;
    });
    
    debugLogger.info('ParticleRenderer', 'Renderizado completado', {
        particulasInput: totalInputParticles,
        particulasRender: totalInstances,
        meshes: totalMeshes,
        reduccion: totalInputParticles > 0 ? `${((1 - totalInstances / totalInputParticles) * 100).toFixed(1)}%` : '0%'
    }, { throttleMs: 1000 });
    
    return instancedMeshes;
}
```

2. Reemplazar las líneas 440-508 en `renderParticles()` con:
```javascript
// 4. Crear instanced meshes para los grupos
const instancedMeshes = this._createInstancedMeshes(groups, cellSize, scene, particles.length);
```

3. Reemplazar el return final con:
```javascript
return instancedMeshes;
```

**Notas:**
- El método necesita `totalInputParticles` para el log final (número de partículas originales)
- Mantener exactamente la misma lógica de creación de meshes
- Mantener el log final con la misma información
- El método limpia `this.particleIndex` y construye el índice

**Testing:**
- Verificar que los instanced meshes se crean correctamente
- Verificar que el índice de partículas se construye correctamente
- Verificar que los meshes se agregan a la escena
- Verificar que el log final aparece correctamente
- Verificar que las partículas se renderizan en las posiciones correctas

---

### Paso 7: Refactorizar renderParticles() para usar los métodos helper

**Descripción:**
Refactorizar el método `renderParticles()` para que actúe como orquestador que llama a los métodos helper en orden.

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**

El método `renderParticles()` debe quedar así:
```javascript
renderParticles(particles, tiposEstilos, agrupacionesGeometria, cellSize, scene, camera = null, playerPosition = null) {
    // Log inicial para debugging
    debugLogger.info('ParticleRenderer', 'Inicio renderParticles', {
        totalParticles: particles ? particles.length : 0,
        hasCamera: !!camera,
        hasPlayerPosition: !!playerPosition,
        enableFrustumCulling: this.enableFrustumCulling,
        enableLOD: this.enableLOD,
        enableParticleLimiting: this.enableParticleLimiting
    });
    
    // 1. Aplicar optimizaciones en cadena
    let particlesToRender = this._applyFrustumCulling(particles, camera, cellSize);
    particlesToRender = this._applyLODOptimization(particlesToRender, playerPosition, camera, cellSize);
    this._applyAdaptiveLimiting();
    particlesToRender = this._applyParticleLimiting(particlesToRender, playerPosition, camera, cellSize);
    
    // 2. Construir grupos de partículas por geometría
    const groups = this._buildParticleGroups(particlesToRender, tiposEstilos, agrupacionesGeometria, cellSize);
    
    // 3. Crear instanced meshes para los grupos
    const instancedMeshes = this._createInstancedMeshes(groups, cellSize, scene, particles.length);
    
    return instancedMeshes;
}
```

**Notas:**
- El método ahora es mucho más corto y fácil de entender
- Cada paso está claramente identificado
- El flujo es fácil de seguir
- Todos los métodos helper se llaman en el orden correcto

**Testing:**
- Verificar que el método funciona igual que antes
- Verificar que el flujo es correcto
- Verificar que todos los métodos helper se llaman

---

### Paso 8: Verificar y Ajustar

**Descripción:**
Verificar que todo funciona correctamente, revisar linting, y hacer ajustes si es necesario.

**Archivos a verificar:**
- `frontend/src/terrain/renderers/particle-renderer.js`

**Detalles de implementación:**

1. Ejecutar linting:
```bash
npm run lint
```

2. Verificar que no hay errores de compilación:
```bash
npm run build
```

3. Probar manualmente que el renderizado funciona:
   - Cargar el juego
   - Verificar que las partículas se renderizan correctamente
   - Verificar que las optimizaciones funcionan
   - Verificar que los logs aparecen correctamente

4. Revisar el código:
   - Verificar que los métodos helper están bien organizados
   - Verificar que los nombres son claros
   - Verificar que los comentarios JSDoc son correctos
   - Verificar que no hay código duplicado

**Notas:**
- Si hay errores de linting, corregirlos
- Si hay problemas funcionales, revisar y ajustar
- Asegurarse de que todos los logs se mantienen
- Verificar que la funcionalidad es idéntica

**Testing:**
- Ejecutar todos los tests existentes (si hay)
- Probar casos edge (sin partículas, sin cámara, etc.)
- Verificar que el rendimiento no ha empeorado (debe ser idéntico o mejor)

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-050_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Notas Adicionales

- **Refactorización incremental:** Se puede hacer paso por paso, probando después de cada paso para facilitar el debugging
- **Sin cambios funcionales:** Este es un refactor puro, no debe cambiar la funcionalidad
- **Logs:** Es importante mantener todos los logs en los lugares correctos
- **Testing:** Es crucial probar que el comportamiento es idéntico al anterior
- **Documentación:** Los métodos helper deben tener comentarios JSDoc claros
- **Organización:** Los métodos helper pueden organizarse después del método `renderParticles()` o agruparse con otros métodos privados según la organización de la clase
