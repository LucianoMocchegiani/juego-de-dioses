# JDG-051 - Animaciones Direccionales de Caminar (Adelante, Atrás, Izquierda, Derecha)

## Descripción de la Tarea

Implementar sistema de animaciones direccionales para caminar, permitiendo que el personaje muestre diferentes animaciones según la dirección del movimiento (adelante, atrás, izquierda, derecha) en lugar de usar siempre la misma animación de caminar hacia adelante.

**Comportamiento actual:**
- Todas las teclas de movimiento (W, A, S, D) activan el mismo estado de animación `walk`
- El estado `walk` siempre reproduce la animación `walk` (caminar hacia adelante)
- No hay diferenciación visual entre caminar hacia adelante, atrás, izquierda o derecha

**Comportamiento esperado:**
- **Caminar hacia adelante (W)**: Debe usar animación `walk_forward` o `walk` (fallback)
- **Caminar hacia atrás (S)**: Debe usar animación `walk_backward` o `walk` (fallback)
- **Caminar hacia la derecha (D)**: Debe usar animación `walk_right` o `walk` (fallback)
- **Caminar hacia la izquierda (A)**: Debe usar animación `walk_left` o `walk` (fallback)
- El sistema debe determinar la dirección basándose en `input.moveDirection` relativo a la rotación del personaje
- Si las animaciones direccionales no están disponibles, el sistema debe usar `walk` como fallback

**Nota importante:** Las animaciones direccionales ya fueron obtenidas desde Meshy (https://www.meshy.ai/) y están ubicadas en `frontend/static/models/biped/male/animations/movement/`. Solo falta implementar la lógica para seleccionarlas según la dirección del movimiento.

## Criterios de Aceptación

1. ❌ El sistema detecta correctamente la dirección del movimiento (adelante, atrás, izquierda, derecha) basándose en `input.moveDirection` y la rotación del personaje
2. ❌ Cuando el jugador presiona W (adelante), se reproduce la animación de caminar hacia adelante
3. ❌ Cuando el jugador presiona S (atrás), se reproduce la animación de caminar hacia atrás (o la más cercana disponible)
4. ❌ Cuando el jugador presiona D (derecha), se reproduce la animación de caminar hacia la derecha (o la más cercana disponible)
5. ❌ Cuando el jugador presiona A (izquierda), se reproduce la animación de caminar hacia la izquierda (o la más cercana disponible)
6. ❌ Si las animaciones direccionales no están disponibles, el sistema usa un fallback apropiado (animación genérica de caminar)
7. ❌ La lógica funciona correctamente con diferentes rotaciones de cámara/personaje
8. ❌ No hay regresiones en otras animaciones existentes

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js AnimationMixer
- ECS (Entity Component System)
- Sistema de estados de animación declarativo

### Archivos/Componentes Principales
- `frontend/src/config/animation-config.js` - Agregar animaciones direccionales a ANIMATION_FILES y modificar lógica de selección
- `frontend/src/ecs/systems/animation-state-system.js` - Pasar información de dirección al sistema de animaciones
- `frontend/src/ecs/systems/animation-mixer-system.js` - Seleccionar animación correcta basándose en dirección
- `frontend/src/ecs/conditions/movement-condition.js` - Extender para detectar dirección (opcional)

## Pasos de Implementación

### Paso 1: Verificar Animaciones Disponibles y Agregarlas a ANIMATION_FILES

**Descripción:**
Verificar qué animaciones direccionales están disponibles en `frontend/static/models/biped/male/animations/movement/` y agregarlas a `ANIMATION_FILES` en `animation-config.js`.

**Archivos a modificar:**
- `frontend/src/config/animation-config.js`

**Detalles de implementación:**

1. **Verificar archivos disponibles:**
   - Revisar la carpeta `frontend/static/models/biped/male/animations/movement/`
   - Identificar los nombres exactos de las animaciones direccionales (ej: `Walk_Forward_withSkin.glb`, `Walk_Backward_withSkin.glb`, etc.)

2. **Agregar a ANIMATION_FILES:**
   ```javascript
   export const ANIMATION_FILES = {
       // ... animaciones existentes ...
       
       // Movimiento direccional - movement/
       'walk': 'biped/male/animations/movement/Walking_withSkin.glb', // Mantener como fallback
       'walk_forward': 'biped/male/animations/movement/Walk_Forward_withSkin.glb', // O el nombre exacto
       'walk_backward': 'biped/male/animations/movement/Walk_Backward_withSkin.glb', // O el nombre exacto
       'walk_left': 'biped/male/animations/movement/Walk_Left_withSkin.glb', // O el nombre exacto
       'walk_right': 'biped/male/animations/movement/Walk_Right_withSkin.glb', // O el nombre exacto
       
       // ... resto de animaciones ...
   };
   ```

**Notas:**
- Usar los nombres exactos de los archivos GLB encontrados en la carpeta
- Si alguna animación no existe, no agregarla (el sistema usará fallback)
- Mantener `walk` como fallback para compatibilidad

**Recursos útiles:**
- Verificar estructura de archivos en `frontend/static/models/biped/male/animations/movement/`
- Revisar `ANIMATION_FILES` existente para ver el formato de rutas

---

### Paso 2: Crear Función Helper para Determinar Dirección de Movimiento

**Descripción:**
Crear una función helper que calcule la dirección del movimiento relativa al personaje basándose en `input.moveDirection` y `render.rotationY`.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js` (agregar método helper)
- O crear nuevo archivo: `frontend/src/ecs/utils/movement-direction-utils.js` (opcional)

**Detalles de implementación:**

```javascript
// En animation-mixer-system.js o en un archivo de utilidades

/**
 * Determinar dirección de movimiento relativa al personaje
 * @param {Object} input - InputComponent con moveDirection
 * @param {Object} render - RenderComponent con rotationY
 * @returns {string} Dirección: 'forward', 'backward', 'left', 'right', o 'forward' como fallback
 */
getMovementDirection(input, render) {
    if (!input || !input.moveDirection) {
        return 'forward'; // Fallback
    }
    
    // Obtener rotación del personaje (en radianes)
    const characterRotation = render && render.rotationY !== undefined ? render.rotationY : 0;
    
    // Obtener dirección de movimiento en espacio del mundo
    const worldDirX = input.moveDirection.x;
    const worldDirY = input.moveDirection.y;
    
    // Si no hay movimiento, retornar forward como fallback
    if (worldDirX === 0 && worldDirY === 0) {
        return 'forward';
    }
    
    // Convertir dirección del mundo a dirección relativa al personaje
    // Rotar el vector de movimiento por el negativo de la rotación del personaje
    // para obtener la dirección en espacio local del personaje
    const cos = Math.cos(-characterRotation);
    const sin = Math.sin(-characterRotation);
    
    // Rotar vector (worldDirX, worldDirY) al espacio local del personaje
    const localDirX = worldDirX * cos - worldDirY * sin;
    const localDirY = worldDirX * sin + worldDirY * cos;
    
    // Determinar dirección dominante
    // En espacio local: X positivo = derecha, X negativo = izquierda
    //                   Y positivo = atrás, Y negativo = adelante
    const absX = Math.abs(localDirX);
    const absY = Math.abs(localDirY);
    
    // Si el movimiento es principalmente en Y (adelante/atrás)
    if (absY > absX) {
        return localDirY < 0 ? 'forward' : 'backward';
    }
    // Si el movimiento es principalmente en X (izquierda/derecha)
    else if (absX > absY) {
        return localDirX > 0 ? 'right' : 'left';
    }
    // Movimiento diagonal: usar la dirección más dominante
    else {
        // Si es diagonal, priorizar adelante/atrás sobre izquierda/derecha
        if (absY > 0) {
            return localDirY < 0 ? 'forward' : 'backward';
        } else {
            return localDirX > 0 ? 'right' : 'left';
        }
    }
}
```

**Notas:**
- La función convierte `input.moveDirection` (en espacio del mundo) a espacio local del personaje
- Usa `render.rotationY` para obtener la rotación del personaje
- Retorna 'forward', 'backward', 'left', o 'right'
- Maneja casos edge como movimiento diagonal (prioriza adelante/atrás)

---

### Paso 3: Modificar AnimationMixerSystem para Seleccionar Animación Basada en Dirección

**Descripción:**
Modificar `AnimationMixerSystem` para que cuando se active el estado `walk`, seleccione la animación correcta basándose en la dirección del movimiento calculada.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**

1. **Modificar método `getAnimationNameForState` o crear método nuevo:**

```javascript
/**
 * Obtener nombre de animación para un estado, considerando dirección si aplica
 * @param {string} stateId - ID del estado
 * @param {Object} context - Contexto con input, render, etc. (opcional)
 * @returns {string|null} Nombre de la animación o null
 */
getAnimationNameForState(stateId, context = null) {
    // ... código existente para combos y combate ...
    
    // Si es estado 'walk', determinar dirección y seleccionar animación
    if (stateId === 'walk' && context) {
        const { input, render } = context;
        const direction = this.getMovementDirection(input, render);
        
        // Mapear dirección a nombre de animación
        const directionMap = {
            'forward': 'walk_forward',
            'backward': 'walk_backward',
            'left': 'walk_left',
            'right': 'walk_right'
        };
        
        const directionalAnimation = directionMap[direction];
        
        // Verificar si la animación direccional existe en ANIMATION_FILES
        if (directionalAnimation && ANIMATION_FILES[directionalAnimation]) {
            return directionalAnimation;
        }
        
        // Fallback: usar 'walk' genérico
        return 'walk';
    }
    
    // Para otros estados, usar lógica existente
    // ... resto del código existente ...
}
```

2. **Modificar `playAnimation` para pasar contexto:**

```javascript
playAnimation(mixer, clips, state, mesh) {
    // ... código existente ...
    
    // Obtener nombre de animación, pasando contexto si es necesario
    let animationName = null;
    
    if (stateId === 'walk') {
        // Obtener componentes para calcular dirección
        const entityId = mesh.userData.entityId;
        const input = entityId ? this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.INPUT) : null;
        const render = entityId ? this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.RENDER) : null;
        
        const context = { input, render };
        animationName = this.getAnimationNameForState(state, context);
    } else {
        animationName = this.getAnimationNameForState(state);
    }
    
    // ... resto del código existente ...
}
```

**Notas:**
- Solo aplicar lógica direccional para el estado 'walk'
- Usar fallback a 'walk' si la animación direccional no existe
- No afectar otros estados de animación

---

### Paso 4: Actualizar AnimationStateSystem para Pasar Contexto (Opcional)

**Descripción:**
Si es necesario, modificar `AnimationStateSystem` o `AnimationMixerSystem` para pasar el contexto completo (input, render) cuando se determina la animación para el estado 'walk'.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**

En `AnimationMixerSystem.update()`, cuando se llama a `playAnimation()`, asegurarse de que el contexto esté disponible:

```javascript
update(deltaTime) {
    // ... código existente ...
    
    for (const entityId of entities) {
        // ... código existente ...
        
        // Cuando se reproduce animación, el contexto ya está disponible
        // porque playAnimation puede acceder a los componentes a través de entityId
        // No se requiere modificación adicional si se implementó el Paso 3 correctamente
    }
}
```

**Notas:**
- Si `playAnimation` ya puede acceder a los componentes a través de `mesh.userData.entityId`, no se requiere modificación adicional
- El contexto se obtiene dinámicamente cuando se necesita

---

### Paso 5: Probar y Ajustar Lógica de Dirección

**Descripción:**
Probar la implementación y ajustar la lógica de cálculo de dirección si es necesario, especialmente para casos de movimiento diagonal y diferentes rotaciones de cámara.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js` (ajustes según testing)

**Detalles de implementación:**

1. **Probar escenarios:**
   - Caminar hacia adelante (W) - debe usar `walk_forward`
   - Caminar hacia atrás (S) - debe usar `walk_backward`
   - Caminar hacia la derecha (D) - debe usar `walk_right`
   - Caminar hacia la izquierda (A) - debe usar `walk_left`
   - Movimiento diagonal (W+D, W+A, S+D, S+A) - debe usar la dirección más dominante
   - Rotar cámara y verificar que las direcciones se mantienen correctas

2. **Ajustar umbrales si es necesario:**
   ```javascript
   // Si el movimiento diagonal necesita mejor manejo:
   const threshold = 0.3; // Umbral para considerar movimiento "principalmente" en una dirección
   if (absY > absX + threshold) {
       return localDirY < 0 ? 'forward' : 'backward';
   } else if (absX > absY + threshold) {
       return localDirX > 0 ? 'right' : 'left';
   }
   ```

**Notas:**
- Ajustar según resultados de testing
- Considerar agregar logging temporal para debugging si es necesario
- Verificar que no hay regresiones en otras animaciones

---

### Paso 6: Agregar Fallback Robusto

**Descripción:**
Asegurar que el sistema funcione correctamente incluso si algunas animaciones direccionales no están disponibles, usando `walk` como fallback.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**

```javascript
getAnimationNameForState(stateId, context = null) {
    // ... código existente ...
    
    if (stateId === 'walk' && context) {
        const { input, render } = context;
        const direction = this.getMovementDirection(input, render);
        
        const directionMap = {
            'forward': 'walk_forward',
            'backward': 'walk_backward',
            'left': 'walk_left',
            'right': 'walk_right'
        };
        
        const directionalAnimation = directionMap[direction];
        
        // Verificar si la animación existe en clips (ya cargada)
        // O verificar si existe en ANIMATION_FILES (para cargar)
        if (directionalAnimation) {
            // Verificar en clips primero (más rápido)
            if (clips && clips[directionalAnimation]) {
                return directionalAnimation;
            }
            // Verificar en ANIMATION_FILES
            if (ANIMATION_FILES[directionalAnimation]) {
                return directionalAnimation;
            }
        }
        
        // Fallback: usar 'walk' genérico
        return 'walk';
    }
    
    // ... resto del código ...
}
```

**Notas:**
- Siempre tener `walk` como fallback garantizado
- Verificar tanto en `clips` (animaciones ya cargadas) como en `ANIMATION_FILES` (para cargar)
- El sistema debe funcionar incluso si solo algunas animaciones direccionales están disponibles

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-051_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- El cálculo de dirección se hace solo cuando el estado es 'walk', impacto mínimo
- La conversión de coordenadas (mundo → local) es O(1), muy eficiente
- No se requiere cacheo adicional ya que se calcula cada frame solo cuando es necesario

### Seguridad
- Validar que `input` y `render` existen antes de acceder a sus propiedades
- Manejar casos donde `moveDirection` o `rotationY` no están disponibles
- Siempre tener fallback a 'walk' para garantizar que el sistema funcione

### Casos Edge
- **Movimiento diagonal**: Priorizar adelante/atrás sobre izquierda/derecha, o usar umbral para determinar dirección dominante
- **Sin rotación**: Si `rotationY` no está disponible, asumir rotación 0 (personaje mirando hacia adelante)
- **Sin movimiento**: Si `moveDirection` es (0,0), retornar 'forward' como fallback
- **Animaciones faltantes**: Si alguna animación direccional no existe, usar 'walk' como fallback
- **Rotación de cámara**: El sistema debe funcionar correctamente independientemente de la rotación de la cámara

### Compatibilidad
- No rompe código existente
- Solo afecta el estado 'walk', otros estados no se ven afectados
- Mantiene compatibilidad con animaciones existentes
- El fallback garantiza que el sistema funcione incluso si las animaciones direccionales no están disponibles

## Patrones de Código a Usar

- **Helper Functions**: Crear función helper para cálculo de dirección (separación de responsabilidades)
- **Guard Clauses**: Verificar condiciones temprano antes de procesar (input, render, moveDirection)
- **Fallback Pattern**: Siempre tener fallback a 'walk' para garantizar funcionalidad
- **Configuration Pattern**: Usar `ANIMATION_FILES` para mapear nombres de animaciones a rutas

## Dependencias

### Nuevas Dependencias
Ninguna - usa código existente

### Variables de Entorno
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/config/animation-config.js` - Agregar animaciones direccionales a `ANIMATION_FILES`
2. `frontend/src/ecs/systems/animation-mixer-system.js` - Implementar lógica de selección de animación basada en dirección
3. `frontend/src/ecs/utils/movement-direction-utils.js` (opcional) - Función helper para calcular dirección

## Testing

### Escenarios de Prueba

1. **Caminar hacia adelante (W)**: Presionar W y verificar que se reproduce `walk_forward` (o `walk` si no existe)
2. **Caminar hacia atrás (S)**: Presionar S y verificar que se reproduce `walk_backward` (o `walk` si no existe)
3. **Caminar hacia la derecha (D)**: Presionar D y verificar que se reproduce `walk_right` (o `walk` si no existe)
4. **Caminar hacia la izquierda (A)**: Presionar A y verificar que se reproduce `walk_left` (o `walk` si no existe)
5. **Movimiento diagonal (W+D)**: Presionar W+D y verificar que se usa la animación más apropiada
6. **Rotación de cámara**: Rotar la cámara y verificar que las direcciones se mantienen correctas relativas al personaje
7. **Fallback**: Si las animaciones direccionales no existen, verificar que se usa `walk` como fallback
8. **Regresiones**: Verificar que otras animaciones (run, jump, attack, etc.) no se ven afectadas

### Casos Edge a Considerar

- **Movimiento diagonal**: ¿Qué animación usar cuando se mueve en diagonal? (W+D, W+A, S+D, S+A)
- **Cambio rápido de dirección**: Las transiciones deben ser suaves al cambiar rápidamente entre direcciones
- **Animaciones faltantes**: Si no existen todas las animaciones direccionales, el sistema debe funcionar con las disponibles
- **Rotación de cámara extrema**: Verificar que funciona correctamente con diferentes ángulos de cámara

## Referencias

- Ticket: `instructions/tickets/JDG-051_work-ticket_2026-01-14_16-56-15.md`
- Relacionado con: JDG-052 (animaciones direccionales de agacharse), JDG-053 (animaciones direccionales de nadar)
- Documentación relevante: 
  - `frontend/src/config/animation-config.js`
  - `frontend/src/ecs/systems/animation-state-system.js`
  - `frontend/src/ecs/systems/animation-mixer-system.js`
- Animaciones obtenidas desde: https://www.meshy.ai/
- Ubicación de animaciones: `frontend/static/models/biped/male/animations/movement/`
