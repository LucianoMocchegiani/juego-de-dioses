# JDG-052 - Animaciones Direccionales de Agacharse y Caminar Agachado

## Descripción de la Tarea

Implementar sistema de animaciones direccionales para agacharse y caminar agachado, permitiendo que el personaje muestre diferentes animaciones según la dirección del movimiento (adelante, atrás, izquierda, derecha) cuando está agachado. También corregir el estado `crouch_idle` para que use una animación apropiada de agacharse en lugar de la animación de caminar agachado.

**Comportamiento actual:**
- Estado `crouch_idle` (Ctrl sin movimiento) usa animación `crouch_walk_forward` (incorrecto)
- Estado `crouch_walk` (Ctrl + movimiento) siempre usa animación `crouch_walk_forward` sin importar la dirección
- No hay diferenciación visual entre caminar agachado hacia adelante, atrás, izquierda o derecha

**Comportamiento esperado:**
- **Agacharse sin movimiento (Ctrl sin WASD)**: Debe usar animación `crouch_idle` (solo agacharse, no caminar agachado)
- **Caminar agachado hacia adelante (Ctrl + W)**: Debe usar animación `crouch_walk_forward`
- **Caminar agachado hacia atrás (Ctrl + S)**: Debe usar animación `crouch_walk_backward`
- **Caminar agachado hacia la derecha (Ctrl + D)**: Debe usar animación `crouch_walk_right`
- **Caminar agachado hacia la izquierda (Ctrl + A)**: Debe usar animación `crouch_walk_left`
- El sistema debe verificar directamente las teclas presionadas (similar a JDG-051) para seleccionar la animación correspondiente
- Si las animaciones direccionales no están disponibles, el sistema debe usar un fallback apropiado

**Nota importante:** Las animaciones direccionales ya fueron obtenidas desde Meshy y están ubicadas en `backend/static/models/biped/male/animations/movement/`. Ya fueron agregadas a `ANIMATION_FILES`:
- `crouch_walk_forward` (ya existía)
- `crouch_walk_right` (ya existía)
- `crouch_walk_backward` (nueva, agregada)
- `crouch_walk_left` (nueva, agregada)
- `crouch_idle` (nueva, agregada - `CrouchLookAroundBow_withSkin.glb`)

## Criterios de Aceptación

1. ❌ Cuando el jugador presiona Ctrl sin movimiento, se reproduce la animación `crouch_idle` (solo agacharse, NO caminar agachado)
2. ❌ Cuando el jugador presiona Ctrl + W (adelante), se reproduce `crouch_walk_forward`
3. ❌ Cuando el jugador presiona Ctrl + S (atrás), se reproduce `crouch_walk_backward`
4. ❌ Cuando el jugador presiona Ctrl + D (derecha), se reproduce `crouch_walk_right`
5. ❌ Cuando el jugador presiona Ctrl + A (izquierda), se reproduce `crouch_walk_left`
6. ❌ El sistema verifica directamente las teclas presionadas (KeyW, KeyS, KeyA, KeyD) similar a JDG-051
7. ❌ Solo se usa una dirección a la vez (prioridad: W > S > A > D), sin combinar teclas para movimiento diagonal
8. ❌ Si las animaciones direccionales no están disponibles, el sistema usa un fallback apropiado
9. ❌ No hay regresiones en otras animaciones existentes

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js AnimationMixer
- ECS (Entity Component System)
- Sistema de estados de animación declarativo

### Archivos/Componentes Principales
- `frontend/src/config/animation-config.js` - Ya contiene las animaciones direccionales en `ANIMATION_FILES` (completado)
- `frontend/src/config/animation-config.js` - Modificar estado `crouch_idle` para usar animación `crouch_idle` en lugar de `crouch_walk_forward`
- `frontend/src/ecs/systems/animation-mixer-system.js` - Implementar lógica de selección de animación direccional para `crouch_walk` (similar a `walk`)
- `frontend/src/ecs/systems/animation-mixer-system.js` - Agregar soporte para detectar cambios en animaciones direccionales de `crouch_walk` (similar a `walk`)

## Pasos de Implementación

### Paso 1: Actualizar Estado crouch_idle en animation-config.js

**Descripción:**
Modificar el estado `crouch_idle` en `ANIMATION_STATES` para que use la animación `crouch_idle` en lugar de `crouch_walk_forward`.

**Archivos a modificar:**
- `frontend/src/config/animation-config.js`

**Detalles de implementación:**

1. **Localizar el estado `crouch_idle` en `ANIMATION_STATES`:**
   ```javascript
   {
       id: 'crouch_idle',
       type: 'idle',
       priority: 6,
       conditions: [
           { type: 'input', property: 'wantsToCrouch', operator: 'equals', value: true },
           { type: 'movement', operator: 'noMovement' }
       ],
       animation: 'crouch_walk_forward', // ❌ Cambiar esto
       transitions: ['crouch_walk', 'idle', 'swim', 'swim_idle']
   }
   ```

2. **Cambiar la animación a `crouch_idle`:**
   ```javascript
   {
       id: 'crouch_idle',
       type: 'idle',
       priority: 6,
       conditions: [
           { type: 'input', property: 'wantsToCrouch', operator: 'equals', value: true },
           { type: 'movement', operator: 'noMovement' }
       ],
       animation: 'crouch_idle', // ✅ Usar animación de idle agachado
       transitions: ['crouch_walk', 'idle', 'swim', 'swim_idle']
   }
   ```

**Notas:**
- La animación `crouch_idle` ya está definida en `ANIMATION_FILES` como `'biped/male/animations/movement/CrouchLookAroundBow_withSkin.glb'`
- Esto corrige el problema donde `crouch_idle` usaba incorrectamente `crouch_walk_forward`

---

### Paso 2: Modificar getAnimationNameForState para Soporte de crouch_walk Direccional

**Descripción:**
Extender `getAnimationNameForState()` en `AnimationMixerSystem` para que cuando el estado sea `crouch_walk`, verifique directamente las teclas presionadas (KeyW, KeyS, KeyA, KeyD) y retorne la animación direccional correspondiente, similar a como se implementó para `walk` en JDG-051.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**

1. **Modificar método `getAnimationNameForState()`:**

```javascript
getAnimationNameForState(stateId, input = null) {
    // Si es estado 'walk' y tenemos input, determinar dirección directamente desde teclas
    if (stateId === 'walk' && input) {
        // Verificar teclas directamente (más simple y confiable)
        // IMPORTANTE: Solo una dirección a la vez - verificar en orden de prioridad
        const isW = input.isKeyPressed('KeyW');
        const isS = input.isKeyPressed('KeyS');
        const isA = input.isKeyPressed('KeyA');
        const isD = input.isKeyPressed('KeyD');

        // Prioridad: W (adelante) > S (atrás) > A (izquierda) > D (derecha)
        // Solo usar la primera tecla que encuentre presionada (una a la vez)
        if (isW) {
            return 'walk_forward';
        } else if (isS) {
            return 'walk_backward';
        } else if (isA) {
            return 'walk_left';
        } else if (isD) {
            return 'walk_right';
        }
        // Si no hay ninguna tecla presionada, usar fallback
    }
    
    // ✅ AGREGAR: Si es estado 'crouch_walk' y tenemos input, determinar dirección directamente desde teclas
    if (stateId === 'crouch_walk' && input) {
        // Verificar teclas directamente (más simple y confiable)
        // IMPORTANTE: Solo una dirección a la vez - verificar en orden de prioridad
        const isW = input.isKeyPressed('KeyW');
        const isS = input.isKeyPressed('KeyS');
        const isA = input.isKeyPressed('KeyA');
        const isD = input.isKeyPressed('KeyD');

        // Prioridad: W (adelante) > S (atrás) > A (izquierda) > D (derecha)
        // Solo usar la primera tecla que encuentre presionada (una a la vez)
        if (isW) {
            return 'crouch_walk_forward';
        } else if (isS) {
            return 'crouch_walk_backward';
        } else if (isA) {
            return 'crouch_walk_left';
        } else if (isD) {
            return 'crouch_walk_right';
        }
        // Si no hay ninguna tecla presionada, usar fallback
    }

    // Buscar en el mapa de configuración
    const stateConfig = this.stateConfigMap.get(stateId);
    // ... resto del código existente ...
}
```

**Notas:**
- Reutilizar la misma lógica simple de JDG-051: verificar directamente las teclas presionadas
- Prioridad: W > S > A > D (solo una dirección a la vez)
- Si no hay ninguna tecla presionada, el sistema usará el fallback del estado config (probablemente `crouch_walk_forward`)

---

### Paso 3: Modificar resolveAnimationName para Pasar Input en crouch_walk

**Descripción:**
Modificar `resolveAnimationName()` para que cuando el estado sea `crouch_walk`, pase el `InputComponent` a `getAnimationNameForState()`, similar a como se hace para `walk`.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**

1. **Localizar método `resolveAnimationName()` y modificar:**

```javascript
resolveAnimationName(entityId, stateId) {
    // ... código existente para combos y combate ...
    
    // Obtener InputComponent si el estado requiere dirección
    let input = null;
    if (stateId === 'walk' || stateId === 'crouch_walk') { // ✅ AGREGAR 'crouch_walk'
        input = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.INPUT);
    }
    
    // Resolver nombre de animación
    const animationName = this.getAnimationNameForState(stateId, input);
    // ... resto del código existente ...
}
```

**Notas:**
- Similar a como se implementó para `walk` en JDG-051
- Solo obtener `InputComponent` cuando el estado es `walk` o `crouch_walk`

---

### Paso 4: Modificar playAnimation para Detectar Cambios en Animaciones Direccionales de crouch_walk

**Descripción:**
Modificar `playAnimation()` para que detecte cambios en animaciones direccionales cuando el estado es `crouch_walk`, similar a como se implementó para `walk` en JDG-051. Esto permite que las animaciones direccionales cambien suavemente incluso si el estado sigue siendo `crouch_walk`.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**

1. **Localizar método `playAnimation()` y modificar la lógica de detección de cambios:**

```javascript
playAnimation(mixer, clips, animationName, mesh) {
    // ... código existente ...
    
    const currentState = mesh.userData.currentAnimationState;
    const currentAnimationName = mesh.userData.currentAnimationName;
    
    // Determinar si el estado cambió
    const stateChanged = currentState !== state;
    
    // ✅ MODIFICAR: Detectar cambios en animaciones direccionales
    // (porque el estado puede ser 'walk' o 'crouch_walk' pero la animación puede ser walk_forward, walk_left, crouch_walk_backward, etc.)
    const animationChanged = ((state === 'walk' && currentState === 'walk') || 
                             (state === 'crouch_walk' && currentState === 'crouch_walk')) ? 
        (currentAnimationName !== animationName) : false;

    // Si ya está reproduciendo esta misma animación Y el estado no cambió Y la animación direccional no cambió, no hacer nada
    if (currentAction && !stateChanged && !animationChanged && currentAction.isRunning()) {
        return;
    }
    
    // ... resto del código existente ...
}
```

**Notas:**
- Extender la lógica existente de `animationChanged` para incluir `crouch_walk`
- Esto permite que las animaciones direccionales de `crouch_walk` cambien suavemente cuando el usuario cambia de dirección mientras está agachado

---

### Paso 5: Verificar que currentAnimationName se Actualiza Correctamente

**Descripción:**
Asegurar que `mesh.userData.currentAnimationName` se actualiza correctamente cuando se reproduce una animación de `crouch_walk`, similar a como se hace para `walk`.

**Archivos a modificar:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**

1. **Verificar que `currentAnimationName` se guarda en `playAnimation()`:**

```javascript
playAnimation(mixer, clips, animationName, mesh) {
    // ... código existente ...
    
    // Guardar referencia a la acción y estado actual
    mesh.userData.currentAction = action;
    mesh.userData.currentAnimationState = state;
    mesh.userData.currentAnimationName = animationName; // ✅ Ya debería estar aquí, verificar que funciona para crouch_walk
}
```

2. **Verificar que se inicializa en `initializeMixer()`:**

```javascript
async initializeMixer(entityId, mesh) {
    // ... código existente ...
    
    // Inicializar userData para tracking de animaciones
    animatedModel.userData.currentAnimationState = null;
    animatedModel.userData.currentAnimationName = null; // ✅ Ya debería estar aquí
    // ... resto del código ...
}
```

**Notas:**
- El código ya debería tener esta lógica implementada para `walk`
- Solo verificar que funciona correctamente para `crouch_walk` también

---

### Paso 6: Probar y Verificar Funcionamiento

**Descripción:**
Probar la implementación completa y verificar que todas las animaciones direccionales de agacharse funcionan correctamente.

**Archivos a modificar:**
- Ninguno (solo testing)

**Detalles de implementación:**

1. **Probar escenarios:**
   - **Ctrl sin movimiento**: Presionar Ctrl sin WASD y verificar que se reproduce `crouch_idle` (no `crouch_walk_forward`)
   - **Ctrl + W (adelante)**: Presionar Ctrl + W y verificar que se reproduce `crouch_walk_forward`
   - **Ctrl + S (atrás)**: Presionar Ctrl + S y verificar que se reproduce `crouch_walk_backward`
   - **Ctrl + D (derecha)**: Presionar Ctrl + D y verificar que se reproduce `crouch_walk_right`
   - **Ctrl + A (izquierda)**: Presionar Ctrl + A y verificar que se reproduce `crouch_walk_left`
   - **Movimiento diagonal (Ctrl + W+D)**: Presionar Ctrl + W+D y verificar que solo se usa W (prioridad)
   - **Cambio rápido de dirección**: Cambiar rápidamente entre direcciones mientras está agachado y verificar transiciones suaves
   - **Regresiones**: Verificar que otras animaciones (walk, run, jump, attack, etc.) no se ven afectadas

2. **Verificar en F6:**
   - Abrir interfaz F6 y verificar que las animaciones direccionales de agacharse aparecen en la lista
   - Probar cada animación manualmente desde F6 para verificar que se cargan correctamente

**Notas:**
- Usar la interfaz F6 para probar las animaciones individualmente
- Verificar que no hay errores 404 en la consola del navegador
- Verificar que las transiciones entre estados son suaves

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-052_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- El cálculo de dirección se hace solo cuando el estado es `crouch_walk`, impacto mínimo
- La verificación de teclas es O(1), muy eficiente
- No se requiere cacheo adicional ya que se calcula cada frame solo cuando es necesario

### Seguridad
- Validar que `input` existe antes de acceder a `isKeyPressed()`
- Manejar casos donde `input` no está disponible
- Siempre tener fallback a `crouch_walk_forward` para garantizar que el sistema funcione

### Casos Edge
- **Sin input**: Si `InputComponent` no está disponible, usar fallback del estado config
- **Sin teclas presionadas**: Si no hay ninguna tecla presionada, usar fallback del estado config
- **Movimiento diagonal**: Solo usar la primera tecla según prioridad (W > S > A > D)
- **Animaciones faltantes**: Si alguna animación direccional no existe, usar `crouch_walk_forward` como fallback
- **Transiciones**: Las transiciones entre `crouch_idle` y `crouch_walk` deben ser suaves

### Compatibilidad
- No rompe código existente
- Solo afecta los estados `crouch_idle` y `crouch_walk`, otros estados no se ven afectados
- Mantiene compatibilidad con animaciones existentes
- El fallback garantiza que el sistema funcione incluso si las animaciones direccionales no están disponibles
- Reutiliza la misma estrategia simple de JDG-051 (verificar teclas directamente)

## Patrones de Código a Usar

- **Reutilización de Lógica**: Reutilizar la misma estrategia simple de JDG-051 (verificar teclas directamente) en lugar de cálculos complejos
- **Guard Clauses**: Verificar condiciones temprano antes de procesar (input, teclas presionadas)
- **Fallback Pattern**: Siempre tener fallback a `crouch_walk_forward` para garantizar funcionalidad
- **Configuration Pattern**: Usar `ANIMATION_FILES` para mapear nombres de animaciones a rutas

## Dependencias

### Nuevas Dependencias
Ninguna - usa código existente

### Variables de Entorno
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/config/animation-config.js` - Modificar estado `crouch_idle` para usar animación `crouch_idle` (ya contiene animaciones direccionales en `ANIMATION_FILES`)
2. `frontend/src/ecs/systems/animation-mixer-system.js` - Implementar lógica de selección de animación direccional para `crouch_walk` (similar a `walk`)

## Testing

### Escenarios de Prueba

1. **Agacharse sin movimiento (Ctrl sin WASD)**: Presionar Ctrl sin WASD y verificar que se reproduce `crouch_idle` (no `crouch_walk_forward`)
2. **Caminar agachado hacia adelante (Ctrl + W)**: Presionar Ctrl + W y verificar que se reproduce `crouch_walk_forward`
3. **Caminar agachado hacia atrás (Ctrl + S)**: Presionar Ctrl + S y verificar que se reproduce `crouch_walk_backward`
4. **Caminar agachado hacia la derecha (Ctrl + D)**: Presionar Ctrl + D y verificar que se reproduce `crouch_walk_right`
5. **Caminar agachado hacia la izquierda (Ctrl + A)**: Presionar Ctrl + A y verificar que se reproduce `crouch_walk_left`
6. **Movimiento diagonal (Ctrl + W+D)**: Presionar Ctrl + W+D y verificar que solo se usa W (prioridad)
7. **Cambio rápido de dirección**: Cambiar rápidamente entre direcciones mientras está agachado y verificar transiciones suaves
8. **Regresiones**: Verificar que otras animaciones (walk, run, jump, attack, etc.) no se ven afectadas
9. **Fallback**: Si las animaciones direccionales no existen, verificar que se usa `crouch_walk_forward` como fallback

### Casos Edge a Considerar

- **Movimiento diagonal agachado**: Solo usar la primera tecla según prioridad (W > S > A > D)
- **Cambio rápido de dirección agachado**: Las transiciones deben ser suaves al cambiar rápidamente entre direcciones mientras está agachado
- **Animaciones faltantes**: Si no existen todas las animaciones direccionales de agacharse, el sistema debe funcionar con las disponibles
- **Sin input**: Si `InputComponent` no está disponible, usar fallback del estado config

## Referencias

- Ticket: `instructions/tickets/JDG-052_work-ticket_2026-01-14_16-56-15.md`
- Relacionado con: JDG-051 (animaciones direccionales de caminar) - reutiliza la misma estrategia simple
- PR de referencia: `instructions/prs/JDG-051_pr-description_2026-01-17_15-42-09.md`
- Documentación relevante: 
  - `frontend/src/config/animation-config.js`
  - `frontend/src/ecs/systems/animation-state-system.js`
  - `frontend/src/ecs/systems/animation-mixer-system.js`
- Animaciones obtenidas desde: Meshy (https://www.meshy.ai/)
- Ubicación de animaciones: `backend/static/models/biped/male/animations/movement/`
- Animaciones agregadas a `ANIMATION_FILES`:
  - `crouch_walk_backward`: `Cautious_Crouch_Walk_Backward_inplace_withSkin.glb` (nueva)
  - `crouch_walk_left`: `Cautious_Crouch_Walk_Left_inplace_withSkin.glb` (nueva)
  - `crouch_idle`: `CrouchLookAroundBow_withSkin.glb` (nueva)
