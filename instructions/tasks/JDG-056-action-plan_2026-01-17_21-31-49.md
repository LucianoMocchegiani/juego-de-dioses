# JDG-056 - Animaciones Direccionales de Nadar

## Descripción de la Tarea

Implementar sistema de animaciones direccionales para nadar, permitiendo que el personaje muestre diferentes animaciones según la tecla presionada (W, A, S, D) cuando está nadando. El sistema verifica directamente las teclas presionadas para seleccionar la animación correspondiente, similar a JDG-051 (caminar) y JDG-052 (agacharse).

**Comportamiento actual:**
- Todas las direcciones de natación (WASD) utilizan la misma animación `swim_forward`
- El estado `swim` siempre reproduce `swim_forward` sin importar la dirección del movimiento
- No hay diferenciación visual entre nadar hacia adelante, atrás, izquierda o derecha

**Comportamiento esperado:**
- **Nadar hacia adelante (W)**: Debe usar animación `swim_forward`
- **Nadar hacia atrás (S)**: Debe usar animación `swim_idle` (fallback, no existe animación específica)
- **Nadar hacia la derecha (D)**: Debe usar animación `swim_idle` (fallback, no existe animación específica)
- **Nadar hacia la izquierda (A)**: Debe usar animación `swim_idle` (fallback, no existe animación específica)
- El sistema verifica directamente las teclas presionadas (KeyW, KeyS, KeyA, KeyD) similar a JDG-051 y JDG-052
- Solo se usa una dirección a la vez (prioridad: W > S > A > D), sin combinar teclas para movimiento diagonal

## Criterios de Aceptación

1. ✅/❌ Cuando el jugador presiona W mientras nada, se reproduce animación `swim_forward`
2. ✅/❌ Cuando el jugador presiona S mientras nada, se reproduce animación `swim_idle` (fallback)
3. ✅/❌ Cuando el jugador presiona D mientras nada, se reproduce animación `swim_idle` (fallback)
4. ✅/❌ Cuando el jugador presiona A mientras nada, se reproduce animación `swim_idle` (fallback)
5. ✅/❌ El sistema verifica directamente las teclas presionadas (KeyW, KeyS, KeyA, KeyD) similar a JDG-051 y JDG-052
6. ✅/❌ Solo se usa una dirección a la vez (prioridad: W > S > A > D), sin combinar teclas para movimiento diagonal
7. ✅/❌ Las animaciones direccionales aparecen en la interfaz F6 para testing
8. ✅/❌ No hay regresiones en otras animaciones existentes

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: JavaScript ES6+, Three.js AnimationMixer
- ECS (Entity Component System)
- Sistema de estados de animación declarativo

## Pasos de Implementación

### Paso 1: Extender getAnimationNameForState() para Estado 'swim'

**Descripción:**
Extender el método `getAnimationNameForState()` en `animation-mixer-system.js` para soportar animaciones direccionales del estado `swim`, similar a como se implementó para `walk` y `crouch_walk` en JDG-051 y JDG-052.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// En getAnimationNameForState(), agregar lógica similar a 'walk' y 'crouch_walk'
// Si es estado 'swim' y tenemos input, determinar dirección directamente desde teclas
if (stateId === 'swim' && input) {
    // Verificar teclas directamente (más simple y confiable)
    // IMPORTANTE: Solo una dirección a la vez - verificar en orden de prioridad
    const isW = input.isKeyPressed('KeyW');
    const isS = input.isKeyPressed('KeyS');
    const isA = input.isKeyPressed('KeyA');
    const isD = input.isKeyPressed('KeyD');

    // Prioridad: W (adelante) > S (atrás) > A (izquierda) > D (derecha)
    // Solo usar la primera tecla que encuentre presionada (una a la vez)
    if (isW) {
        return 'swim_forward';
    } else if (isS) {
        return 'swim_idle'; // Fallback: no existe swim_backward
    } else if (isA) {
        return 'swim_idle'; // Fallback: no existe swim_left
    } else if (isD) {
        return 'swim_idle'; // Fallback: no existe swim_right
    }
    // Si no hay ninguna tecla presionada, usar fallback
}
```

**Notas:**
- Reutilizar la misma estrategia simple de JDG-051 y JDG-052: verificar teclas directamente (KeyW, KeyS, KeyA, KeyD)
- Prioridad de selección: W > S > A > D (solo una dirección a la vez)
- Usar `swim_idle` como fallback para S, A, D ya que no existen animaciones específicas `swim_backward`, `swim_left`, `swim_right`
- Colocar este bloque DESPUÉS de la lógica de `crouch_walk` y ANTES del fallback general (línea ~101)

**Recursos útiles:**
- Ver implementación de `walk` (líneas 58-78) y `crouch_walk` (líneas 80-101) como referencia
- Las animaciones `swim_forward` y `swim_idle` ya existen en `ANIMATION_FILES`

---

### Paso 2: Modificar resolveAnimationName() para Pasar InputComponent en Estado 'swim'

**Descripción:**
Modificar el método `resolveAnimationName()` para pasar `InputComponent` cuando el estado es `swim`, similar a como se hace para `walk` y `crouch_walk`.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// En resolveAnimationName(), modificar la condición para incluir 'swim'
// Si es estado 'walk', 'crouch_walk' o 'swim', pasar input para determinar dirección
let input = null;
if (stateId === 'walk' || stateId === 'crouch_walk' || stateId === 'swim') {
    input = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.INPUT);
}
const animationName = this.getAnimationNameForState(stateId, input);
```

**Notas:**
- La modificación está en la línea ~167 donde se verifica si el estado es `'walk'` o `'crouch_walk'`
- Agregar `|| stateId === 'swim'` a la condición
- Esto permite que `getAnimationNameForState()` reciba el `InputComponent` cuando el estado es `swim`

**Recursos útiles:**
- Ver línea 167 en `animation-mixer-system.js` donde se verifica `stateId === 'walk' || stateId === 'crouch_walk'`

---

### Paso 3: Modificar playAnimation() para Detectar Cambios en Animaciones Direccionales de 'swim'

**Descripción:**
Modificar el método `playAnimation()` para detectar cambios en animaciones direccionales cuando el estado es `swim`, similar a como se hace para `walk` y `crouch_walk`. Esto permite transiciones suaves al cambiar de dirección mientras se nada.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// En playAnimation(), modificar la verificación de animationChanged para incluir 'swim'
// Para estado 'walk', 'crouch_walk' o 'swim', también verificar si la animación direccional cambió
// (porque el estado puede ser 'walk', 'crouch_walk' o 'swim' pero la animación puede ser walk_forward, walk_left, swim_forward, swim_idle, etc.)
const animationChanged = ((state === 'walk' && currentState === 'walk') || 
                         (state === 'crouch_walk' && currentState === 'crouch_walk') ||
                         (state === 'swim' && currentState === 'swim')) ? 
    (currentAnimationName !== animationName) : false;
```

**Notas:**
- La modificación está en la línea ~390 donde se verifica `animationChanged`
- Agregar `|| (state === 'swim' && currentState === 'swim')` a la condición
- Esto permite detectar cuando cambia la dirección de natación (de `swim_forward` a `swim_idle` o viceversa) mientras el estado sigue siendo `swim`

**Recursos útiles:**
- Ver líneas 389-392 en `animation-mixer-system.js` donde se calcula `animationChanged`

---

### Paso 4: Modificar playAnimation() para Obtener InputComponent en Estado 'swim'

**Descripción:**
Modificar el método `playAnimation()` para obtener `InputComponent` y pasar a `getAnimationNameForState()` cuando el estado es `swim`, similar a como se hace para `walk`. Esto es necesario para que el método pueda determinar la dirección correcta.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js`

**Detalles de implementación:**
```javascript
// En playAnimation(), modificar la condición para incluir 'swim'
// Si es estado 'walk' o 'swim', pasar input para determinar dirección
let input = null;
if (state === 'walk' || state === 'swim') {
    const entityId = mesh.userData.entityId;
    if (entityId) {
        input = this.ecs.getComponent(entityId, ECS_CONSTANTS.COMPONENT_NAMES.INPUT);
    }
}
animationName = this.getAnimationNameForState(state, input);
```

**Notas:**
- La modificación está en la línea ~360 donde se verifica si `state === 'walk'`
- Agregar `|| state === 'swim'` a la condición
- Esto permite obtener el `InputComponent` cuando el estado es `swim` para determinar la dirección

**Recursos útiles:**
- Ver líneas 359-366 en `animation-mixer-system.js` donde se obtiene `input` para `walk`

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-056_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- No hay impacto significativo en performance
- La verificación de teclas presionadas es O(1)
- Solo se obtiene `InputComponent` cuando el estado es `swim` (similar a `walk` y `crouch_walk`)

### Seguridad
- No aplica (cambios solo en frontend, sin interacción con backend)

### Casos Edge
- **Movimiento diagonal nadando**: Solo usar la primera tecla según prioridad (W > S > A > D), sin combinar teclas
- **Cambio rápido de dirección nadando**: Las transiciones deben ser suaves al cambiar rápidamente entre direcciones gracias a `animationChanged`
- **Sin input**: Si `InputComponent` no está disponible, usar fallback del estado config (`swim_forward`)
- **Teclas no presionadas**: Si no hay ninguna tecla presionada mientras está en estado `swim`, usar fallback `swim_forward` del estado config

### Compatibilidad
- Compatible con JDG-051 (animaciones direccionales de caminar)
- Compatible con JDG-052 (animaciones direccionales de agacharse)
- No afecta otras animaciones existentes
- Las animaciones `swim_forward` y `swim_idle` ya existen en `ANIMATION_FILES`

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Reutilizar la misma estrategia simple de JDG-051 y JDG-052: verificar teclas directamente (KeyW, KeyS, KeyA, KeyD)
  - Mantener consistencia con el código existente para `walk` y `crouch_walk`
  - Usar fallback robusto: si las animaciones direccionales no existen, usar `swim_forward` o `swim_idle`

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna - reutiliza dependencias existentes

### Variables de Entorno (si aplica)
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/animation-mixer-system.js` - Extender lógica de animaciones direccionales para estado `swim`

## Testing

### Tests a Crear/Modificar
Ninguno - testing manual según escenarios de prueba

### Escenarios de Prueba
1. **Escenario 1 - Nadar hacia adelante**: Presionar W mientras nada y verificar que se reproduce `swim_forward`
2. **Escenario 2 - Nadar hacia atrás**: Presionar S mientras nada y verificar que se reproduce `swim_idle` (fallback)
3. **Escenario 3 - Nadar hacia la derecha**: Presionar D mientras nada y verificar que se reproduce `swim_idle` (fallback)
4. **Escenario 4 - Nadar hacia la izquierda**: Presionar A mientras nada y verificar que se reproduce `swim_idle` (fallback)
5. **Escenario 5 - Movimiento diagonal nadando**: Presionar W+D mientras nada y verificar que solo se usa W (prioridad)
6. **Escenario 6 - Cambio rápido de dirección**: Cambiar rápidamente entre direcciones mientras nada y verificar transiciones suaves
7. **Escenario 7 - Interfaz F6**: Verificar que las animaciones direccionales aparecen en la interfaz F6 para testing
8. **Escenario 8 - Regresiones**: Verificar que no hay regresiones en otras animaciones existentes (walk, run, jump, attack, etc.)

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos (no requiere rebuild de Docker si se monta como volumen)
2. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar que W reproduce `swim_forward` mientras nada
- [ ] Verificar que S, A, D reproducen `swim_idle` mientras nada
- [ ] Verificar que solo se usa una dirección a la vez (prioridad: W > S > A > D)
- [ ] Verificar que las animaciones direccionales aparecen en F6
- [ ] Verificar que no hay errores en la consola del navegador
- [ ] Verificar que no hay regresiones en otras animaciones

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
