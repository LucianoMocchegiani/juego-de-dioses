# JDG-057 - Refactorizar AnimationMixerSystem con Helpers Externos

## Descripción de la Tarea

Refactorizar `animation-mixer-system.js` (799 líneas) extrayendo responsabilidades específicas a helpers externos en `ecs/helpers/animation/`. El objetivo es reducir el sistema a ~200-300 líneas manteniendo la funcionalidad exacta, mejorando legibilidad y mantenibilidad.

**Comportamiento actual:**
- `animation-mixer-system.js` tiene 799 líneas y maneja múltiples responsabilidades:
  - Carga de animaciones desde archivos GLB (~35 líneas en `loadAnimation`)
  - Inicialización de AnimationMixer (~110 líneas en `initializeMixer`)
  - Resolución de nombres de animación según estado/dirección (~70 líneas en `getAnimationNameForState` y `resolveAnimationName`)
  - Reproducción de animaciones y transiciones (~130 líneas en `playAnimation`)
  - Gestión de combate (i-frames, cleanup) (~80 líneas en `updateCombatAction` y `cleanupFinishedCombatAction`)
  - Reproducción por nombre (~85 líneas en `playAnimationByName`)
  - Método `update` (~100 líneas)
- Es difícil de leer, mantener y testear
- No sigue una estructura consistente con otros sistemas más pequeños

**Comportamiento esperado:**
- `animation-mixer-system.js` es un sistema orquestador de ~200-300 líneas que delega a helpers especializados
- Carpeta `ecs/helpers/animation/` creada con 4 helpers reutilizables:
  - `animation-loader.js` - Carga de animaciones GLB y gestión de cache
  - `animation-resolver.js` - Resolución de nombres según estado/dirección
  - `animation-player.js` - Reproducción y transiciones de animaciones
  - `combat-animation-handler.js` - Gestión de combate (i-frames, cleanup)
- Funcionalidad idéntica (sin cambios de comportamiento)
- Estructura clara y consistente
- Helpers testables independientemente

## Criterios de Aceptación

1. ✅/❌ `animation-mixer-system.js` tiene entre 200-300 líneas (reducido de 799)
2. ✅/❌ Se crea carpeta `ecs/helpers/animation/` con 4 helpers especializados
3. ✅/❌ Cada helper tiene una responsabilidad única y clara
4. ✅/❌ El sistema mantiene exactamente la misma funcionalidad (sin cambios de comportamiento)
5. ✅/❌ Los helpers no dependen del ECS directamente (reciben componentes como parámetros)
6. ✅/❌ Los helpers son testables independientemente
7. ✅/❌ No hay regresiones en animaciones existentes
8. ✅/❌ El código es más legible y mantenible
9. ✅/❌ La estructura sigue las mismas convenciones que otros sistemas pequeños

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: JavaScript ES6+, Three.js AnimationMixer
- ECS (Entity Component System)
- Patrón de helpers/utilities para separación de responsabilidades

## Pasos de Implementación

### Paso 1: Crear Carpeta y Helper AnimationLoader

**Descripción:**
Crear la carpeta `ecs/helpers/animation/` y extraer la lógica de carga de animaciones desde archivos GLB a un helper `AnimationLoader`. Este helper manejará el cache de animaciones y la carga desde archivos GLB.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/animation/animation-loader.js` (nuevo)
- `frontend/src/ecs/helpers/animation/README.md` (nuevo, documentación de la carpeta)

**Detalles de implementación:**
```javascript
// animation-loader.js
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { getBackendBaseUrl } from '../../../utils/config.js';
import { debugLogger } from '../../../debug/logger.js';

const gltfLoader = new GLTFLoader();

export class AnimationLoader {
    constructor() {
        // Cache de animaciones cargadas
        this.animationCache = new Map();
    }

    /**
     * Cargar animación desde archivo GLB
     * @param {string} animationFile - Ruta del archivo de animación
     * @returns {Promise<THREE.AnimationClip[]>} Array de clips de animación
     */
    async loadAnimation(animationFile) {
        // Verificar cache
        if (this.animationCache.has(animationFile)) {
            return this.animationCache.get(animationFile);
        }

        const backendBase = getBackendBaseUrl();
        const url = `${backendBase}/static/models/${animationFile}`;

        try {
            const gltf = await gltfLoader.loadAsync(url);

            if (gltf.animations && gltf.animations.length > 0) {
                this.animationCache.set(animationFile, gltf.animations);
                debugLogger.debug('AnimationLoader', 'Animation loaded successfully', {
                    animationFile,
                    animationCount: gltf.animations.length
                });
                return gltf.animations;
            } else {
                debugLogger.warn('AnimationLoader', 'Animation file has no animations', {
                    animationFile,
                    url
                });
                return [];
            }
        } catch (error) {
            debugLogger.error('AnimationLoader', 'Error loading animation', {
                animationFile,
                url,
                error: error.message
            });
            return [];
        }
    }
}
```

**Notas:**
- Extraer método `loadAnimation()` completo del sistema (líneas 203-242)
- Mover `gltfLoader` a nivel de módulo del helper (similar al sistema actual)
- Mantener mismo comportamiento de cache y logging
- El helper NO depende del ECS, solo recibe el nombre del archivo como parámetro
- **⚠️ READMEs:** Crear `ecs/helpers/animation/README.md` explicando qué contiene la carpeta y para qué sirve cada helper

**Recursos útiles:**
- Ver método `loadAnimation()` en `animation-mixer-system.js` (líneas 203-242)

---

### Paso 2: Crear Helper AnimationResolver

**Descripción:**
Extraer la lógica de resolución de nombres de animación según estado y dirección a un helper `AnimationResolver`. Este helper manejará la resolución de nombres considerando combos, combate, estados normales y direcciones.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/animation/animation-resolver.js` (nuevo)

**Detalles de implementación:**
```javascript
// animation-resolver.js
import { ANIMATION_FILES, ANIMATION_STATES, ANIMATION_MIXER } from '../../../config/animation-config.js';
import { debugLogger } from '../../../debug/logger.js';

export class AnimationResolver {
    constructor(stateConfigMap) {
        // Mapa de estado → AnimationState (pasado desde el sistema)
        this.stateConfigMap = stateConfigMap;
    }

    /**
     * Obtener nombre de animación para un estado
     * @param {string} stateId - ID del estado
     * @param {Object} input - InputComponent opcional para determinar dirección
     * @returns {string|null} Nombre de la animación o null si no hay
     */
    getAnimationNameForState(stateId, input = null) {
        // Lógica de walk, crouch_walk, swim (líneas 56-124 del sistema original)
        // ... (mover código completo)

        // Buscar en el mapa de configuración
        const stateConfig = this.stateConfigMap.get(stateId);
        if (stateConfig && stateConfig.animation) {
            return stateConfig.animation;
        }

        // Fallback: si el estado es el mismo que la animación, usar directamente
        if (ANIMATION_FILES[stateId]) {
            return stateId;
        }

        // Fallback final
        debugLogger.debug('AnimationResolver', 'Using default animation state', {
            stateId,
            defaultState: ANIMATION_MIXER.defaultState
        });
        return ANIMATION_MIXER.defaultState;
    }

    /**
     * Resolver nombre de animación desde componentes fuente según prioridad
     * Prioridad: Combo > Combate > Normal (config)
     * 
     * @param {string} stateId - ID del estado actual
     * @param {Object} combo - ComboComponent opcional
     * @param {Object} combat - CombatComponent opcional
     * @param {Object} input - InputComponent opcional
     * @returns {string|null} Nombre de la animación o null si no se encuentra
     */
    resolveAnimationName(stateId, combo = null, combat = null, input = null) {
        // Prioridad 1: Combo
        if (combo?.activeComboId && combo?.comboAnimation) {
            debugLogger.debug('AnimationResolver', 'Resolved animation from combo', {
                comboId: combo.activeComboId,
                animationName: combo.comboAnimation
            });
            return combo.comboAnimation;
        }

        // Prioridad 2: Combate
        if (combat?.activeAction && combat?.combatAnimation) {
            debugLogger.debug('AnimationResolver', 'Resolved animation from combat', {
                actionId: combat.activeAction,
                animationName: combat.combatAnimation
            });
            return combat.combatAnimation;
        }

        // Prioridad 3: Resolver desde configuración (estado normal)
        const animationName = this.getAnimationNameForState(stateId, input);
        debugLogger.debug('AnimationResolver', 'Resolved animation from state', {
            stateId,
            animationName,
            hasInput: input !== null
        });
        return animationName;
    }
}
```

**Notas:**
- Extraer métodos `getAnimationNameForState()` y `resolveAnimationName()` del sistema (líneas 50-200)
- El helper recibe `stateConfigMap` como parámetro del constructor (creado en el sistema)
- Los helpers reciben componentes como parámetros, NO buscan en el ECS
- Mantener misma lógica de prioridad: Combo > Combate > Normal

**Recursos útiles:**
- Ver métodos `getAnimationNameForState()` y `resolveAnimationName()` en `animation-mixer-system.js` (líneas 50-200)

---

### Paso 3: Crear Helper CombatAnimationHandler

**Descripción:**
Extraer la lógica de gestión de combate (i-frames, cleanup temprano y final) a un helper `CombatAnimationHandler`. Este helper manejará las acciones de combate en progreso.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/animation/combat-animation-handler.js` (nuevo)

**Detalles de implementación:**
```javascript
// combat-animation-handler.js
import { COMBAT_ACTIONS } from '../../../config/combat-actions-config.js';
import { COMBAT_CONSTANTS } from '../../../config/combat-constants.js';
import { ANIMATION_CONSTANTS } from '../../../config/animation-constants.js';

export class CombatAnimationHandler {
    /**
     * Actualizar acciones de combate en progreso (i-frames, limpieza temprana, limpieza final)
     * 
     * @param {Object} combat - CombatComponent
     * @param {Object|null} input - InputComponent o null
     * @param {Object} anim - AnimationComponent
     * @param {THREE.Object3D} mesh - Mesh del modelo
     * @param {THREE.AnimationAction} action - Acción de combate activa
     * @returns {Object} { finished: boolean, finishedActionId: string|null }
     */
    updateCombatAction(combat, input, anim, mesh, action) {
        const actionDuration = action.getClip().duration;
        const progress = actionDuration > 0 ? action.time / actionDuration : 1.0;

        if (!combat || !combat.activeAction) {
            return { finished: false, finishedActionId: null };
        }

        const combatConfig = COMBAT_ACTIONS[combat.activeAction];
        const finishedActionId = combat.activeAction;

        // Actualizar i-frames si corresponde
        if (combatConfig && combatConfig.hasIFrames) {
            combat.hasIFrames = progress >= combatConfig.iFrameStart &&
                progress <= combatConfig.iFrameEnd;
        }

        // Early cleanup: Limpiar defenseType antes de que termine completamente
        const shouldEarlyCleanup = progress >= COMBAT_CONSTANTS.EARLY_CLEANUP_THRESHOLD && progress < 1.0;
        if (shouldEarlyCleanup && (finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.PARRY ||
            finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.DODGE)) {
            combat.cleanupDefenseType(finishedActionId, input);
        }

        // Verificar si la animación terminó completamente
        const animationFinished = progress >= ANIMATION_CONSTANTS.NUMERIC.PROGRESS_COMPLETE || 
                                  (!action.isRunning() && action.time >= actionDuration);

        if (animationFinished) {
            this.cleanupFinishedCombatAction(finishedActionId, combat, input, anim, mesh);
            return { finished: true, finishedActionId };
        }

        return { finished: false, finishedActionId: null };
    }

    /**
     * Limpiar estado cuando termina una animación de combate
     * 
     * @param {string} finishedActionId - ID de la acción que terminó
     * @param {Object} combat - CombatComponent
     * @param {Object|null} input - InputComponent o null
     * @param {Object} anim - AnimationComponent
     * @param {THREE.Object3D} mesh - Mesh del modelo
     */
    cleanupFinishedCombatAction(finishedActionId, combat, input, anim, mesh) {
        // Guardar si parry todavía se quiere (para reactivación)
        const parryStillWanted = finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.PARRY &&
            input && input.wantsToParry;

        // Limpiar todo el estado de combate
        combat.clearCombatState();

        // Lógica especial por tipo de acción
        if (parryStillWanted) {
            combat.defenseType = COMBAT_CONSTANTS.ACTION_IDS.PARRY;
        } else {
            combat.cleanupDefenseType(finishedActionId, input);
        }

        // Resetear wantsToDodge
        if (finishedActionId === COMBAT_CONSTANTS.ACTION_IDS.DODGE && input) {
            input.wantsToDodge = false;
        }

        // Cambiar estado de animación a idle
        if (anim) {
            anim.currentState = ANIMATION_CONSTANTS.STATE_IDS.IDLE;
        }

        // Limpiar referencias en mesh
        mesh.userData.combatAction = null;
        mesh.userData.isAttacking = false;

        // Resetear flag de movimiento aplicado
        if (mesh.userData.movementApplied !== undefined) {
            mesh.userData.movementApplied = false;
        }
    }
}
```

**Notas:**
- Extraer métodos `updateCombatAction()` y `cleanupFinishedCombatAction()` del sistema (líneas 596-686)
- El helper recibe componentes como parámetros, NO busca en el ECS
- Mantener misma lógica de i-frames, early cleanup y cleanup final
- Cambiar retorno de `updateCombatAction()` para retornar objeto con `finished` y `finishedActionId` (mejor para el sistema que lo usa)

**Recursos útiles:**
- Ver métodos `updateCombatAction()` y `cleanupFinishedCombatAction()` en `animation-mixer-system.js` (líneas 596-686)

---

### Paso 4: Crear Helper AnimationPlayer

**Descripción:**
Extraer la lógica de reproducción de animaciones y transiciones a un helper `AnimationPlayer`. Este helper manejará la reproducción de animaciones, fade in/out, detección de cambios direccionales y lógica de interrupción.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/animation/animation-player.js` (nuevo)

**Detalles de implementación:**
```javascript
// animation-player.js
import * as THREE from 'three';
import { ANIMATION_MIXER } from '../../../config/animation-config.js';
import { ANIMATION_CONSTANTS } from '../../../config/animation-constants.js';
import { ECS_CONSTANTS } from '../../../config/ecs-constants.js';
import { COMBAT_ACTIONS } from '../../../config/combat-actions-config.js';

export class AnimationPlayer {
    constructor(animationResolver, ecs) {
        this.animationResolver = animationResolver;
        this.ecs = ecs; // Necesario para obtener InputComponent en playAnimation
    }

    /**
     * Reproducir animación según estado
     * @param {THREE.AnimationMixer} mixer - AnimationMixer
     * @param {Object} clips - Objeto con clips de animación por estado
     * @param {string} state - Estado actual de animación
     * @param {THREE.Object3D} mesh - Mesh del modelo
     * @param {Map} stateConfigMap - Mapa de configuración de estados
     * @param {Object} combo - ComboComponent opcional
     * @param {Object} combat - CombatComponent opcional
     */
    playAnimation(mixer, clips, state, mesh, stateConfigMap, combo = null, combat = null) {
        // Extraer lógica completa de playAnimation del sistema (líneas 363-498)
        // Incluir:
        // - Resolución de nombre de animación
        // - Verificación de cambios de estado/dirección
        // - Lógica de interrupción
        // - Creación y reproducción de action
        // - Tracking de estado actual
    }

    /**
     * Reproducir animación directamente por nombre
     * 
     * @param {number} entityId - ID de la entidad
     * @param {string} animationName - Nombre de la animación
     * @param {THREE.AnimationMixer} mixer - AnimationMixer
     * @param {Object} clips - Clips de animación
     * @param {THREE.Object3D} mesh - Mesh del modelo
     * @returns {boolean} True si se reprodujo correctamente
     */
    playAnimationByName(entityId, animationName, mixer, clips, mesh) {
        // Extraer lógica completa de playAnimationByName del sistema (líneas 501-593)
    }
}
```

**Notas:**
- Extraer métodos `playAnimation()` y `playAnimationByName()` del sistema (líneas 363-593)
- El helper recibe `animationResolver` y `ecs` como dependencias (necesario para obtener InputComponent)
- Mantener misma lógica de transiciones, interrupciones y tracking
- Esta es la parte más compleja, requiere mover ~230 líneas

**Recursos útiles:**
- Ver métodos `playAnimation()` y `playAnimationByName()` en `animation-mixer-system.js` (líneas 363-593)

---

### Paso 5: Refactorizar AnimationMixerSystem para Usar Helpers

**Descripción:**
Refactorizar `animation-mixer-system.js` para usar los helpers creados. El sistema ahora será un orquestador que delega a los helpers especializados.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/animation-mixer-system.js` (refactorizar completamente)

**Detalles de implementación:**
```javascript
// animation-mixer-system.js (refactorizado)
import { System } from '../system.js';
import { ANIMATION_FILES, ANIMATION_STATES, ANIMATION_MIXER } from '../../config/animation-config.js';
import { AnimationState } from '../states/animation-state.js';
import { ECS_CONSTANTS } from '../../config/ecs-constants.js';
import { AnimationLoader } from '../helpers/animation/animation-loader.js';
import { AnimationResolver } from '../helpers/animation/animation-resolver.js';
import { AnimationPlayer } from '../helpers/animation/animation-player.js';
import { CombatAnimationHandler } from '../helpers/animation/combat-animation-handler.js';
// ... otros imports necesarios

export class AnimationMixerSystem extends System {
    constructor(lodManager = null) {
        super();
        // ... configuración inicial

        // Crear helpers
        this.animationLoader = new AnimationLoader();
        this.animationResolver = new AnimationResolver(this.stateConfigMap);
        this.animationPlayer = new AnimationPlayer(this.animationResolver, this.ecs);
        this.combatHandler = new CombatAnimationHandler();
    }

    // Mantener método initializeMixer pero usar AnimationLoader
    async initializeMixer(entityId, mesh) {
        // Usar this.animationLoader.loadAnimation() en lugar de método local
        // ... resto de lógica de inicialización (carga de modelo base, etc.)
    }

    // Método update simplificado que delega a helpers
    update(deltaTime) {
        // Solo orquestación: obtener entidades, delegar a helpers
        // Usar this.animationResolver, this.animationPlayer, this.combatHandler
    }
}
```

**Notas:**
- Eliminar métodos extraídos a helpers (`loadAnimation`, `getAnimationNameForState`, `resolveAnimationName`, `playAnimation`, `playAnimationByName`, `updateCombatAction`, `cleanupFinishedCombatAction`)
- Mantener `initializeMixer()` pero usar `this.animationLoader.loadAnimation()`
- Refactorizar `update()` para usar helpers
- Mantener `stateConfigMap` en el sistema (necesario para pasar a resolver)
- El sistema debe quedar con ~200-300 líneas
- Mantener misma interfaz pública del sistema

**Recursos útiles:**
- Ver estructura actual del sistema en `animation-mixer-system.js`

---

### Paso 6: Actualizar Imports en Otros Archivos (si necesario)

**Descripción:**
Verificar si hay otros archivos que importen métodos específicos del sistema que ahora están en helpers. Actualizar imports si es necesario.

**Archivos a modificar/crear:**
- Verificar archivos que usen `AnimationMixerSystem` (ej: interfaces de prueba)

**Detalles de implementación:**
```javascript
// Si algún archivo importa métodos específicos del sistema,
// verificar que la interfaz pública del sistema se mantiene
// Los métodos públicos deben seguir disponibles en el sistema
```

**Notas:**
- Verificar que `playAnimationByName()` siga disponible como método público del sistema (delegar a helper)
- Verificar interfaces de prueba (ej: F6) siguen funcionando
- Si hay imports directos a métodos ahora privados, actualizar para usar métodos públicos del sistema

**Recursos útiles:**
- Buscar usos de `AnimationMixerSystem` en el proyecto

---

### Paso 7: Testing y Verificación

**Descripción:**
Verificar que todas las animaciones funcionan exactamente igual que antes de la refactorización. Probar todos los escenarios de animación.

**Archivos a modificar/crear:**
- Ninguno (solo testing manual)

**Detalles de implementación:**
1. Probar carga de animaciones desde GLB
2. Probar resolución de nombres (walk, crouch_walk, swim direccionales)
3. Probar reproducción y transiciones de animaciones
4. Probar gestión de combate (i-frames, cleanup)
5. Probar reproducción por nombre (interfaz F6)
6. Verificar que no hay regresiones en animaciones existentes

**Notas:**
- Verificar que el comportamiento es idéntico al anterior
- No debe haber cambios visibles para el usuario
- Si hay alguna diferencia, corregir antes de continuar

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-057_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- No hay impacto significativo en performance
- Los helpers agregan una capa de abstracción pero mantienen misma eficiencia
- El cache de animaciones se mantiene igual (en AnimationLoader)

### Seguridad
- No aplica (refactorización interna, sin cambios de funcionalidad)

### Casos Edge
- **Funcionalidad idéntica**: Asegurar que el comportamiento es exactamente igual al anterior
- **Dependencias circulares**: Verificar que no hay dependencias circulares entre helpers
- **Interfaz pública**: Mantener misma interfaz pública del sistema para no romper otros sistemas

### Compatibilidad
- Compatible con sistemas existentes (misma interfaz pública)
- Compatible con interfaces de prueba (F6, etc.)
- No requiere cambios en otros sistemas

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Helpers independientes que reciben componentes como parámetros
  - Sin dependencias del ECS directamente en helpers
  - Sistema orquestador que delega a helpers
  - Mantener misma estructura de código y convenciones

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna - reutiliza dependencias existentes

### Variables de Entorno (si aplica)
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/animation-mixer-system.js` - Refactorizar para usar helpers (~200-300 líneas)
2. `frontend/src/ecs/helpers/animation/animation-loader.js` (nuevo) - Carga de animaciones
3. `frontend/src/ecs/helpers/animation/animation-resolver.js` (nuevo) - Resolución de nombres
4. `frontend/src/ecs/helpers/animation/animation-player.js` (nuevo) - Reproducción de animaciones
5. `frontend/src/ecs/helpers/animation/combat-animation-handler.js` (nuevo) - Gestión de combate
6. `frontend/src/ecs/helpers/animation/README.md` (nuevo) - Documentación de la carpeta

## Testing

### Tests a Crear/Modificar
Ninguno - testing manual según escenarios de prueba

### Escenarios de Prueba
1. **Escenario 1 - Carga de animaciones**: Verificar que las animaciones se cargan correctamente desde GLB
2. **Escenario 2 - Resolución de nombres**: Verificar que las animaciones direccionales (walk, crouch_walk, swim) se resuelven correctamente
3. **Escenario 3 - Reproducción y transiciones**: Verificar que las transiciones entre animaciones son suaves
4. **Escenario 4 - Gestión de combate**: Verificar que i-frames y cleanup de combate funcionan correctamente
5. **Escenario 5 - Tracking direccional**: Verificar que los cambios direccionales se detectan correctamente
6. **Escenario 6 - Reproducción por nombre**: Verificar que `playAnimationByName()` funciona correctamente (interfaz F6)
7. **Escenario 7 - No regresiones**: Verificar que todas las animaciones existentes (idle, walk, run, jump, attack, etc.) funcionan igual
8. **Escenario 8 - Rendimiento**: Verificar que no hay degradación de rendimiento

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos (no requiere rebuild de Docker si se monta como volumen)
2. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar que todas las animaciones funcionan igual que antes
- [ ] Verificar que la carga de animaciones es correcta
- [ ] Verificar que las animaciones direccionales funcionan correctamente
- [ ] Verificar que las transiciones son suaves
- [ ] Verificar que el combate funciona correctamente
- [ ] Verificar que la interfaz F6 funciona correctamente
- [ ] Verificar que no hay errores en la consola del navegador
- [ ] Verificar que no hay degradación de rendimiento

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
