# JDG-058 - Refactorizar WeaponEquipSystem con Helpers Externos

## Descripción de la Tarea

Refactorizar `weapon-equip-system.js` (628 líneas) extrayendo responsabilidades específicas a helpers externos en `ecs/helpers/weapon/`. El objetivo es reducir el sistema a ~200-250 líneas manteniendo la funcionalidad exacta, mejorando legibilidad y mantenibilidad.

**Comportamiento actual:**
- `weapon-equip-system.js` tiene 628 líneas y maneja múltiples responsabilidades:
  - Inspección de estructura completa de modelos GLB (~200 líneas en `inspectWeaponModel`)
  - Carga de modelos con gestión de cache y promesas (~160 líneas en `equipWeapon`)
  - Adjuntar armas al personaje con ajustes de offset (~135 líneas en `attachWeaponToEntity`)
  - Desequipar armas (~15 líneas en `unequipWeapon`)
  - Orquestación del sistema en `update()` (~35 líneas)
- Es difícil de leer, mantener y testear
- No sigue una estructura consistente con otros sistemas refactorizados

**Comportamiento esperado:**
- `weapon-equip-system.js` es un sistema orquestador de ~200-250 líneas que delega a helpers especializados
- Carpeta `ecs/helpers/weapon/` creada con 3 helpers reutilizables:
  - `weapon-model-inspector.js` - Inspección de estructura de modelos GLB
  - `weapon-model-loader.js` - Carga de modelos con cache y gestión de promesas
  - `weapon-attachment-manager.js` - Adjuntar y desequipar armas al personaje
- Funcionalidad idéntica (sin cambios de comportamiento)
- Estructura clara y consistente
- Helpers testables independientemente

## Criterios de Aceptación

1. ✅/❌ `weapon-equip-system.js` tiene entre 200-250 líneas (reducido de 628)
2. ✅/❌ Se crea carpeta `ecs/helpers/weapon/` con 3 helpers especializados
3. ✅/❌ Cada helper tiene una responsabilidad única y clara
4. ✅/❌ El sistema mantiene exactamente la misma funcionalidad (sin cambios de comportamiento)
5. ✅/❌ Los helpers no dependen del ECS directamente (reciben componentes como parámetros)
6. ✅/❌ Los helpers son testables independientemente
7. ✅/❌ No hay regresiones en equipamiento/desequipamiento de armas
8. ✅/❌ El código es más legible y mantenible
9. ✅/❌ La estructura sigue las mismas convenciones que `animation-mixer-system.js` refactorizado

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: JavaScript ES6+, Three.js (Object3D, Mesh, Group)
- ECS (Entity Component System)
- Patrón de helpers/utilities para separación de responsabilidades
- Object Pool (optimización JDG-047)

## Pasos de Implementación

### Paso 1: Crear Carpeta y Helper WeaponModelInspector

**Descripción:**
Crear la carpeta `ecs/helpers/weapon/` y extraer la lógica de inspección de estructura de modelos GLB a un helper `WeaponModelInspector`. Este helper analiza la jerarquía completa de modelos de armas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/weapon/weapon-model-inspector.js` (nuevo)
- `frontend/src/ecs/helpers/weapon/README.md` (nuevo, documentación de la carpeta)

**Detalles de implementación:**
```javascript
// weapon-model-inspector.js
import * as THREE from 'three';
import { debugLogger } from '../../../debug/logger.js';

export class WeaponModelInspector {
    /**
     * Inspeccionar estructura completa de un modelo de arma
     * @param {THREE.Object3D} model - Modelo a inspeccionar
     * @param {string} modelUrl - URL del modelo (para contexto)
     * @param {Object|null} objectPool - Object Pool opcional (optimización JDG-047)
     * @returns {Object} Estructura detallada del modelo
     */
    inspectWeaponModel(model, modelUrl, objectPool = null) {
        // Extraer método completo inspectWeaponModel del sistema (líneas 45-243)
        // Incluir:
        // - Construcción de estructura del modelo
        // - Función recursiva buildHierarchy
        // - Análisis de transformaciones
        // - Logging detallado
        // - Manejo de Object Pool (optimización JDG-047)
    }
}
```

**Notas:**
- Extraer método `inspectWeaponModel()` completo del sistema (líneas 45-243)
- Mover función recursiva `buildHierarchy` al helper
- Mantener mismo manejo de Object Pool (optimización JDG-047)
- El helper recibe `objectPool` como parámetro opcional (no busca en window.app directamente)
- **⚠️ READMEs:** Crear `ecs/helpers/weapon/README.md` explicando qué contiene la carpeta y para qué sirve cada helper

**Recursos útiles:**
- Ver método `inspectWeaponModel()` en `weapon-equip-system.js` (líneas 45-243)

---

### Paso 2: Crear Helper WeaponModelLoader

**Descripción:**
Extraer la lógica de carga de modelos de armas con gestión de cache y promesas a un helper `WeaponModelLoader`. Este helper maneja la carga desde archivos GLB, cache de modelos y evita cargas duplicadas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/weapon/weapon-model-loader.js` (nuevo)

**Detalles de implementación:**
```javascript
// weapon-model-loader.js
import { ModelLoader } from '../../models/model-loader.js';
import { ModelCache } from '../../models/model-cache.js';
import { getBackendBaseUrl } from '../../../utils/config.js';
import { debugLogger } from '../../../debug/logger.js';

export class WeaponModelLoader {
    constructor(modelLoader, weaponCache, weaponInspector) {
        this.modelLoader = modelLoader;
        this.weaponCache = weaponCache;
        this.weaponInspector = weaponInspector; // Para inspeccionar modelos después de cargar
        // Cache de promesas de carga para evitar cargas duplicadas
        this.loadingPromises = new Map();
    }

    /**
     * Cargar modelo de arma con cache y gestión de promesas
     * @param {string} weaponConfigPath - Ruta del modelo desde WEAPON_MODELS
     * @returns {Promise<THREE.Object3D>} Modelo cargado o desde cache
     */
    async loadWeaponModel(weaponConfigPath) {
        // Extraer lógica de carga del método equipWeapon (líneas 294-456, partes de carga)
        // Incluir:
        // - Construcción de URL del modelo
        // - Verificación de cache
        // - Gestión de promesas (evitar cargas duplicadas)
        // - Llamada a ModelLoader
        // - Inspección del modelo usando WeaponModelInspector
        // - Cache del modelo clonado
        // - Manejo de errores
    }
}
```

**Notas:**
- Extraer lógica de carga de `equipWeapon()` (parte que maneja cache, promesas y ModelLoader)
- El helper recibe `ModelLoader`, `ModelCache` e `WeaponModelInspector` como dependencias
- Mantener misma lógica de cache de promesas para evitar cargas duplicadas
- El helper NO depende del ECS directamente, solo maneja carga de modelos

**Recursos útiles:**
- Ver método `equipWeapon()` en `weapon-equip-system.js` (líneas 294-456, específicamente líneas 307-446)

---

### Paso 3: Crear Helper WeaponAttachmentManager

**Descripción:**
Extraer la lógica de adjuntar y desequipar armas al personaje a un helper `WeaponAttachmentManager`. Este helper maneja la configuración de attachment, ajustes de offset y uso de utilidades de adjuntar armas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/weapon/weapon-attachment-manager.js` (nuevo)

**Detalles de implementación:**
```javascript
// weapon-attachment-manager.js
import { attachWeaponToCharacter, detachWeaponFromCharacter } from '../../../utils/weapon-attachment.js';
import { debugLogger } from '../../../debug/logger.js';

export class WeaponAttachmentManager {
    /**
     * Adjuntar arma al personaje
     * @param {THREE.Object3D} weaponModel - Modelo del arma
     * @param {THREE.Object3D} characterMesh - Mesh del personaje
     * @param {Object} weaponConfig - Configuración del arma desde WEAPON_MODELS
     * @returns {boolean} True si se adjuntó correctamente
     */
    attachWeapon(weaponModel, characterMesh, weaponConfig) {
        // Extraer lógica de attachWeaponToEntity (líneas 466-598)
        // Incluir:
        // - Preparación de configuración de attachment
        // - Asegurar visibilidad del modelo
        // - Detección y compensación de mesh desplazado (offset)
        // - Llamada a attachWeaponToCharacter
        // - Logging detallado
    }

    /**
     * Desequipar arma del personaje
     * @param {THREE.Object3D} weaponModel - Modelo del arma a desequipar
     * @param {THREE.Scene} scene - Escena Three.js (para remover de escena si es necesario)
     */
    unequipWeapon(weaponModel, scene) {
        // Extraer lógica de unequipWeapon (líneas 605-618)
        // Incluir:
        // - Llamada a detachWeaponFromCharacter
        // - Remover de escena si está directamente en ella
    }
}
```

**Notas:**
- Extraer métodos `attachWeaponToEntity()` y `unequipWeapon()` del sistema (líneas 466-618)
- El helper recibe modelos y configuraciones como parámetros, NO busca en el ECS
- Mantener misma lógica de compensación de offset para meshes desplazados
- Mantener logging detallado para debugging

**Recursos útiles:**
- Ver métodos `attachWeaponToEntity()` y `unequipWeapon()` en `weapon-equip-system.js` (líneas 466-618)

---

### Paso 4: Refactorizar WeaponEquipSystem para Usar Helpers

**Descripción:**
Refactorizar `weapon-equip-system.js` para usar los helpers creados. El sistema ahora será un orquestador que delega a los helpers especializados.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/weapon-equip-system.js` (refactorizar completamente)

**Detalles de implementación:**
```javascript
// weapon-equip-system.js (refactorizado)
import { System } from '../system.js';
import { WEAPON_MODELS } from '../../config/weapon-models-config.js';
import { ECS_CONSTANTS } from '../../config/ecs-constants.js';
import { ModelLoader } from '../models/model-loader.js';
import { ModelCache } from '../models/model-cache.js';
import { WeaponModelInspector } from '../helpers/weapon/weapon-model-inspector.js';
import { WeaponModelLoader } from '../helpers/weapon/weapon-model-loader.js';
import { WeaponAttachmentManager } from '../helpers/weapon/weapon-attachment-manager.js';
import { debugLogger } from '../../debug/logger.js';

export class WeaponEquipSystem extends System {
    constructor(scene) {
        super();
        // ... configuración inicial

        // Crear helpers
        const modelLoader = new ModelLoader();
        const weaponCache = ModelCache.getInstance();
        const weaponInspector = new WeaponModelInspector();
        this.weaponModelLoader = new WeaponModelLoader(modelLoader, weaponCache, weaponInspector);
        this.weaponAttachmentManager = new WeaponAttachmentManager();
        this.scene = scene;
    }

    // Método equipWeapon simplificado que delega a helpers
    async equipWeapon(entityId, weapon, render, weaponConfig) {
        // Usar this.weaponModelLoader.loadWeaponModel() para cargar
        // Usar this.weaponAttachmentManager.attachWeapon() para adjuntar
        // Actualizar WeaponComponent con información del arma
    }

    // Método unequipWeapon simplificado
    unequipWeapon(entityId, weapon) {
        // Usar this.weaponAttachmentManager.unequipWeapon()
        // Limpiar WeaponComponent
    }

    // Método update simplificado que delega a helpers
    update(deltaTime) {
        // Solo orquestación: obtener entidades, delegar a helpers
    }
}
```

**Notas:**
- Eliminar métodos extraídos a helpers (`inspectWeaponModel`, `attachWeaponToEntity`, lógica de carga de `equipWeapon`)
- Refactorizar `equipWeapon()` para usar `this.weaponModelLoader` y `this.weaponAttachmentManager`
- Simplificar `unequipWeapon()` para usar `this.weaponAttachmentManager`
- Mantener `update()` pero simplificado
- El sistema debe quedar con ~200-250 líneas
- Mantener misma interfaz pública del sistema
- Mantener `destroy()` para limpiar recursos (ahora limpiará `loadingPromises` del loader si es necesario)

**Recursos útiles:**
- Ver estructura actual del sistema en `weapon-equip-system.js`

---

### Paso 5: Actualizar Imports en Otros Archivos (si necesario)

**Descripción:**
Verificar si hay otros archivos que importen métodos específicos del sistema que ahora están en helpers. Actualizar imports si es necesario.

**Archivos a modificar/crear:**
- Verificar archivos que usen `WeaponEquipSystem` (ej: interfaces de prueba)

**Detalles de implementación:**
```javascript
// Si algún archivo importa métodos específicos del sistema,
// verificar que la interfaz pública del sistema se mantiene
// Los métodos públicos deben seguir disponibles en el sistema
```

**Notas:**
- Verificar que la interfaz pública del sistema se mantiene intacta
- Si hay imports directos a métodos ahora privados, actualizar para usar métodos públicos del sistema

**Recursos útiles:**
- Buscar usos de `WeaponEquipSystem` en el proyecto

---

### Paso 6: Testing y Verificación

**Descripción:**
Verificar que todas las funcionalidades de equipamiento/desequipamiento funcionan exactamente igual que antes de la refactorización. Probar todos los escenarios de armas.

**Archivos a modificar/crear:**
- Ninguno (solo testing manual)

**Detalles de implementación:**
1. Probar carga de modelos de armas desde GLB
2. Probar cache de modelos (no cargar duplicados)
3. Probar inspección de modelos (verificar logs)
4. Probar equipamiento de armas
5. Probar desequipamiento de armas
6. Probar cambio de armas (desequipar anterior al equipar nueva)
7. Verificar que no hay regresiones en armas existentes
8. Verificar manejo de Object Pool (optimización JDG-047)

**Notas:**
- Verificar que el comportamiento es idéntico al anterior
- No debe haber cambios visibles para el usuario
- Si hay alguna diferencia, corregir antes de continuar

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-058_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- No hay impacto significativo en performance
- Los helpers agregan una capa de abstracción pero mantienen misma eficiencia
- El cache de modelos se mantiene igual (en ModelCache y WeaponModelLoader)
- Object Pool sigue funcionando igual (optimización JDG-047)

### Seguridad
- No aplica (refactorización interna, sin cambios de funcionalidad)

### Casos Edge
- **Funcionalidad idéntica**: Asegurar que el comportamiento es exactamente igual al anterior
- **Dependencias circulares**: Verificar que no hay dependencias circulares entre helpers
- **Interfaz pública**: Mantener misma interfaz pública del sistema para no romper otros sistemas
- **Object Pool**: Verificar que los objetos del pool se liberan correctamente después de usar

### Compatibilidad
- Compatible con sistemas existentes (misma interfaz pública)
- Compatible con Object Pool (optimización JDG-047)
- No requiere cambios en otros sistemas

## Patrones de Código a Usar

- **Frontend (Three.js)**: 
  - Helpers independientes que reciben componentes como parámetros
  - Sin dependencias del ECS directamente en helpers
  - Sistema orquestador que delega a helpers
  - Mantener misma estructura de código y convenciones

## Dependencias

### Nuevas Dependencias (si aplica)
Ninguna - reutiliza dependencias existentes

### Variables de Entorno (si aplica)
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/weapon-equip-system.js` - Refactorizar para usar helpers (~200-250 líneas)
2. `frontend/src/ecs/helpers/weapon/weapon-model-inspector.js` (nuevo) - Inspección de modelos
3. `frontend/src/ecs/helpers/weapon/weapon-model-loader.js` (nuevo) - Carga de modelos
4. `frontend/src/ecs/helpers/weapon/weapon-attachment-manager.js` (nuevo) - Adjuntar/desequipar armas
5. `frontend/src/ecs/helpers/weapon/README.md` (nuevo) - Documentación de la carpeta

## Testing

### Tests a Crear/Modificar
Ninguno - testing manual según escenarios de prueba

### Escenarios de Prueba
1. **Escenario 1 - Carga de modelos**: Verificar que las armas se cargan correctamente desde GLB
2. **Escenario 2 - Cache de modelos**: Verificar que el cache funciona (no carga duplicados)
3. **Escenario 3 - Inspección de modelos**: Verificar que la inspección funciona correctamente
4. **Escenario 4 - Equipamiento**: Verificar que las armas se equipan correctamente
5. **Escenario 5 - Desequipamiento**: Verificar que las armas se desequipan correctamente
6. **Escenario 6 - Cambio de armas**: Verificar que al cambiar de arma, la anterior se desequipa
7. **Escenario 7 - No regresiones**: Verificar que todas las armas existentes funcionan igual
8. **Escenario 8 - Object Pool**: Verificar que los objetos del pool se liberan correctamente

## Deployment

### Orden de Deployment
1. Frontend: Actualizar archivos estáticos (no requiere rebuild de Docker si se monta como volumen)
2. Verificar en ambiente local con Docker Compose

### Verificación Post-Deployment
- [ ] Verificar que todas las armas funcionan igual que antes
- [ ] Verificar que la carga de armas es correcta
- [ ] Verificar que el cache funciona correctamente
- [ ] Verificar que las armas se equipan/desequipan correctamente
- [ ] Verificar que no hay errores en la consola del navegador
- [ ] Verificar que no hay degradación de rendimiento

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
