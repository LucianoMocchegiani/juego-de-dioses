# JDG-059 - Refactorizar InputSystem con Helpers Externos

## Descripción de la Tarea

Refactorizar `input-system.js` (385 líneas) extrayendo responsabilidades específicas a 4 helpers especializados en `ecs/helpers/input/`. El sistema se reducirá a ~150-200 líneas, mejorando legibilidad y mantenibilidad sin cambiar funcionalidad.

**Comportamiento actual:**
- `input-system.js` tiene 385 líneas con múltiples responsabilidades mezcladas:
  - Verificación de acciones con lógica compleja de combinaciones (~50 líneas en `checkAction`)
  - Cálculo de dirección de movimiento 2D y 3D (~90 líneas en `update`)
  - Sistema de saltos y activación de vuelo (~35 líneas en `update`)
  - Procesamiento de inputs de combate (~35 líneas en `update`)
  - Aplicación de movimiento a física (~35 líneas en `update`)

**Comportamiento esperado:**
- `input-system.js` será un sistema orquestador de ~150-200 líneas que delega a 4 helpers especializados
- Helpers en `ecs/helpers/input/`: `InputActionChecker`, `MovementDirectionCalculator`, `JumpHandler`, `CombatInputProcessor`
- Mantener funcionalidad exacta (sin cambios de comportamiento)
- Estructura consistente con otros sistemas refactorizados (JDG-057, JDG-058)

## Criterios de Aceptación

1. ❌ `input-system.js` reducido a 150-200 líneas (de 385)
2. ❌ Carpeta `ecs/helpers/input/` creada con 4 helpers especializados
3. ❌ Cada helper tiene una responsabilidad única y clara
4. ❌ El sistema mantiene exactamente la misma funcionalidad (sin cambios de comportamiento)
5. ❌ Los helpers no dependen del ECS directamente (reciben componentes como parámetros)
6. ❌ Los helpers son testables independientemente
7. ❌ No hay regresiones en procesamiento de input
8. ❌ El código es más legible y mantenible
9. ❌ La estructura sigue las mismas convenciones que JDG-057 y JDG-058

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (cálculos de rotación de cámara)
- ECS (Entity Component System)
- InputManager (gestión de teclas y mouse)
- CameraController (rotación de cámara para movimiento 3D)

## Pasos de Implementación

### Paso 1: Crear Carpeta y Helper InputActionChecker

**Descripción:**
Extraer lógica de verificación de acciones del método `checkAction()` a un helper especializado. Este helper manejará la verificación de combinaciones de teclas, clicks de mouse y mapeo de acciones.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/input/input-action-checker.js` (crear)
- `frontend/src/ecs/helpers/input/README.md` (crear)

**Detalles de implementación:**
- Crear clase `InputActionChecker` que reciba `inputManager` y constantes de animación como dependencias
- Extraer método `checkAction(actionName, input)` de `InputSystem`
- Mover lógica de combinaciones de teclas (Control+Click, Shift+Click, etc.)
- Mover verificación de clicks simples (ClickLeft, ClickRight)
- Mover verificación de teclas normales
- Helper debe mantener la misma lógica y retornar boolean

**Notas:**
- **⚠️ READMEs:** Crear `ecs/helpers/input/README.md` documentando la carpeta y helpers
- El helper recibe `inputManager` como dependencia, no lo busca en el ECS
- Mantener compatibilidad con `INPUT_MAP` y `ANIMATION_CONSTANTS`
- El método `checkAction` puede mantenerse como método público de InputSystem que delega al helper

---

### Paso 2: Crear Helper MovementDirectionCalculator

**Descripción:**
Extraer lógica de cálculo de dirección de movimiento (2D normal y 3D en vuelo) a un helper especializado. Este helper manejará la transformación de input local a dirección mundial basada en rotación de cámara.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/input/movement-direction-calculator.js` (crear)

**Detalles de implementación:**
- Crear clase `MovementDirectionCalculator` que reciba `cameraController` y constantes de animación como dependencias
- Extraer lógica de cálculo de dirección 2D (movimiento normal) de `InputSystem.update()`
- Extraer lógica de cálculo de dirección 3D (movimiento en vuelo) con rotación vertical/horizontal de cámara
- Método principal: `calculateMovementDirection(input, physics, inputActionChecker)` que retorna `{x, y, z}`
- Manejar normalización de direcciones según umbrales
- Separar lógica para vuelo (`isFlying === true`) y movimiento normal

**Notas:**
- La lógica 3D es compleja: incluye cálculo de forward/right vectors basados en rotación horizontal y vertical
- El helper necesita acceso a `inputActionChecker` para verificar acciones de movimiento
- Mantener compatibilidad con `ANIMATION_CONSTANTS.INPUT.DIRECTION` y umbrales de normalización
- El resultado debe ser compatible con `input.moveDirection` (objeto con x, y, z)

---

### Paso 3: Crear Helper JumpHandler

**Descripción:**
Extraer lógica de sistema de saltos y activación de vuelo (triple salto) a un helper especializado. Este helper manejará el contador de saltos consecutivos y la activación de vuelo.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/input/jump-handler.js` (crear)

**Detalles de implementación:**
- Crear clase `JumpHandler` que reciba `inputManager` y constantes de animación como dependencias
- Extraer lógica de triple salto de `InputSystem.update()`
- Manejar contador de saltos consecutivos (`consecutiveJumps`)
- Manejar timeout de combo de saltos (`JUMP_COMBO_TIMEOUT`)
- Determinar cuándo activar vuelo (3 saltos consecutivos)
- Método principal: `processJump(input, physics, currentTime)` que actualiza `input.wantsToJump` y `physics.isFlying`
- Resetear contador si pasa mucho tiempo desde último salto

**Notas:**
- El helper necesita acceso a `performance.now()` para timestamps
- Mantener lógica de salto desde suelo vs salto aéreo (doble salto)
- La activación de vuelo debe resetear contador y actualizar `physics.useGravity`
- El helper solo procesa lógica, no aplica cambios directamente (retorna cambios a aplicar)

---

### Paso 4: Crear Helper CombatInputProcessor

**Descripción:**
Extraer lógica de procesamiento de inputs de combate (ataques, defensas, acciones especiales) a un helper especializado. Este helper manejará wantsToAttack, wantsToParry, wantsToDodge, etc.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/input/combat-input-processor.js` (crear)

**Detalles de implementación:**
- Crear clase `CombatInputProcessor` que reciba `inputManager`, `inputActionChecker` y constantes como dependencias
- Extraer lógica de procesamiento de defensas (parry, dodge) de `InputSystem.update()`
- Extraer lógica de procesamiento de ataques (attack, heavyAttack, chargedAttack, specialAttack) de `InputSystem.update()`
- Mantener orden de prioridad para evitar solapamiento de teclas
- Manejar reset de `wantsToDodge` después de procesarlo (solo una vez por press)
- Método principal: `processCombatInputs(input, inputActionChecker)` que actualiza flags en `input` component

**Notas:**
- El orden de verificación es importante: defensas primero, luego ataques especiales, luego ataque normal
- Dodge requiere verificación especial con `isKeyDown` (solo press, no mantener)
- Mantener compatibilidad con `INPUT_MAP` y acciones de combate
- El helper solo actualiza flags en `input`, no ejecuta acciones directamente

---

### Paso 5: Refactorizar InputSystem para Usar Helpers

**Descripción:**
Actualizar `input-system.js` para usar los 4 helpers como orquestador, reduciendo su tamaño de 385 a ~150-200 líneas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/input-system.js` (modificar)

**Detalles de implementación:**
- Importar los 4 helpers creados
- En constructor, instanciar helpers pasando dependencias necesarias:
  - `InputActionChecker(inputManager, ANIMATION_CONSTANTS)`
  - `MovementDirectionCalculator(cameraController, ANIMATION_CONSTANTS)`
  - `JumpHandler(inputManager, ANIMATION_CONSTANTS)`
  - `CombatInputProcessor(inputManager, inputActionChecker, ANIMATION_CONSTANTS)`
- Actualizar método `checkAction()` para delegar a `inputActionChecker.checkAction()`
- Refactorizar método `update()`:
  - Llamar a `movementDirectionCalculator.calculateMovementDirection()` para obtener dirección
  - Llamar a `jumpHandler.processJump()` para procesar saltos
  - Llamar a `combatInputProcessor.processCombatInputs()` para procesar combate
  - Mantener lógica de aplicación de movimiento a física (puede simplificarse si el helper retorna dirección directamente)
- Eliminar métodos/lógica extraídos a helpers
- Mantener lógica de bloqueo de movimiento durante acciones de combate

**Notas:**
- El sistema debe mantener la misma interfaz pública (método `checkAction` sigue disponible)
- El orden de llamadas a helpers debe ser el mismo que el orden de lógica original
- Verificar que no haya regresiones en el flujo de procesamiento
- El helper `MovementDirectionCalculator` puede necesitar acceso a `inputActionChecker` para verificar acciones

---

### Paso 6: Actualizar README de Helpers Input

**Descripción:**
Completar la documentación en `ecs/helpers/input/README.md` explicando cada helper y sus responsabilidades.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/input/README.md` (actualizar)

**Detalles de implementación:**
- Documentar `InputActionChecker`: verificación de acciones y combinaciones
- Documentar `MovementDirectionCalculator`: cálculo de dirección 2D/3D
- Documentar `JumpHandler`: sistema de saltos y vuelo
- Documentar `CombatInputProcessor`: procesamiento de inputs de combate
- Incluir ejemplos de uso si aplica
- Explicar dependencias entre helpers (CombatInputProcessor usa InputActionChecker, MovementDirectionCalculator puede usarlo también)

**Notas:**
- **⚠️ READMEs:** Seguir el mismo formato que `ecs/helpers/animation/README.md` y `ecs/helpers/weapon/README.md`
- Documentar principios de diseño (independencia del ECS, una responsabilidad, testabilidad)

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-059_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Los helpers deben mantener la misma eficiencia que el código original
- No agregar overhead innecesario con múltiples capas de abstracción
- Mantener cálculos de movimiento 3D optimizados

### Seguridad
- Los helpers deben validar inputs recibidos (inputManager, cameraController no null)
- Manejar casos edge donde dependencias no están disponibles

### Casos Edge
- Cámara sin rotación (rotaciónY = 0, rotación vertical = 0)
- Cambio rápido entre movimiento normal y vuelo
- Múltiples combinaciones de teclas presionadas simultáneamente
- Input bloqueado durante acciones de combate (debe respetar `shouldBlockMovement`)
- CameraController no disponible (usar valores por defecto)

### Compatibilidad
- Mantener compatibilidad con InputManager existente
- Mantener compatibilidad con CameraController existente
- No cambiar interfaz pública de InputSystem (métodos públicos como `checkAction`)

## Patrones de Código a Usar

- **Helpers:**
  - Clases ES6 con constructor que recibe dependencias
  - Métodos públicos claros con responsabilidades únicas
  - No buscan componentes en ECS, reciben como parámetros
  - Testables independientemente sin necesidad del ECS completo

- **InputSystem:**
  - Mantener como orquestador que delega a helpers
  - Constructor instancia helpers pasando dependencias
  - Método `update()` simplificado que llama a helpers en orden correcto
  - Mantener lógica de aplicación de movimiento a física (puede simplificarse)

## Dependencias

### Nuevas Dependencias
Ninguna (solo reorganización de código existente)

### Variables de Entorno
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/input-system.js` - Sistema principal a refactorizar (385 → ~150-200 líneas)
2. `frontend/src/ecs/helpers/input/input-action-checker.js` - Helper para verificación de acciones (nuevo)
3. `frontend/src/ecs/helpers/input/movement-direction-calculator.js` - Helper para cálculo de dirección (nuevo)
4. `frontend/src/ecs/helpers/input/jump-handler.js` - Helper para saltos y vuelo (nuevo)
5. `frontend/src/ecs/helpers/input/combat-input-processor.js` - Helper para inputs de combate (nuevo)
6. `frontend/src/ecs/helpers/input/README.md` - Documentación de helpers (nuevo)

## Testing

### Escenarios de Prueba
1. Movimiento básico: Verificar que W/A/S/D mueven correctamente en 2D con rotación de cámara
2. Movimiento en vuelo: Verificar que W/A/S/D mueven correctamente en 3D basado en rotación de cámara (horizontal y vertical)
3. Sistema de saltos: Verificar que primer salto desde suelo funciona, segundo salto en aire funciona, triple salto activa vuelo
4. Combate: Verificar que clicks procesan wantsToAttack, tecla Q procesa wantsToParry, tecla E procesa wantsToDodge
5. Combinaciones de teclas: Verificar que Shift+Click procesa heavyAttack, Ctrl+Click procesa specialAttack
6. Bloqueo de movimiento: Verificar que durante acciones de combate sin hasMovement, el movimiento se bloquea

### Tests a Crear/Modificar
- No hay tests unitarios existentes para InputSystem, pero los helpers deberían ser testables independientemente

## Deployment

### Orden de Deployment
1. Frontend: Los archivos se montan como volumen en Docker, cambios se reflejan automáticamente con hot-reload

### Verificación Post-Deployment
- [x] Verificar frontend en navegador
- [x] Verificar movimiento básico (W/A/S/D)
- [x] Verificar movimiento en vuelo (triple salto + W/A/S/D en 3D)
- [x] Verificar sistema de saltos (simple, doble, triple → vuelo)
- [x] Verificar combate (clicks, Q para parry, E para dodge)
- [x] Verificar combinaciones de teclas (Shift+Click, Ctrl+Click)
- [x] Verificar que no hay errores en consola del navegador

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. El helper más complejo será `MovementDirectionCalculator` debido a la lógica 3D con rotación de cámara. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
