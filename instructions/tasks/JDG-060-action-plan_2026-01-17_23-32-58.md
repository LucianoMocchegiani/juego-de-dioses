# JDG-060 - Refactorizar CollisionSystem con Helpers Externos

## Descripción de la Tarea

Refactorizar `collision-system.js` (269 líneas) extrayendo responsabilidades específicas a 4 helpers especializados en `ecs/helpers/collision/`. El sistema se reducirá a ~120-150 líneas, mejorando legibilidad y mantenibilidad sin cambiar funcionalidad.

**Comportamiento actual:**
- `collision-system.js` tiene 269 líneas con múltiples responsabilidades mezcladas:
  - Gestión de cache de colisiones por entidad (~30 líneas: entityCollisionCache, lastEntityPositions, invalidación)
  - Actualización de celdas ocupadas desde partículas (~15 líneas en `updateLoadedCells`)
  - Detección de líquidos (~25 líneas en `detectLiquidAtPosition`)
  - Detección de colisiones laterales y suelo (~60 líneas en `update`)
  - Verificación de límites del terreno y respawn (~30 líneas en `update`)
  - Invalidación de cache basada en movimiento (~15 líneas en `update`)

**Comportamiento esperado:**
- `collision-system.js` será un sistema orquestador de ~120-150 líneas que delega a 4 helpers especializados
- Helpers en `ecs/helpers/collision/`: `CollisionCacheManager`, `CollisionDetectorHelper`, `LiquidDetector`, `TerrainBoundsChecker`
- Mantener funcionalidad exacta (sin cambios de comportamiento)
- Estructura consistente con otros sistemas refactorizados (JDG-057, JDG-058, JDG-059)

## Criterios de Aceptación

1. ❌ `collision-system.js` reducido a 120-150 líneas (de 269)
2. ❌ Carpeta `ecs/helpers/collision/` creada con 4 helpers especializados
3. ❌ Cada helper tiene una responsabilidad única y clara
4. ❌ El sistema mantiene exactamente la misma funcionalidad (sin cambios de comportamiento)
5. ❌ Los helpers no dependen del ECS directamente (reciben componentes como parámetros)
6. ❌ Los helpers son testables independientemente
7. ❌ No hay regresiones en detección de colisiones
8. ❌ El código es más legible y mantenible
9. ❌ La estructura sigue las mismas convenciones que JDG-057, JDG-058 y JDG-059

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)

### Tecnologías Involucradas
- JavaScript ES6+
- ECS (Entity Component System)
- CollisionDetector (detección de colisiones)
- SpatialGrid (optimización de queries espaciales)

## Pasos de Implementación

### Paso 1: Crear Carpeta y Helper CollisionCacheManager

**Descripción:**
Extraer lógica de gestión de cache de colisiones a un helper especializado. Este helper manejará el cache de partículas ocupadas por entidad, invalidación basada en movimiento y actualización de celdas ocupadas desde partículas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/collision/collision-cache-manager.js` (crear)
- `frontend/src/ecs/helpers/collision/README.md` (crear)

**Detalles de implementación:**
- Crear clase `CollisionCacheManager` que reciba constantes de animación como dependencias
- Extraer gestión de `entityCollisionCache` y `lastEntityPositions` del constructor
- Extraer método `updateLoadedCells()` del sistema (crear mapa de celdas ocupadas desde partículas)
- Métodos principales:
  - `updateLoadedCells(particles)` - Actualizar mapa de celdas ocupadas desde partículas
  - `getOccupiedCells(entityId, loadedOccupiedCells, collisionDetector, position, bloqueId)` - Obtener celdas ocupadas (cache, cargadas o consultar)
  - `invalidateCacheIfNeeded(entityId, position, lastPositions, cache, threshold)` - Invalidar cache si entidad se movió significativamente
  - `clearCache()` - Limpiar cache completo
  - `clearEntityCache(entityId)` - Limpiar cache de entidad específica

**Notas:**
- **⚠️ READMEs:** Crear `ecs/helpers/collision/README.md` documentando la carpeta y helpers
- El helper maneja el cache interno (Map) pero recibe dependencias externas como parámetros
- Mantener compatibilidad con `ANIMATION_CONSTANTS.COLLISION`
- La consulta async de `checkCollision` debe manejarse (puede retornar Promise o callback)

---

### Paso 2: Crear Helper CollisionDetectorHelper

**Descripción:**
Extraer lógica de detección de colisiones (laterales X/Y y suelo Z) a un helper especializado. Este helper manejará la verificación de colisiones y ajuste de velocidad/posición.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/collision/collision-detector-helper.js` (crear)

**Detalles de implementación:**
- Crear clase `CollisionDetectorHelper` que reciba `collisionDetector` y constantes como dependencias
- Extraer lógica de detección de colisiones laterales X/Y de `update()`
- Extraer lógica de detección de suelo Z de `update()`
- Métodos principales:
  - `checkLateralCollisions(position, physics, deltaTime, occupiedCells)` - Verificar colisiones X/Y y ajustar velocidad
  - `checkGroundCollision(position, physics, occupiedCells, dimension)` - Verificar suelo y ajustar `isGrounded`/posición
- Manejar caso especial: entidad dentro de partícula sólida (ajustar hacia arriba)
- Manejar límites del terreno cuando no hay partículas cargadas

**Notas:**
- El helper necesita `collisionDetector` para usar `isCellOccupied`
- Mantener lógica de ajuste de posición cuando entidad está dentro de partícula sólida
- Retornar estado actualizado: `{ hasGround: boolean, adjustedPosition: {x, y, z}?, adjustedVelocity: {x, y, z}? }`

---

### Paso 3: Crear Helper LiquidDetector

**Descripción:**
Extraer lógica de detección de líquidos a un helper especializado. Este helper verificará si hay líquidos en una posición dada.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/collision/liquid-detector.js` (crear)

**Detalles de implementación:**
- Crear clase `LiquidDetector` que reciba constantes como dependencias
- Extraer método `detectLiquidAtPosition()` del sistema
- Método principal: `detectLiquidAtPosition(position, particles)` - Detectar si hay líquidos en posición
- Verificar partículas en posición y filtrar por estado líquido o tipos líquidos

**Notas:**
- El helper recibe `particles` como parámetro, no las busca en el ECS
- Mantener compatibilidad con `ANIMATION_CONSTANTS.COLLISION.PARTICLE_STATE_LIQUID` y `LIQUID_TYPES`
- Retornar boolean (true si hay líquidos)

---

### Paso 4: Crear Helper TerrainBoundsChecker

**Descripción:**
Extraer lógica de verificación de límites del terreno y respawn a un helper especializado. Este helper manejará la limitación de posición y teleporte si se cae fuera del terreno.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/collision/terrain-bounds-checker.js` (crear)

**Detalles de implementación:**
- Crear clase `TerrainBoundsChecker` que reciba constantes como dependencias
- Extraer lógica de límites del terreno de `update()`
- Métodos principales:
  - `checkAndApplyBounds(position, physics, dimension)` - Verificar y aplicar límites, respawn si es necesario
  - Retornar objeto con posición y velocidad ajustadas si hubo respawn
- Manejar límites horizontales (X, Y) y profundidad mínima (Z)
- No limitar altura máxima (permitir vuelo ilimitado hacia arriba)
- Respawn si cae fuera del terreno

**Notas:**
- El helper recibe `dimension` como parámetro opcional
- Mantener compatibilidad con `ANIMATION_CONSTANTS.COLLISION.DEFAULT_RESPAWN` y `DEFAULT_DIMENSION`
- Retornar `{ respawned: boolean, position: {x, y, z}, velocity: {x, y, z} }` si hubo respawn

---

### Paso 5: Refactorizar CollisionSystem para Usar Helpers

**Descripción:**
Actualizar `collision-system.js` para usar los 4 helpers como orquestador, reduciendo su tamaño de 269 a ~120-150 líneas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/collision-system.js` (modificar)

**Detalles de implementación:**
- Importar los 4 helpers creados
- En constructor, instanciar helpers pasando dependencias necesarias:
  - `CollisionCacheManager(ANIMATION_CONSTANTS)`
  - `CollisionDetectorHelper(collisionDetector, ANIMATION_CONSTANTS)`
  - `LiquidDetector(ANIMATION_CONSTANTS)`
  - `TerrainBoundsChecker(ANIMATION_CONSTANTS)`
- Actualizar método `updateLoadedCells()` para delegar a `collisionCacheManager.updateLoadedCells()`
- Actualizar método `detectLiquidAtPosition()` para delegar a `liquidDetector.detectLiquidAtPosition()`
- Refactorizar método `update()`:
  - Delegar actualización de spatial grid (mantener en sistema si es necesario)
  - Delegar obtención de celdas ocupadas a `collisionCacheManager.getOccupiedCells()`
  - Delegar detección de colisiones a `collisionDetectorHelper.checkLateralCollisions()` y `checkGroundCollision()`
  - Delegar verificación de límites a `terrainBoundsChecker.checkAndApplyBounds()`
  - Delegar detección de líquidos a `liquidDetector.detectLiquidAtPosition()`
  - Delegar invalidación de cache a `collisionCacheManager.invalidateCacheIfNeeded()`
- Mantener método `setParticles()` actualizando cache manager
- Eliminar métodos/lógica extraídos a helpers
- Mantener propiedades necesarias: `collisionDetector`, `bloqueId`, `dimension`, `particles`, `spatialGrid`

**Notas:**
- El sistema debe mantener la misma interfaz pública (métodos `setParticles`, `updateLoadedCells`, `detectLiquidAtPosition` siguen disponibles)
- El orden de llamadas a helpers debe ser el mismo que el orden de lógica original
- Verificar que no haya regresiones en el flujo de detección de colisiones
- La consulta async de `checkCollision` puede manejarse en `CollisionCacheManager` o en el sistema

---

### Paso 6: Actualizar README de Helpers Collision

**Descripción:**
Completar la documentación en `ecs/helpers/collision/README.md` explicando cada helper y sus responsabilidades.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/collision/README.md` (actualizar)

**Detalles de implementación:**
- Documentar `CollisionCacheManager`: gestión de cache y celdas ocupadas
- Documentar `CollisionDetectorHelper`: detección de colisiones laterales y suelo
- Documentar `LiquidDetector`: detección de líquidos
- Documentar `TerrainBoundsChecker`: límites del terreno y respawn
- Incluir ejemplos de uso si aplica
- Explicar dependencias entre helpers (si hay alguna)

**Notas:**
- **⚠️ READMEs:** Seguir el mismo formato que otros READMEs de helpers (`ecs/helpers/animation/README.md`, etc.)
- Documentar principios de diseño (independencia del ECS, una responsabilidad, testabilidad)

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-060_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Los helpers deben mantener la misma eficiencia que el código original
- El cache de colisiones es crítico para rendimiento, no agregar overhead
- Mantener invalidación de cache basada en umbral de movimiento

### Seguridad
- Los helpers deben validar inputs recibidos (position, physics, particles no null)
- Manejar casos edge donde dependencias no están disponibles

### Casos Edge
- Entidad dentro de partícula sólida (debe ajustar hacia arriba)
- Caída fuera de límites del terreno (debe respawnear correctamente)
- Sin partículas cargadas (debe usar cache o consultar correctamente)
- Sin dimension (debe manejar límites por defecto)
- Cache vacío al inicio (debe iniciar consulta async)

### Compatibilidad
- Mantener compatibilidad con CollisionDetector existente
- Mantener compatibilidad con SpatialGrid existente
- No cambiar interfaz pública de CollisionSystem (métodos públicos como `setParticles`)

## Patrones de Código a Usar

- **Helpers:**
  - Clases ES6 con constructor que recibe dependencias
  - Métodos públicos claros con responsabilidades únicas
  - No buscan componentes en ECS, reciben como parámetros
  - Testables independientemente sin necesidad del ECS completo

- **CollisionSystem:**
  - Mantener como orquestador que delega a helpers
  - Constructor instancia helpers pasando dependencias
  - Método `update()` simplificado que llama a helpers en orden correcto
  - Mantener lógica de actualización de spatial grid (puede delegarse si el helper la necesita)

## Dependencias

### Nuevas Dependencias
Ninguna (solo reorganización de código existente)

### Variables de Entorno
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/collision-system.js` - Sistema principal a refactorizar (269 → ~120-150 líneas)
2. `frontend/src/ecs/helpers/collision/collision-cache-manager.js` - Helper para gestión de cache (nuevo)
3. `frontend/src/ecs/helpers/collision/collision-detector-helper.js` - Helper para detección de colisiones (nuevo)
4. `frontend/src/ecs/helpers/collision/liquid-detector.js` - Helper para detección de líquidos (nuevo)
5. `frontend/src/ecs/helpers/collision/terrain-bounds-checker.js` - Helper para límites del terreno (nuevo)
6. `frontend/src/ecs/helpers/collision/README.md` - Documentación de helpers (nuevo)

## Testing

### Escenarios de Prueba
1. Colisiones laterales: Verificar que velocidad X/Y se resetea al chocar con partículas sólidas
2. Colisión con suelo: Verificar que `isGrounded` se establece, velocidad Z se resetea, posición Z se ajusta
3. Entidad dentro de partícula: Verificar que posición Z se ajusta hacia arriba
4. Límites del terreno: Verificar que posición se limita correctamente (X, Y, Z mínimo)
5. Respawn: Verificar que si cae fuera del terreno, respawnea en posición por defecto
6. Detección de líquidos: Verificar que `isInWater` se establece correctamente cuando hay líquidos
7. Cache de colisiones: Verificar que cache funciona y se invalida cuando entidad se mueve significativamente
8. Actualización de spatial grid: Verificar que spatial grid se actualiza correctamente

### Tests a Crear/Modificar
- No hay tests unitarios existentes para CollisionSystem, pero los helpers deberían ser testables independientemente

## Deployment

### Orden de Deployment
1. Frontend: Los archivos se montan como volumen en Docker, cambios se reflejan automáticamente con hot-reload

### Verificación Post-Deployment
- [x] Verificar frontend en navegador
- [x] Verificar colisiones laterales (caminar contra paredes)
- [x] Verificar colisión con suelo (caer y tocar suelo)
- [x] Verificar límites del terreno (moverse a bordes, caer fuera)
- [x] Verificar respawn si cae fuera del terreno
- [x] Verificar detección de líquidos (nadar en agua)
- [x] Verificar que no hay errores en consola del navegador

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. El helper más complejo será `CollisionCacheManager` debido a la gestión de cache y consultas async. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
