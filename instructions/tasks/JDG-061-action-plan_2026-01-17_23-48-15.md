# JDG-061 - Refactorizar CombatSystem con Helpers Externos

## Descripción de la Tarea

Refactorizar `combat-system.js` (217 líneas) extrayendo responsabilidades específicas a 4 helpers especializados en `ecs/helpers/combat/`. El sistema se reducirá a ~100-130 líneas, mejorando legibilidad y mantenibilidad sin cambiar funcionalidad.

**Comportamiento actual:**
- `combat-system.js` tiene 217 líneas con múltiples responsabilidades mezcladas:
  - Cache de animation states (~10 líneas en constructor)
  - Procesamiento de acciones en loop principal (~40 líneas en `update()`)
  - Verificación de input de acción (~20 líneas en `checkActionInput()`)
  - Verificación de condiciones de ejecución (~15 líneas en `canExecuteAction()`)
  - Aplicación de configuración de acción (~45 líneas en `applyActionConfig()`)
  - Gestión de cooldowns, combo activo, tipo de arma (~30 líneas en `update()`)
  - Logging y eventos de debug (~15 líneas en `update()`)

**Comportamiento esperado:**
- `combat-system.js` será un sistema orquestador de ~100-130 líneas que delega a 4 helpers especializados
- Helpers en `ecs/helpers/combat/`: `CombatActionInputChecker`, `CombatActionValidator`, `CombatActionConfigApplier`, `CombatAnimationStateCache`
- Mantener funcionalidad exacta (sin cambios de comportamiento)
- Estructura consistente con otros sistemas refactorizados (JDG-057, JDG-058, JDG-059, JDG-060)

## Criterios de Aceptación

1. ❌ `combat-system.js` reducido a 100-130 líneas (de 217)
2. ❌ Carpeta `ecs/helpers/combat/` creada con 4 helpers especializados
3. ❌ Cada helper tiene una responsabilidad única y clara
4. ❌ El sistema mantiene exactamente la misma funcionalidad (sin cambios de comportamiento)
5. ❌ Los helpers no dependen del ECS directamente (reciben componentes como parámetros)
6. ❌ Los helpers son testables independientemente
7. ❌ No hay regresiones en procesamiento de combate (ataques, defensas, cooldowns)
8. ❌ El código es más legible y mantenible
9. ❌ La estructura sigue las mismas convenciones que JDG-057, JDG-058, JDG-059 y JDG-060

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)

### Tecnologías Involucradas
- JavaScript ES6+
- ECS (Entity Component System)
- COMBAT_ACTIONS (configuración centralizada de acciones)
- ANIMATION_STATES (configuración de estados de animación)

## Pasos de Implementación

### Paso 1: Crear Carpeta y Helper CombatAnimationStateCache

**Descripción:**
Extraer lógica de cache de animation states a un helper especializado. Este helper manejará el cache O(1) para lookup de animation states.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/combat/combat-animation-state-cache.js` (crear)
- `frontend/src/ecs/helpers/combat/README.md` (crear)

**Detalles de implementación:**
- Crear clase `CombatAnimationStateCache` que reciba `ANIMATION_STATES` como dependencia
- Extraer construcción de cache desde constructor del sistema
- Método principal: `getAnimationState(animationStateId)` - Obtener animation state por ID (O(1) lookup)
- Constructor inicializa el cache desde `ANIMATION_STATES`

**Notas:**
- **⚠️ READMEs:** Crear `ecs/helpers/combat/README.md` documentando la carpeta y helpers
- El helper maneja el cache interno (Map) para lookup O(1)
- Mantener compatibilidad con `ANIMATION_STATES` array

---

### Paso 2: Crear Helper CombatActionInputChecker

**Descripción:**
Extraer lógica de verificación de input de acción a un helper especializado. Este helper verificará si el InputComponent tiene el input necesario para una acción específica.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/combat/combat-action-input-checker.js` (crear)

**Detalles de implementación:**
- Crear clase `CombatActionInputChecker` que reciba constantes de combate como dependencias
- Extraer método `checkActionInput()` del sistema
- Método principal: `checkActionInput(input, inputAction)` - Verificar si el input corresponde a la acción
- Mapear `inputAction` a propiedades del InputComponent (wantsToDodge, wantsToParry, wantsToAttack, etc.)
- Usar switch/if para mapear según `COMBAT_CONSTANTS.ACTION_IDS`

**Notas:**
- El helper recibe `input` como parámetro, no lo busca en el ECS
- Mantener compatibilidad con `COMBAT_CONSTANTS.ACTION_IDS`
- Retornar boolean (true si el input corresponde a la acción)

---

### Paso 3: Crear Helper CombatActionValidator

**Descripción:**
Extraer lógica de verificación de condiciones de ejecución a un helper especializado. Este helper verificará si una acción puede ejecutarse (arma requerida, tipo de arma, etc.).

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/combat/combat-action-validator.js` (crear)

**Detalles de implementación:**
- Crear clase `CombatActionValidator` que reciba constantes de combate como dependencias
- Extraer método `canExecuteAction()` del sistema
- Método principal: `canExecuteAction(actionConfig, weapon, weaponType)` - Verificar si se puede ejecutar una acción
- Verificar condiciones específicas:
  - Parry requiere arma
  - Special attack requiere espada (WEAPON_TYPES.SWORD)
  - Otras validaciones futuras
- Retornar boolean (true si se puede ejecutar)

**Notas:**
- El helper recibe `weapon` y `weaponType` como parámetros, no los busca en el ECS
- Mantener compatibilidad con `COMBAT_CONSTANTS.WEAPON_TYPES` y `COMBAT_CONSTANTS.ACTION_IDS`
- Debe poder extenderse fácilmente para nuevas validaciones

---

### Paso 4: Crear Helper CombatActionConfigApplier

**Descripción:**
Extraer lógica de aplicación de configuración de acción a un helper especializado. Este helper aplicará la configuración de acción al CombatComponent, incluyendo mapeo de animation states.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/combat/combat-action-config-applier.js` (crear)

**Detalles de implementación:**
- Crear clase `CombatActionConfigApplier` que reciba `animationStateCache`, validadores y constantes como dependencias
- Extraer método `applyActionConfig()` del sistema
- Método principal: `applyActionConfig(combat, actionConfig, animationStateCache)` - Aplicar configuración de acción
- Validar que la acción existe usando `stateValidator`
- Obtener animation state del cache
- Setear propiedades en CombatComponent:
  - `defenseType` (si existe en actionConfig)
  - `attackType` (si existe en actionConfig)
  - `combatAnimation` (desde animation state)
  - `isAttacking` (basado en attackType)
- Manejar errores si animation state no se encuentra (logging)

**Notas:**
- El helper recibe `combat`, `actionConfig` y `animationStateCache` como parámetros
- Mantener compatibilidad con `stateValidator`, `COMBAT_ACTIONS`, `debugLogger`
- Retornar boolean o objeto con estado de éxito/error si es necesario

---

### Paso 5: Refactorizar CombatSystem para Usar Helpers

**Descripción:**
Actualizar `combat-system.js` para usar los 4 helpers como orquestador, reduciendo su tamaño de 217 a ~100-130 líneas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/combat-system.js` (modificar)

**Detalles de implementación:**
- Importar los 4 helpers creados
- En constructor, instanciar helpers pasando dependencias necesarias:
  - `CombatAnimationStateCache(ANIMATION_STATES)`
  - `CombatActionInputChecker(COMBAT_CONSTANTS)`
  - `CombatActionValidator(COMBAT_CONSTANTS)`
  - `CombatActionConfigApplier(animationStateCache, stateValidator, COMBAT_ACTIONS)`
- Eliminar construcción de cache de animation states (movido a helper)
- Refactorizar método `update()`:
  - Mantener lógica de actualización de cooldowns
  - Mantener verificación de combo activo
  - Mantener obtención de tipo de arma
  - Delegar verificación de input a `combatActionInputChecker.checkActionInput()`
  - Delegar validación de ejecución a `combatActionValidator.canExecuteAction()`
  - Delegar aplicación de configuración a `combatActionConfigApplier.applyActionConfig()`
  - Mantener logging y eventos de debug en el lugar apropiado
- Eliminar métodos extraídos: `checkActionInput()`, `canExecuteAction()`, `applyActionConfig()`
- Mantener propiedades necesarias: `inputManager`, `priority`, `requiredComponents`

**Notas:**
- El sistema debe mantener la misma interfaz pública (método `update()` sigue funcionando igual)
- El orden de llamadas a helpers debe ser el mismo que el orden de lógica original
- Verificar que no haya regresiones en el flujo de procesamiento de combate
- Logging y eventos de debug pueden mantenerse en el sistema o moverse a helpers según sea apropiado

---

### Paso 6: Actualizar README de Helpers Combat

**Descripción:**
Completar la documentación en `ecs/helpers/combat/README.md` explicando cada helper y sus responsabilidades.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/combat/README.md` (actualizar)

**Detalles de implementación:**
- Documentar `CombatAnimationStateCache`: cache O(1) para lookup de animation states
- Documentar `CombatActionInputChecker`: verificación de input de acción desde InputComponent
- Documentar `CombatActionValidator`: verificación de condiciones de ejecución (arma, tipo de arma)
- Documentar `CombatActionConfigApplier`: aplicación de configuración de acción y mapeo de animation states
- Incluir ejemplos de uso si aplica
- Explicar dependencias entre helpers (si hay alguna)

**Notas:**
- **⚠️ READMEs:** Seguir el mismo formato que otros READMEs de helpers (`ecs/helpers/animation/README.md`, etc.)
- Documentar principios de diseño (independencia del ECS, una responsabilidad, testabilidad)

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-061_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- El cache de animation states es crítico para rendimiento (O(1) lookup), debe mantenerse
- Los helpers no deben agregar overhead significativo

### Seguridad
- Los helpers deben validar inputs recibidos (input, combat, actionConfig no null)
- Manejar casos edge donde dependencias no están disponibles

### Casos Edge
- Acción activa ya en progreso (no procesar nuevos inputs)
- Combo activo (omitiendo procesamiento de acciones individuales)
- Arma requerida para ciertas acciones (parry, special_attack)
- Cooldowns expirados (permitir ejecución)
- Animation state no encontrado (manejo de error con logging)

### Compatibilidad
- Mantener compatibilidad con COMBAT_ACTIONS existente
- Mantener compatibilidad con ANIMATION_STATES existente
- Mantener compatibilidad con InputComponent y CombatComponent
- No cambiar interfaz pública de CombatSystem (método `update()`)

## Patrones de Código a Usar

- **Helpers:**
  - Clases ES6 con constructor que recibe dependencias
  - Métodos públicos claros con responsabilidades únicas
  - No buscan componentes en ECS, reciben como parámetros
  - Testables independientemente sin necesidad del ECS completo

- **CombatSystem:**
  - Mantener como orquestador que delega a helpers
  - Constructor instancia helpers pasando dependencias
  - Método `update()` simplificado que llama a helpers en orden correcto
  - Mantener lógica de coordinación (cooldowns, combo activo, tipo de arma)

## Dependencias

### Nuevas Dependencias
Ninguna (solo reorganización de código existente)

### Variables de Entorno
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/combat-system.js` - Sistema principal a refactorizar (217 → ~100-130 líneas)
2. `frontend/src/ecs/helpers/combat/combat-animation-state-cache.js` - Helper para cache de animation states (nuevo)
3. `frontend/src/ecs/helpers/combat/combat-action-input-checker.js` - Helper para verificación de input de acción (nuevo)
4. `frontend/src/ecs/helpers/combat/combat-action-validator.js` - Helper para validación de condiciones de ejecución (nuevo)
5. `frontend/src/ecs/helpers/combat/combat-action-config-applier.js` - Helper para aplicación de configuración de acción (nuevo)
6. `frontend/src/ecs/helpers/combat/README.md` - Documentación de helpers (nuevo)

## Testing

### Escenarios de Prueba
1. Ataques básicos: Verificar que los ataques se procesan correctamente según input
2. Defensas (parry/dodge): Verificar que las defensas se procesan correctamente
3. Cooldowns: Verificar que los cooldowns funcionan correctamente
4. Validación de arma: Verificar que las acciones que requieren arma funcionan correctamente (parry requiere arma, special_attack requiere espada)
5. Aplicación de configuración: Verificar que las configuraciones de acción se aplican correctamente
6. Cache de animation states: Verificar que el cache funciona correctamente (O(1) lookup)
7. Combos activos: Verificar que si hay combo activo, se omite el procesamiento de acciones individuales
8. Acción activa en progreso: Verificar que si hay acción activa, no se procesan nuevos inputs

### Tests a Crear/Modificar
- No hay tests unitarios existentes para CombatSystem, pero los helpers deberían ser testables independientemente

## Deployment

### Orden de Deployment
1. Frontend: Los archivos se montan como volumen en Docker, cambios se reflejan automáticamente con hot-reload

### Verificación Post-Deployment
- [x] Verificar frontend en navegador
- [x] Verificar ataques básicos (clicks)
- [x] Verificar defensas (Q para parry, E para dodge)
- [x] Verificar cooldowns (no permitir ejecución repetida inmediata)
- [x] Verificar validación de arma (parry requiere arma, special_attack requiere espada)
- [x] Verificar que no hay errores en consola del navegador

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. El helper más complejo será `CombatActionConfigApplier` debido a la validación y mapeo de animation states. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
