# JDG-062 - Refactorizar PhysicsSystem con Helpers Externos

## Descripción de la Tarea

Refactorizar `physics-system.js` (220 líneas) extrayendo responsabilidades específicas a 4 helpers especializados en `ecs/helpers/physics/`. El sistema se reducirá a ~100-130 líneas, mejorando legibilidad y mantenibilidad sin cambiar funcionalidad.

**Comportamiento actual:**
- `physics-system.js` tiene 220 líneas con múltiples responsabilidades mezcladas:
  - Timestep fijo y acumulador (~15 líneas en `update()`)
  - Aplicar saltos (~15 líneas en `updatePhysics()`)
  - Gestión de vuelo (~5 líneas en `updatePhysics()`)
  - Movimiento de acciones de combate (~50 líneas en `updatePhysics()`)
  - Bloqueo de movimiento normal (~15 líneas en `updatePhysics()`)
  - Aplicar gravedad (~5 líneas en `updatePhysics()`)
  - Actualizar velocidad con aceleración (~5 líneas en `updatePhysics()`)
  - Aplicar fricción (~25 líneas en `updatePhysics()`)
  - Limitar velocidad máxima (~15 líneas en `updatePhysics()`)
  - Actualizar posición (~5 líneas en `updatePhysics()`)

**Comportamiento esperado:**
- `physics-system.js` será un sistema orquestador de ~100-130 líneas que delega a 4 helpers especializados
- Helpers en `ecs/helpers/physics/`: `PhysicsTimestepManager`, `CombatMovementApplier`, `PhysicsFrictionApplier`, `PhysicsVelocityLimiter`
- Mantener funcionalidad exacta (sin cambios de comportamiento)
- Estructura consistente con otros sistemas refactorizados (JDG-057, JDG-058, JDG-059, JDG-060, JDG-061)

## Criterios de Aceptación

1. ❌ `physics-system.js` reducido a 100-130 líneas (de 220)
2. ❌ Carpeta `ecs/helpers/physics/` creada con 4 helpers especializados
3. ❌ Cada helper tiene una responsabilidad única y clara
4. ❌ El sistema mantiene exactamente la misma funcionalidad (sin cambios de comportamiento)
5. ❌ Los helpers no dependen del ECS directamente (reciben componentes como parámetros)
6. ❌ Los helpers son testables independientemente
7. ❌ No hay regresiones en física (gravedad, velocidad, aceleración, fricción, movimiento de combate)
8. ❌ El código es más legible y mantenible
9. ❌ La estructura sigue las mismas convenciones que JDG-057, JDG-058, JDG-059, JDG-060 y JDG-061

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js)

### Tecnologías Involucradas
- JavaScript ES6+
- ECS (Entity Component System)
- COMBAT_ACTIONS (configuración centralizada de acciones de combate)

## Pasos de Implementación

### Paso 1: Crear Carpeta y Helper PhysicsTimestepManager

**Descripción:**
Extraer lógica de timestep fijo y acumulador a un helper especializado. Este helper manejará la ejecución de física con timestep fijo.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/physics/physics-timestep-manager.js` (crear)
- `frontend/src/ecs/helpers/physics/README.md` (crear)

**Detalles de implementación:**
- Crear clase `PhysicsTimestepManager` que reciba `fixedTimestep` como dependencia
- Extraer lógica de acumulador desde constructor y método `update()` del sistema
- Método principal: `update(deltaTime, updateCallback)` - Actualizar con timestep fijo y ejecutar callback múltiples veces si es necesario
- El acumulador se mantiene interno en el helper
- Retornar número de pasos ejecutados (útil para debugging)

**Notas:**
- **⚠️ READMEs:** Crear `ecs/helpers/physics/README.md` documentando la carpeta y helpers
- El helper maneja el acumulador interno
- El callback se ejecuta múltiples veces si el acumulador es mayor que fixedTimestep
- Mantener compatibilidad con `ANIMATION_CONSTANTS.PHYSICS.FIXED_TIMESTEP`

---

### Paso 2: Crear Helper CombatMovementApplier

**Descripción:**
Extraer lógica de aplicación de movimiento de acciones de combate a un helper especializado. Este helper aplicará impulso de movimiento basado en configuración de acciones de combate.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/physics/combat-movement-applier.js` (crear)

**Detalles de implementación:**
- Crear clase `CombatMovementApplier` que reciba `COMBAT_ACTIONS` como dependencia
- Extraer lógica de movimiento de combate de `updatePhysics()`
- Método principal: `applyCombatMovement(physics, input, combat, render, actionConfig)` - Aplicar movimiento de combate si es necesario
- Manejar cálculo de dirección (input o cámara)
- Manejar flag `movementApplied` en `render.mesh.userData`
- Resetear flag cuando no hay acción activa
- Retornar boolean indicando si se aplicó movimiento

**Notas:**
- El helper recibe `physics`, `input`, `combat`, `render` y `actionConfig` como parámetros
- Mantener compatibilidad con `COMBAT_ACTIONS` y `actionConfig.hasMovement`, `actionConfig.movementSpeed`, `actionConfig.useMovementInput`
- El flag `movementApplied` debe manejarse cuidadosamente para aplicar impulso solo una vez

---

### Paso 3: Crear Helper PhysicsFrictionApplier

**Descripción:**
Extraer lógica de aplicación de fricción a un helper especializado. Este helper aplicará fricción según el estado (vuelo, normal, bloqueado).

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/physics/physics-friction-applier.js` (crear)

**Detalles de implementación:**
- Crear clase `PhysicsFrictionApplier`
- Extraer lógica de fricción de `updatePhysics()`
- Método principal: `applyFriction(physics, shouldBlockNormalMovement)` - Aplicar fricción según estado
- Manejar tres casos:
  - Vuelo: fricción 0.85 en todas las direcciones
  - Movimiento normal: fricción horizontal según `groundFriction` o `airFriction`
  - Movimiento bloqueado: fricción extra 0.7 para transición más suave
- Modificar `physics.velocity` directamente

**Notas:**
- El helper recibe `physics` y `shouldBlockNormalMovement` como parámetros
- Mantener valores de fricción exactos (0.85 para vuelo, 0.7 para bloqueado)
- La fricción se aplica a `velocity.x`, `velocity.y` (y `velocity.z` solo en vuelo)

---

### Paso 4: Crear Helper PhysicsVelocityLimiter

**Descripción:**
Extraer lógica de limitación de velocidad máxima a un helper especializado. Este helper limitará la velocidad según los límites configurados.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/physics/physics-velocity-limiter.js` (crear)

**Detalles de implementación:**
- Crear clase `PhysicsVelocityLimiter`
- Extraer lógica de limitación de velocidad de `updatePhysics()`
- Método principal: `limitVelocity(physics)` - Limitar velocidad según `maxVelocity`
- Limitar `velocity.x` y `velocity.y` siempre
- Limitar `velocity.z` solo si NO está volando (permitir vuelo ilimitado hacia arriba)
- Modificar `physics.velocity` directamente

**Notas:**
- El helper recibe `physics` como parámetro
- Mantener lógica de no limitar velocidad vertical en vuelo
- Usar `Math.sign()` y `Math.abs()` para limitar correctamente

---

### Paso 5: Refactorizar PhysicsSystem para Usar Helpers

**Descripción:**
Actualizar `physics-system.js` para usar los 4 helpers como orquestador, reduciendo su tamaño de 220 a ~100-130 líneas.

**Archivos a modificar/crear:**
- `frontend/src/ecs/systems/physics-system.js` (modificar)

**Detalles de implementación:**
- Importar los 4 helpers creados
- En constructor, instanciar helpers pasando dependencias necesarias:
  - `PhysicsTimestepManager(this.fixedTimestep)`
  - `CombatMovementApplier(COMBAT_ACTIONS)`
  - `PhysicsFrictionApplier()`
  - `PhysicsVelocityLimiter()`
- Refactorizar método `update()`:
  - Usar `timestepManager.update(deltaTime, (timestep) => { this.updatePhysics(timestep); })`
- Refactorizar método `updatePhysics()`:
  - Mantener lógica de aplicar saltos
  - Mantener lógica de desactivar vuelo si toca el suelo
  - Delegar movimiento de combate a `combatMovementApplier.applyCombatMovement()`
  - Mantener lógica de bloqueo de movimiento normal (o extraer a helper si es apropiado)
  - Mantener lógica de aplicar gravedad
  - Mantener lógica de actualizar velocidad con aceleración
  - Delegar fricción a `physicsFrictionApplier.applyFriction()`
  - Delegar limitación de velocidad a `physicsVelocityLimiter.limitVelocity()`
  - Mantener lógica de actualizar posición
  - Mantener lógica de resetear aceleración
- Eliminar lógica extraída a helpers

**Notas:**
- El sistema debe mantener la misma interfaz pública (métodos `update()` y `updatePhysics()` siguen funcionando igual)
- El orden de llamadas a helpers debe ser el mismo que el orden de lógica original
- Verificar que no haya regresiones en el flujo de física
- La lógica de saltos, gravedad y actualización de posición/velocidad puede mantenerse en el sistema (son operaciones simples)

---

### Paso 6: Actualizar README de Helpers Physics

**Descripción:**
Completar la documentación en `ecs/helpers/physics/README.md` explicando cada helper y sus responsabilidades.

**Archivos a modificar/crear:**
- `frontend/src/ecs/helpers/physics/README.md` (actualizar)

**Detalles de implementación:**
- Documentar `PhysicsTimestepManager`: gestión de timestep fijo y acumulador
- Documentar `CombatMovementApplier`: aplicación de movimiento de acciones de combate
- Documentar `PhysicsFrictionApplier`: aplicación de fricción (vuelo, normal, bloqueado)
- Documentar `PhysicsVelocityLimiter`: limitación de velocidad máxima
- Incluir ejemplos de uso si aplica
- Explicar dependencias entre helpers (si hay alguna)

**Notas:**
- **⚠️ READMEs:** Seguir el mismo formato que otros READMEs de helpers (`ecs/helpers/animation/README.md`, etc.)
- Documentar principios de diseño (independencia del ECS, una responsabilidad, testabilidad)

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-062_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- El timestep fijo es crítico para física estable, debe mantenerse correctamente
- Los helpers no deben agregar overhead significativo

### Seguridad
- Los helpers deben validar inputs recibidos (physics, input, combat, etc. no null)
- Manejar casos edge donde dependencias no están disponibles

### Casos Edge
- Entidad volando y tocando el suelo (debe desactivar vuelo)
- Movimiento de combate bloqueado (debe aplicar fricción extra)
- Velocidad máxima en vuelo (no limitar velocidad vertical)
- Timestep fijo acumulado mayor que fixedTimestep (debe ejecutar múltiples pasos)

### Compatibilidad
- Mantener compatibilidad con COMBAT_ACTIONS existente
- Mantener compatibilidad con PhysicsComponent y PositionComponent
- No cambiar interfaz pública de PhysicsSystem (métodos `update()` y `updatePhysics()`)

## Patrones de Código a Usar

- **Helpers:**
  - Clases ES6 con constructor que recibe dependencias
  - Métodos públicos claros con responsabilidades únicas
  - No buscan componentes en ECS, reciben como parámetros
  - Testables independientemente sin necesidad del ECS completo

- **PhysicsSystem:**
  - Mantener como orquestador que delega a helpers
  - Constructor instancia helpers pasando dependencias
  - Método `update()` usa `PhysicsTimestepManager` para timestep fijo
  - Método `updatePhysics()` simplificado que llama a helpers en orden correcto
  - Mantener lógica simple de saltos, gravedad y actualización de posición/velocidad

## Dependencias

### Nuevas Dependencias
Ninguna (solo reorganización de código existente)

### Variables de Entorno
Ninguna

## Archivos Principales Involucrados

1. `frontend/src/ecs/systems/physics-system.js` - Sistema principal a refactorizar (220 → ~100-130 líneas)
2. `frontend/src/ecs/helpers/physics/physics-timestep-manager.js` - Helper para timestep fijo (nuevo)
3. `frontend/src/ecs/helpers/physics/combat-movement-applier.js` - Helper para movimiento de combate (nuevo)
4. `frontend/src/ecs/helpers/physics/physics-friction-applier.js` - Helper para fricción (nuevo)
5. `frontend/src/ecs/helpers/physics/physics-velocity-limiter.js` - Helper para límites de velocidad (nuevo)
6. `frontend/src/ecs/helpers/physics/README.md` - Documentación de helpers (nuevo)

## Testing

### Escenarios de Prueba
1. Gravedad: Verificar que la gravedad se aplica correctamente cuando no está volando
2. Velocidad y aceleración: Verificar que la velocidad se actualiza correctamente con aceleración
3. Fricción: Verificar que la fricción se aplica correctamente (vuelo, normal, bloqueado)
4. Límites de velocidad: Verificar que la velocidad máxima se limita correctamente
5. Movimiento de combate: Verificar que el movimiento de acciones de combate se aplica correctamente
6. Saltos: Verificar que los saltos se aplican correctamente
7. Vuelo: Verificar que el vuelo se desactiva cuando toca el suelo
8. Timestep fijo: Verificar que el timestep fijo funciona correctamente (múltiples pasos si es necesario)

### Tests a Crear/Modificar
- No hay tests unitarios existentes para PhysicsSystem, pero los helpers deberían ser testables independientemente

## Deployment

### Orden de Deployment
1. Frontend: Los archivos se montan como volumen en Docker, cambios se reflejan automáticamente con hot-reload

### Verificación Post-Deployment
- [x] Verificar frontend en navegador
- [x] Verificar gravedad (caída correcta)
- [x] Verificar velocidad y aceleración (movimiento correcto)
- [x] Verificar fricción (frenado correcto)
- [x] Verificar límites de velocidad (no excede máximo)
- [x] Verificar movimiento de combate (impulso correcto en acciones)
- [x] Verificar saltos (salto normal y doble salto)
- [x] Verificar vuelo (se desactiva al tocar suelo)
- [x] Verificar que no hay errores en consola del navegador

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. El helper más complejo será `CombatMovementApplier` debido a la lógica de movimiento de acciones de combate. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`. Esto genera automáticamente la descripción completa del PR lista para Git.
