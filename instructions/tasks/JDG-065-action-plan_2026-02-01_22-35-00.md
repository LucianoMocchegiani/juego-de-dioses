# JDG-065 - Migrar Backend a Estructura por Dominio (estilo Nest)

## Descripción de la Tarea

Reorganizar el backend FastAPI por **dominio/módulo** (estilo NestJS): cada recurso (bloques, particles, characters, celestial, agrupaciones) tendrá su propia carpeta bajo `api/domains/` con schemas (DTOs) y routes. Schemas compartidos (geometría, estilos) irán a `api/domains/shared/`. La API expuesta (URLs y contratos JSON) no cambia.

**Comportamiento actual:** Schemas centralizados en `models/schemas.py` y `models/particula_schemas.py`; rutas en `api/routes/*.py`. No hay agrupación por dominio.

**Comportamiento esperado:** Estructura `api/domains/{bloques,particles,characters,celestial,agrupaciones,shared}/` con `schemas.py` y `routes.py` por dominio; main.py registra los mismos routers con los mismos prefijos. Mismas URLs y mismos response bodies.

## Criterios de Aceptación

1. [ ] Existe `api/domains/` con carpetas shared, bloques, particles, characters, celestial, agrupaciones.
2. [ ] Cada dominio tiene su `schemas.py` (DTOs del recurso) y `routes.py` (router FastAPI).
3. [ ] Schemas compartidos (parse_jsonb_field, GeometriaVisual, EstilosParticula, etc.) viven en `api/domains/shared/schemas.py`.
4. [ ] main.py registra los routers desde los nuevos módulos; prefijos y rutas son los mismos que hoy.
5. [ ] Tests de API existentes (si los hay) siguen pasando; OpenAPI /docs muestra los mismos esquemas y rutas.
6. [ ] README de `backend/src/models/` y de `backend/src/api/` (o api/domains/) actualizados describiendo la estructura por dominio.
7. [ ] No hay cambios en BD ni en frontend; refactor solo backend.
8. [ ] No queda carpeta `api/routes/`; eliminada por completo tras migrar rutas a api/domains/.
9. [ ] (Paso 9) Servicios de negocio migrados a dominios: celestial, particles (y opcionalmente bloques) tienen `service.py` en su dominio; rutas importan desde el dominio; `src/services/` solo conserva lo cross-cutting (p. ej. performance_monitor) o se documenta en README.

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [ ] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Python 3.11, FastAPI, Pydantic
- Estructura de carpetas por dominio (convención tipo Nest)

### Referencia
- **Análisis de arquitectura:** `instructions/analysis/JDG-065-architecture-analysis_2026-02-01_22-35-00.md`
- **Ticket:** `instructions/tickets/JDG-065_work-ticket_2026-02-01_22-30-44.md`

---

## Pasos de Implementación

### Paso 1: Crear estructura de carpetas y módulo shared

**Descripción:**
Crear `api/domains/`, `api/domains/shared/` y extraer a `shared/schemas.py` los modelos usados por más de un dominio: `parse_jsonb_field`, `GeometriaParametros`, `GeometriaVisual`, `MaterialProperties`, `VisualProperties`, `EstilosParticula`. Asegurar que `shared` no importe de ningún dominio para evitar ciclos.

**Archivos a modificar/crear:**
- `backend/src/api/domains/__init__.py` (crear)
- `backend/src/api/domains/shared/__init__.py` (crear)
- `backend/src/api/domains/shared/schemas.py` (crear; mover o copiar modelos compartidos desde `models/schemas.py`)
- `backend/src/models/schemas.py` (eliminar contenido migrado; no re-exportar)

**Detalles de implementación:**
- En `shared/schemas.py` incluir: `parse_jsonb_field`, `MaterialProperties`, `GeometriaParametros`, `GeometriaVisual`, `VisualProperties`, `EstilosParticula`. Los dominios characters y particles importarán desde `src.api.domains.shared.schemas`.
- En `shared/__init__.py` exportar los nombres públicos necesarios.

**Notas:**
- **⚠️ READMEs:** Crear `api/domains/README.md` indicando que contiene módulos por dominio (bloques, particles, etc.) y que shared contiene DTOs compartidos. Crear `api/domains/shared/README.md` breve indicando qué contiene (helpers y modelos reutilizados por varios dominios).

**Recursos útiles:**
- `instructions/analysis/JDG-065-architecture-analysis_2026-02-01_22-35-00.md` (sección "shared kernel")

---

### Paso 2: Migrar dominio bloques

**Descripción:**
Crear `api/domains/bloques/` con `schemas.py` (DimensionBase, DimensionCreate, DimensionResponse, WorldSizeResponse) y `routes.py` con el contenido actual de `api/routes/dimensions.py`. Registrar el router en main.py desde el nuevo módulo. Comprobar que GET /bloques, GET /bloques/{id}, GET /bloques/world/size respondan igual.

**Archivos a modificar/crear:**
- `backend/src/api/domains/bloques/__init__.py` (crear)
- `backend/src/api/domains/bloques/schemas.py` (crear; DimensionBase, DimensionCreate, DimensionResponse, WorldSizeResponse)
- `backend/src/api/domains/bloques/routes.py` (crear; contenido de dimensions.py; imports desde .schemas)
- `backend/src/main.py` (modificar: importar router desde api.domains.bloques.routes y registrar con prefix /api/v1; quitar include_router de api.routes.dimensions)
- `backend/src/api/routes/dimensions.py` (eliminar)

**Detalles de implementación:**
```python
# domains/bloques/routes.py
from fastapi import APIRouter
from src.api.domains.bloques.schemas import DimensionResponse, WorldSizeResponse
# ... resto igual que dimensions.py, prefix="/bloques", tags=["bloques"]
```

**Notas:**
- **⚠️ READMEs:** Crear `api/domains/bloques/README.md` indicando que contiene DTOs y rutas del recurso bloques (dimensiones/mundos).

---

### Paso 3: Migrar dominio celestial

**Descripción:**
Crear `api/domains/celestial/` con `schemas.py` (CelestialStateResponse, TemperatureRequest, TemperatureResponse, CelestialPosition) y `routes.py` con el contenido actual de `api/routes/celestial.py`. Registrar el router en main.py. Comprobar GET /celestial/state y POST /celestial/temperature.

**Archivos a modificar/crear:**
- `backend/src/api/domains/celestial/__init__.py` (crear)
- `backend/src/api/domains/celestial/schemas.py` (crear)
- `backend/src/api/domains/celestial/routes.py` (crear; contenido de celestial.py; imports desde .schemas y desde services/config según corresponda)
- `backend/src/main.py` (modificar: registrar router desde api.domains.celestial.routes)
- `backend/src/api/routes/celestial.py` (eliminar)

**Notas:**
- **⚠️ READMEs:** Crear `api/domains/celestial/README.md` breve.

---

### Paso 4: Migrar dominio particles

**Descripción:**
Crear `api/domains/particles/` con `schemas.py` (ParticleResponse, ParticlesResponse, ParticleTypeResponse, ParticleTypesResponse, ParticleViewportQuery; importar desde shared lo necesario, ej. parse_jsonb_field). `routes.py` con contenido actual de `api/routes/particles.py`. Registrar router. Comprobar GET /bloques/{id}/particles y GET /bloques/{id}/particle-types.

**Archivos a modificar/crear:**
- `backend/src/api/domains/particles/__init__.py` (crear)
- `backend/src/api/domains/particles/schemas.py` (crear; importar parse_jsonb_field desde shared)
- `backend/src/api/domains/particles/routes.py` (crear; contenido de particles.py)
- `backend/src/main.py` (modificar: registrar router desde api.domains.particles.routes)
- `backend/src/api/routes/particles.py` (eliminar)

**Notas:**
- Decidir si `particula_schemas.py` (JDG-038) se integra en `particles/schemas.py` o se deja como `particles/particula_schemas.py` y se documenta en README.
- **⚠️ READMEs:** Crear `api/domains/particles/README.md`.

---

### Paso 5: Migrar dominio characters

**Descripción:**
Crear `api/domains/characters/` con `schemas.py` (CharacterResponse, CharacterCreate, BipedGeometry, BipedGeometryPart, Model3D, Model3DOffset, Model3DRotation; importar GeometriaVisual desde shared) y `routes.py` con contenido actual de `api/routes/characters.py`. Registrar router. Comprobar GET/POST /bloques/{id}/characters y GET .../model.

**Archivos a modificar/crear:**
- `backend/src/api/domains/characters/__init__.py` (crear)
- `backend/src/api/domains/characters/schemas.py` (crear; importar GeometriaVisual desde api.domains.shared.schemas)
- `backend/src/api/domains/characters/routes.py` (crear; contenido de characters.py; imports desde .schemas y database/creators, templates, etc.)
- `backend/src/main.py` (modificar: registrar router desde api.domains.characters.routes)
- `backend/src/api/routes/characters.py` (eliminar)

**Notas:**
- **⚠️ READMEs:** Crear `api/domains/characters/README.md`.

---

### Paso 6: Migrar dominio agrupaciones

**Descripción:**
Crear `api/domains/agrupaciones/` con `schemas.py` (AgrupacionResponse, AgrupacionWithParticles; si usan ParticleResponse, importar desde domains.particles.schemas) y `routes.py` con contenido actual de `api/routes/agrupaciones.py`. Registrar router. Comprobar GET /bloques/{id}/agrupaciones y GET /bloques/{id}/agrupaciones/{aid}.

**Archivos a modificar/crear:**
- `backend/src/api/domains/agrupaciones/__init__.py` (crear)
- `backend/src/api/domains/agrupaciones/schemas.py` (crear; AgrupacionResponse, AgrupacionWithParticles; AgrupacionWithParticles incluye particulas: List[ParticleResponse] → importar ParticleResponse desde domains.particles.schemas)
- `backend/src/api/domains/agrupaciones/routes.py` (crear; contenido de agrupaciones.py)
- `backend/src/main.py` (modificar: registrar router desde api.domains.agrupaciones.routes)
- `backend/src/api/routes/agrupaciones.py` (eliminar)
- **Eliminar la carpeta `backend/src/api/routes/`** por completo (README e `__init__.py` incluidos); no dejar carpeta legacy. Actualizar `README.md` raíz para quitar el enlace a api/routes.

**Notas:**
- **⚠️ READMEs:** Crear `api/domains/agrupaciones/README.md`.

---

### Paso 7: Actualizar consumidores y limpiar models

**Descripción:**
Actualizar todos los imports en `database/`, `services/` y cualquier otro módulo que use `from src.models.schemas import ...` para que importen desde los nuevos módulos (`src.api.domains.shared.schemas`, `src.api.domains.bloques.schemas`, etc.). Eliminar `models/schemas.py` (y `models/particula_schemas.py` si se integró en particles); actualizar `models/README.md` para indicar que los DTOs viven en `api/domains/`.

**Archivos a modificar/crear:**
- `backend/src/database/creators/entity_creator.py` (y otros que importen schemas)
- `backend/src/database/templates/bipedos/*.py` (si importan schemas)
- `backend/src/services/*.py` (si importan schemas)
- `backend/src/models/schemas.py` (eliminar; contenido ya migrado a domains)
- `backend/src/models/README.md` (actualizar: documentar estructura por dominio y que los DTOs están en api/domains/)
- `backend/src/api/README.md` o `api/routes/README.md` (actualizar o crear api/domains/README.md con índice de dominios)

**Detalles de implementación:**
- Buscar en el repo: `from src.models.schemas` y `from src.models import` y reemplazar por imports desde `src.api.domains.<dominio>.schemas` o `src.api.domains.shared.schemas`.

**Notas:**
- **⚠️ READMEs:** Actualizar `backend/src/models/README.md` con la nueva estructura y referencias a api/domains/. La carpeta `api/routes/` se elimina en el Paso 6; no debe quedar.

---

### Paso 8: Verificación y documentación final

**Descripción:**
Ejecutar la aplicación y verificar que /docs (OpenAPI) muestra los mismos endpoints y esquemas. Ejecutar tests de API si existen. Añadir o ajustar una sección en el README principal del backend (o en docs/) que describa la estructura por dominio y enlace a api/domains/README.md.

**Archivos a modificar/crear:**
- `backend/README.md` o `backend/src/README.md` (si existe; añadir subsección "Estructura por dominio" con enlace a api/domains/)
- `instructions/analysis/JDG-065-architecture-analysis_2026-02-01_22-35-00.md` (referencia; no modificar salvo correcciones)

**Notas:**
- No incluir pasos de testing manual extensivo; los criterios de aceptación ya piden que los tests existentes pasen.

---

### Paso 9: Migrar servicios a dominios

**Descripción:**
Mover la lógica de negocio de `src/services/` a los dominios correspondientes en `api/domains/`, de modo que cada dominio tenga su `service.py` (o carpeta `services/`) cuando aplique. Las rutas del dominio importan desde el servicio del mismo dominio.

**Servicios actuales y destino sugerido:**
- **Celestial:** `celestial_time_service.py`, `temperature_service.py` → `api/domains/celestial/service.py` (o `celestial/services/` con módulos separados). Actualizar `api/domains/celestial/routes.py` para importar desde `.service` (o `.services`).
- **Partículas:** `particula_service.py` → `api/domains/particles/service.py`. Actualizar `api/domains/particles/routes.py` y cualquier otro consumidor (p. ej. celestial routes que usen `get_particulas_con_inercia`) para importar desde `src.api.domains.particles.service`.
- **Bloques:** `world_bloque_manager.py`, `world_bloque.py` → `api/domains/bloques/service.py` si se usan desde rutas de bloques; si solo los usan otros servicios, valorar moverlos a bloques o dejarlos en `src/services/` como compartidos.
- **Cross-cutting:** `performance_monitor_service.py` puede permanecer en `src/services/` (no es dominio de API) o moverse a un módulo shared de infra si se prefiere.

**Archivos a modificar/crear:**
- `backend/src/api/domains/celestial/service.py` (crear; contenido de CelestialTimeService y lógica de temperature_service, o importar y re-exportar desde módulos movidos).
- `backend/src/api/domains/particles/service.py` (crear; contenido de particula_service).
- `backend/src/api/domains/bloques/service.py` (crear si aplica; world_bloque_manager, world_bloque).
- Actualizar `api/domains/<dominio>/routes.py` para importar desde `src.api.domains.<dominio>.service` en lugar de `src.services`.
- Actualizar `main.py` y cualquier otro consumidor (p. ej. lifespan que inicia tareas celestiales) para importar desde los nuevos módulos de dominio.
- Eliminar o vaciar los archivos migrados en `src/services/` (celestial_time_service, temperature_service, particula_service, y opcionalmente world_bloque_*). Actualizar `src/services/__init__.py` para exportar solo lo que permanezca (p. ej. performance_monitor_service).
- **READMEs:** Actualizar `api/domains/README.md` y los README por dominio para indicar que cada dominio puede tener `service.py`; actualizar `backend/src/services/README.md` indicando que la lógica por dominio está en `api/domains/<dominio>/`.

**Notas:**
- Evitar imports circulares: los servicios de dominio no deben importar rutas de otros dominios; pueden importar schemas de shared o del mismo dominio.
- Si un servicio es usado por varios dominios (p. ej. temperature por celestial y por particles), puede vivir en el dominio "dueño" del concepto (celestial) y ser importado desde particles, o extraerse a `api/domains/shared/` si es genérico.

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-065_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Sin impacto: mismo código de rutas y validación Pydantic; solo cambia la ubicación de los archivos.

### Seguridad
- Sin cambios en validación ni en contratos; mismos DTOs y mismos endpoints.

### Casos Edge
- Imports circulares: asegurar que `shared` no importe de ningún dominio. Si agrupaciones importa ParticleResponse de particles, evitar que particles importe de agrupaciones.
- Rutas que usan DTOs de más de un dominio (ej. TemperatureRequest con bloque_id): el DTO vive en el dominio que posee el endpoint (celestial).

### Compatibilidad
- API 100% compatible: mismas URLs, mismos request/response bodies. Frontend y tests E2E no requieren cambios.

## Patrones de Código a Usar

- **Backend (FastAPI):** APIRouter por dominio; response_model y request body con DTOs del mismo dominio; imports desde shared cuando un dominio use geometría/estilos.
- **Estructura:** Un dominio = una carpeta con `__init__.py`, `schemas.py`, `routes.py`; shared = solo schemas compartidos sin dependencias de dominios.

## Dependencias

### Nuevas Dependencias
Ninguna; solo reorganización de código.

### Variables de Entorno
Ninguna nueva.

## Archivos Principales Involucrados

1. `backend/src/main.py` – Registro de routers desde api.domains.*
2. `backend/src/api/domains/` – Nueva estructura (shared, bloques, particles, characters, celestial, agrupaciones)
3. `backend/src/models/schemas.py` – Eliminado; README actualizado
4. `backend/src/api/routes/` – Carpeta eliminada; rutas en domains/*/routes.py
5. `backend/src/database/`, `backend/src/services/` – Imports actualizados; tras Paso 9, servicios por dominio en api/domains/<dominio>/service.py

## Testing

### Tests a Crear/Modificar
- Si existen tests de API (p. ej. tests que llamen a GET /bloques, GET /particles, etc.), deben seguir pasando sin cambiar aserciones.
- No se exige añadir nuevos tests en este refactor; solo verificar que los existentes pasen.

### Escenarios de Prueba
1. GET /api/v1/bloques devuelve lista de dimensiones con la misma estructura.
2. GET /api/v1/bloques/{id}/particles?x_min=...&x_max=... devuelve ParticlesResponse igual que antes.
3. GET /api/v1/celestial/state devuelve CelestialStateResponse igual que antes.
4. GET /api/v1/bloques/{id}/characters y POST /api/v1/bloques/{id}/characters funcionan igual.
5. OpenAPI /docs muestra los mismos esquemas y rutas que antes del refactor.

## Deployment

### Orden de Deployment
1. Backend: rebuild de imagen Docker (si aplica) y restart del contenedor.
2. No hay cambios en frontend, BD ni variables de entorno.

### Verificación Post-Deployment
- [ ] Verificar /docs (OpenAPI) y comparar con versión anterior (mismas rutas y esquemas).
- [ ] Verificar al menos un endpoint por dominio con curl o Postman (mismo body que antes).
- [ ] Verificar logs del backend sin errores de import.

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. Si encuentras problemas o necesitas clarificación, consulta con el equipo antes de proceder.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`.
