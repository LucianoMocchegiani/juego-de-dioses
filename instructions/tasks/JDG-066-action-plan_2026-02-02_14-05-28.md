# JDG-066 - Plan de acción: Migración completa del backend a Hexagonal + DDD

## Descripción de la Tarea

Implementar la **arquitectura objetivo completa** Hexagonal + DDD en todo el backend: todos los dominios (bloques, particles, characters, celestial, agrupaciones) con puertos de persistencia (repositorios), casos de uso y rutas como adaptadores de entrada; `world_creation_engine` usando repositorios inyectados; sin `get_connection()` ni SQL fuera de `infrastructure/` y `database/`.

**Comportamiento actual:**
- Routes y services usan `get_connection()` y SQL directo (asyncpg).
- No hay interfaces de repositorio ni casos de uso explícitos.
- Estructura por dominio (JDG-065) ya existe; falta capa application + infrastructure por dominio.

**Comportamiento esperado:**
- Cada dominio tiene: `application/ports/` (interfaces), `application/*.py` (casos de uso), `infrastructure/` (PostgresXxxRepository), `routes.py` (solo HTTP ↔ casos de uso).
- Ningún archivo en `domain/` ni `application/` importa asyncpg, get_connection, FastAPI o APIRouter.
- main.py registra routers y provee dependencias (Depends) para repositorios.
- API expuesta (URLs y JSON) no cambia.

**Referencia:** `instructions/analysis/JDG-066-architecture-analysis_2026-02-02_10-14-48.md` (sección "Arquitectura objetivo completa").

---

## Criterios de Aceptación

1. ❌ Todos los dominios (bloques, particles, characters, celestial, agrupaciones) tienen puerto de repositorio, adaptador Postgres y casos de uso; routes sin SQL.
2. ❌ world_creation_engine usa repositorios inyectados (no get_connection directo).
3. ❌ main.py (o cada router) inyecta repositorios vía Depends; no hay get_connection en routes ni en application.
4. ❌ READMEs de backend y de cada dominio actualizados (estructura Hexagonal+DDD).
5. ❌ Tests unitarios de al menos un caso de uso por dominio con repositorio mock.
6. ❌ API (URLs y contratos JSON) idéntica a la actual.

---

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Backend (FastAPI)
- [ ] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL) — sin cambios de schema
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Python 3.11, FastAPI, Depends (inyección de dependencias)
- asyncpg, get_connection() solo en infrastructure/ y database/
- Patrones: Puerto/Adaptador, Repository, Dependency Injection

---

## Pasos de Implementación

### Paso 1: Estructura base y convenciones (bloques como plantilla)

**Descripción:**
Crear en el dominio **bloques** la estructura completa Hexagonal+DDD (domain/, application/ports/, application/*.py, infrastructure/) y usarla como plantilla para el resto. Implementar puerto `IBloqueRepository`, adaptador `PostgresBloqueRepository`, casos de uso (get_bloques, get_bloque_by_id, get_world_size) y refactorizar routes para que solo llamen a los casos de uso con Depends.

**Archivos a modificar/crear:**
- `backend/src/domains/bloques/domain/__init__.py` (vacío o con comentario)
- `backend/src/domains/bloques/application/__init__.py`
- `backend/src/domains/bloques/application/ports/__init__.py`
- `backend/src/domains/bloques/application/ports/bloque_repository.py` (IBloqueRepository)
- `backend/src/domains/bloques/application/get_bloques.py`
- `backend/src/domains/bloques/application/get_bloque_by_id.py`
- `backend/src/domains/bloques/application/get_world_size.py`
- `backend/src/domains/bloques/infrastructure/__init__.py`
- `backend/src/domains/bloques/infrastructure/postgres_bloque_repository.py`
- `backend/src/domains/bloques/routes.py` (refactor: Depends(repository), llamar casos de uso)
- `backend/src/domains/bloques/README.md` (actualizar: explicar domain/application/infrastructure)

**Detalles de implementación:**
- Extraer de `bloques/routes.py` y de `bloques/terrain_utils.py` (si aplica) las queries actuales y moverlas a `PostgresBloqueRepository`.
- La interfaz `IBloqueRepository` debe declarar los métodos que hoy usan las rutas (listar bloques, obtener por id, datos para world size).
- Casos de uso: funciones async que reciben el repositorio como argumento y devuelven DTOs (DimensionResponse, WorldSizeResponse); lanzan ValueError/KeyError para “no encontrado” y routes traducen a HTTP 404.
- En routes: `def get_bloque_repository(): return PostgresBloqueRepository()` y `Depends(get_bloque_repository)`; cada endpoint construye parámetros, llama al caso de uso y devuelve el response.

**Notas:**
- **⚠️ READMEs:** Actualizar `domains/bloques/README.md` con la nueva estructura (domain, application/ports, application use cases, infrastructure, routes).
- No modificar `schemas.py` salvo para añadir tipos necesarios para el contrato del repositorio si faltan.

---

### Paso 2: Dominio particles — puerto, adaptador y casos de uso

**Descripción:**
Añadir en **particles** la estructura application/ports, application (casos de uso), infrastructure. Definir `IParticleRepository` con los métodos usados por las rutas actuales (get_types_in_viewport, get_by_viewport, count_by_viewport, get_by_id, bloque_exists). Implementar `PostgresParticleRepository` moviendo el SQL desde `particles/routes.py` y `particles/service.py`. Crear casos de uso (get_particle_types_in_viewport, get_particles_by_viewport, get_particle_by_id) y refactorizar routes para usar Depends(repository) y casos de uso.

**Archivos a modificar/crear:**
- `backend/src/domains/particles/domain/__init__.py`
- `backend/src/domains/particles/application/__init__.py`
- `backend/src/domains/particles/application/ports/__init__.py`
- `backend/src/domains/particles/application/ports/particle_repository.py` (IParticleRepository)
- `backend/src/domains/particles/application/get_particle_types_in_viewport.py`
- `backend/src/domains/particles/application/get_particles_by_viewport.py`
- `backend/src/domains/particles/application/get_particle_by_id.py`
- `backend/src/domains/particles/infrastructure/__init__.py`
- `backend/src/domains/particles/infrastructure/postgres_particle_repository.py`
- `backend/src/domains/particles/routes.py` (refactor)
- `backend/src/domains/particles/README.md` (actualizar)
- Decidir si mantener `service.py` para lógica que usan otros dominios (celestial) o moverla a casos de uso y que celestial dependa del puerto IParticleRepository.

**Detalles de implementación:**
- Revisar todas las llamadas a `get_connection()` en particles/routes.py y particles/service.py; cada flujo debe tener un método en IParticleRepository y su implementación en PostgresParticleRepository.
- Casos de uso reciben `IParticleRepository` por parámetro; validan viewport (validate_ranges); si “bloque no encontrado”, lanzar ValueError para que routes devuelva 404.
- Mantener `parse_jsonb_field` en shared; los adaptadores pueden importar desde shared.

**Notas:**
- **⚠️ READMEs:** Actualizar `domains/particles/README.md` con domain/application/infrastructure y lista de casos de uso.

---

### Paso 3: Dominio characters — puerto, adaptador, storage y casos de uso

**Descripción:**
Añadir en **characters** application/ports (character_repository y opcionalmente un port para storage, reutilizando BaseStorage), application (casos de uso: list_characters, get_character, create_character, get_character_model), infrastructure (PostgresCharacterRepository y adaptador que use BaseStorage para modelos). Refactorizar routes para usar Depends y casos de uso.

**Archivos a modificar/crear:**
- `backend/src/domains/characters/domain/__init__.py`
- `backend/src/domains/characters/application/__init__.py`
- `backend/src/domains/characters/application/ports/__init__.py`
- `backend/src/domains/characters/application/ports/character_repository.py`
- `backend/src/domains/characters/application/ports/storage_port.py` (opcional: tipo Protocol que coincida con BaseStorage)
- `backend/src/domains/characters/application/list_characters.py`
- `backend/src/domains/characters/application/get_character.py`
- `backend/src/domains/characters/application/create_character.py`
- `backend/src/domains/characters/application/get_character_model.py`
- `backend/src/domains/characters/infrastructure/postgres_character_repository.py`
- `backend/src/domains/characters/infrastructure/local_storage_adapter.py` (usa BaseStorage)
- `backend/src/domains/characters/routes.py` (refactor)
- `backend/src/domains/characters/README.md` (actualizar)

**Detalles de implementación:**
- create_character y get_character_model usan EntityCreator/Builders del world_creation_engine; en este paso los builders pueden seguir usando get_connection si hace falta, y en un paso posterior (Paso 7) se inyectarán repositorios. Alternativa: ya inyectar repos en EntityCreator desde routes (pasando repositorios desde main o desde el router).
- Si se define storage_port, que sea un Protocol con los métodos que usa characters (get_model_url, model_exists, etc.); LocalFileStorage ya los implementa.

**Notas:**
- **⚠️ READMEs:** Actualizar README de characters con la nueva estructura.

---

### Paso 4: Dominio celestial — puertos y casos de uso

**Descripción:**
Celestial hoy usa lógica en service.py y llama a particles (get_particulas_con_inercia, etc.). Introducir application/ports (puerto para “estado celestial” o lectura de estado si aplica; puerto para partículas: usar `IParticleRepository` de particles o un puerto específico que particles implemente). Casos de uso: get_celestial_state, apply_temperature_to_cells (o el flujo que corresponda). Implementación en infrastructure que use get_connection() donde haga falta y el repositorio de partículas inyectado. Refactorizar routes para usar Depends y casos de uso.

**Archivos a modificar/crear:**
- `backend/src/domains/celestial/domain/__init__.py`
- `backend/src/domains/celestial/application/__init__.py`
- `backend/src/domains/celestial/application/ports/__init__.py`
- `backend/src/domains/celestial/application/ports/particle_repository.py` (puede re-exportar IParticleRepository de particles o definir un protocolo más acotado)
- `backend/src/domains/celestial/application/get_celestial_state.py`
- `backend/src/domains/celestial/application/apply_temperature_to_cells.py` (o el nombre del flujo real)
- `backend/src/domains/celestial/infrastructure/celestial_service_impl.py` (o postgres_* si hay persistencia directa)
- `backend/src/domains/celestial/routes.py` (refactor)
- `backend/src/domains/celestial/README.md` (actualizar)

**Detalles de implementación:**
- Celestial puede depender de `src.domains.particles.application.ports.particle_repository.IParticleRepository` para leer partículas; en main.py se inyecta la misma instancia PostgresParticleRepository (o un wrapper) para particles y celestial.
- La lógica actual de temperature update y background tasks puede vivir en el caso de uso o en un “service” de aplicación que use los puertos; lo importante es que no haya get_connection() en application/, solo en infrastructure/.

**Notas:**
- **⚠️ READMEs:** Actualizar README de celestial; documentar dependencia del puerto de partículas.

---

### Paso 5: Dominio agrupaciones — puerto, adaptador y casos de uso

**Descripción:**
Añadir en **agrupaciones** application/ports (IAgrupacionRepository), application (get_agrupaciones, get_agrupacion_with_particles), infrastructure (PostgresAgrupacionRepository). Refactorizar routes para usar Depends y casos de uso. El repositorio puede necesitar datos de partículas; puede usar IParticleRepository inyectado o encapsular queries JOIN en PostgresAgrupacionRepository.

**Archivos a modificar/crear:**
- `backend/src/domains/agrupaciones/domain/__init__.py`
- `backend/src/domains/agrupaciones/application/__init__.py`
- `backend/src/domains/agrupaciones/application/ports/__init__.py`
- `backend/src/domains/agrupaciones/application/ports/agrupacion_repository.py`
- `backend/src/domains/agrupaciones/application/get_agrupaciones.py`
- `backend/src/domains/agrupaciones/application/get_agrupacion_with_particles.py`
- `backend/src/domains/agrupaciones/infrastructure/__init__.py`
- `backend/src/domains/agrupaciones/infrastructure/postgres_agrupacion_repository.py`
- `backend/src/domains/agrupaciones/routes.py` (refactor)
- `backend/src/domains/agrupaciones/README.md` (actualizar)

**Detalles de implementación:**
- Las respuestas actuales incluyen partículas; el repositorio puede devolver AgrupacionWithParticles construido con queries propias o componiendo IParticleRepository si se inyecta.

**Notas:**
- **⚠️ READMEs:** Actualizar README de agrupaciones.

---

### Paso 6: world_creation_engine — usar repositorios inyectados

**Descripción:**
Modificar `world_creation_engine` (builders, entity_creator, terrain_builder) para que no usen `get_connection()` directamente. En su lugar, recibir por constructor o parámetro los repositorios necesarios (IParticleRepository, IBloqueRepository, ICharacterRepository si aplica, BaseStorage). Las llamadas desde seeds o desde endpoints (ej. crear personaje) deben instanciar los repositorios concretos y pasarlos al EntityCreator / TerrainBuilder.

**Archivos a modificar/crear:**
- `backend/src/world_creation_engine/builders/base.py` (añadir parámetros de repos en constructor)
- `backend/src/world_creation_engine/builders/tree_builder.py` (usar self._particle_repo, self._bloque_repo)
- `backend/src/world_creation_engine/builders/biped_builder.py` (usar repos inyectados)
- `backend/src/world_creation_engine/creators/entity_creator.py` (recibir repos en __init__)
- `backend/src/world_creation_engine/terrain_builder.py` (recibir repos si escribe en BD)
- `backend/src/database/seed_terrain_test_1.py` (instanciar repos y pasar a EntityCreator/terrain_builder)
- `backend/src/database/seed_terrain_test_2.py` (igual)
- `backend/src/database/seed_character_with_model.py` (igual)
- `backend/src/domains/characters/routes.py` (al llamar a EntityCreator, construir repos y pasarlos)
- `backend/src/world_creation_engine/README.md` (actualizar: dependencias por inyección)

**Detalles de implementación:**
- BaseBuilder: `__init__(self, particle_repository: IParticleRepository, bloque_repository: IBloqueRepository, ...)`.
- EntityCreator: `__init__(self, particle_repo, bloque_repo, character_repo, storage: BaseStorage)`.
- En seeds, obtener conexión o repos: `particle_repo = PostgresParticleRepository()` (o vía un get_connection si los repos lo necesitan internamente); pasar al creator. Los repos ya usan get_connection() internamente, así que no hace falta pasar connection a los seeds si los repos se instancian ahí.

**Notas:**
- **⚠️ READMEs:** Actualizar world_creation_engine/README.md explicando que los builders y creators reciben puertos por inyección.

---

### Paso 7: main.py — registro de dependencias y eliminación de get_connection en routes

**Descripción:**
Centralizar en main.py (o en cada router vía Depends) la creación de los repositorios concretos. Asegurar que ninguna ruta ni caso de uso llame a get_connection() directamente; solo infrastructure/ y database/ lo usan. Revisar que todos los routers reciban el repositorio vía Depends. Opcional: definir funciones `get_bloque_repository()`, `get_particle_repository()`, etc., en main.py y re-exportarlas o inyectarlas en los routers según convención de FastAPI.

**Archivos a modificar/crear:**
- `backend/src/main.py` (no es obligatorio poner todos los get_*_repository aquí; cada dominio puede definir su propio Depends en su routes.py; si se prefiere un solo lugar, definir en main o en un módulo de “composition root” y pasar a los routers)
- Revisar todos los `domains/*/routes.py` para que no quede ningún `from src.database.connection import get_connection` ni uso de conn.

**Detalles de implementación:**
- En cada dominio, `routes.py` puede tener `def get_particle_repository(): return PostgresParticleRepository()` y `Depends(get_particle_repository)`. Así main.py no necesita conocer cada repositorio.
- Alternativa: en main.py, `app.dependency_overrides` o un módulo `backend/src/container.py` que registre factories y los routers los usen vía Depends. Para “versión completa” es suficiente que cada router declare su Depends localmente.

**Notas:**
- Verificar que los background tasks (celestial, temperature update) reciban los repositorios que necesiten (por ejemplo inyectando en el closure o en app.state).

---

### Paso 8: shared y limpieza final

**Descripción:**
Revisar `domains/shared/`: world_bloque_manager y world_bloque no deben usar get_connection() si pueden usar un puerto (ej. IBloqueRepository). Si se inyecta IBloqueRepository en quien use WorldBloqueManager, hacerlo. Eliminar cualquier import de get_connection o asyncpg de application/ y domain/ en todos los dominios. Eliminar o deprecar `service.py` de particles y celestial si toda la lógica pasó a casos de uso e infrastructure.

**Archivos a modificar/crear:**
- `backend/src/domains/shared/world_bloque_manager.py` (opcional: aceptar IBloqueRepository por inyección)
- `backend/src/domains/shared/world_bloque.py` (revisar dependencias)
- Eliminar o vaciar `backend/src/domains/particles/service.py` si ya no se usa (y actualizar celestial para que use solo IParticleRepository/casos de uso)
- `backend/src/domains/README.md` (actualizar: describir estructura Hexagonal+DDD por dominio)
- `backend/README.md` o `backend/src/README.md` (si existe; añadir sección “Arquitectura Hexagonal + DDD”)

**Notas:**
- **⚠️ READMEs:** Actualizar domains/README.md con el árbol domain/application/infrastructure y la regla “no asyncpg/get_connection en application ni domain”.

---

### Paso 9: Tests unitarios de casos de uso

**Descripción:**
Añadir tests que instancien los casos de uso con un repositorio mock (objeto que implementa la interfaz del puerto y devuelve datos fijos). Al menos un test por dominio: bloques, particles, characters, celestial, agrupaciones. Verificar que el caso de uso devuelve el DTO esperado y que lanza excepciones cuando el mock indica “no encontrado”.

**Archivos a modificar/crear:**
- `backend/tests/unit/domains/bloques/test_get_bloques.py` (o estructura equivalente)
- `backend/tests/unit/domains/particles/test_get_particles_by_viewport.py`
- `backend/tests/unit/domains/characters/test_get_character.py`
- `backend/tests/unit/domains/celestial/test_get_celestial_state.py`
- `backend/tests/unit/domains/agrupaciones/test_get_agrupaciones.py`
- Mocks: clases que implementen IBloqueRepository, IParticleRepository, etc., con métodos que retornen listas/dicts fijos.

**Detalles de implementación:**
- pytest + pytest-asyncio para tests async. Mock del repo: clase con los mismos métodos que el puerto, retornando valores de prueba. Llamar al caso de uso pasando el mock y comprobar que el resultado es el esperado.

**Notas:**
- No es obligatorio cubrir todos los casos de uso; al menos uno representativo por dominio demuestra el patrón.

---

### Paso 10: Documentación y verificación de API

**Descripción:**
Verificar que la API expuesta (OpenAPI /docs) no haya cambiado: mismos endpoints, mismos request/response. Actualizar cualquier documento de arquitectura en docs/ (por ejemplo docs/comparacion-hexagonal-ddd.md) indicando que la migración completa se implementó. Checklist final: no hay get_connection en routes ni en application/; world_creation_engine usa repos inyectados; READMEs actualizados.

**Archivos a modificar/crear:**
- `docs/comparacion-hexagonal-ddd.md` (añadir nota: “Migración completa implementada según JDG-066”)
- Ejecutar la app y revisar /docs; opcionalmente ejecutar una suite de tests de integración o smoke tests contra los endpoints.

**Notas:**
- Si existe un Postman o colección de requests, ejecutarla para regresión.

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-066_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- Los repositorios siguen usando el mismo pool (get_connection()); no hay cambio de rendimiento por la capa de abstracción. Mantener consultas parametrizadas y evitar N+1.

### Seguridad
- Validación de entrada sigue en Pydantic (schemas); casos de uso pueden validar reglas de negocio. SQL solo en infrastructure con parámetros.

### Casos Edge
- Bloque o recurso no encontrado: casos de uso lanzan ValueError/KeyError; routes traducen a HTTP 404. Viewport inválido: validar en caso de uso o en schema (ParticleViewportQuery.validate_ranges).
- Celestial y agrupaciones dependen de particles; asegurar que la inyección de IParticleRepository sea la misma instancia (o compatible) entre dominios.

### Compatibilidad
- API (URLs y JSON) debe permanecer idéntica. No cambiar nombres de campos ni rutas. Solo refactor interno.

---

## Patrones de Código a Usar

- **Hexagonal:** Puerto (ABC o Protocol) en application/ports/; Adaptador (clase concreta) en infrastructure/.
- **Repository:** Un puerto por agregado o recurso principal (IBloqueRepository, IParticleRepository, etc.); métodos que reflejen los flujos actuales (get_by_viewport, get_by_id, etc.).
- **Dependency Injection:** FastAPI Depends para inyectar el repositorio concreto en cada endpoint; el caso de uso recibe el repositorio por parámetro (inyectado desde la ruta).
- **Naming:** Interfaces con prefijo I (IParticleRepository) o sin I (ParticleRepository como abstracto); implementaciones PostgresParticleRepository, etc.

---

## Dependencias

### Nuevas Dependencias (si aplica)
- Ninguna; se usa solo la stdlib (abc.ABC) y FastAPI Depends.

### Variables de Entorno (si aplica)
- Sin cambios; POSTGRES_* siguen usadas por database/connection.py, usado desde infrastructure/.

---

## Archivos Principales Involucrados

1. `backend/src/domains/bloques/` — application/, infrastructure/, routes.py
2. `backend/src/domains/particles/` — application/, infrastructure/, routes.py, service.py (eliminar o vaciar)
3. `backend/src/domains/characters/` — application/, infrastructure/, routes.py
4. `backend/src/domains/celestial/` — application/, infrastructure/, routes.py, service.py
5. `backend/src/domains/agrupaciones/` — application/, infrastructure/, routes.py
6. `backend/src/world_creation_engine/` — builders/, creators/, terrain_builder.py
7. `backend/src/main.py` — revisión de dependencias
8. `backend/src/domains/shared/` — world_bloque_manager, world_bloque (opcional inyección)
9. `backend/tests/unit/domains/` — tests por dominio
10. `backend/src/database/seed_*.py` — uso de repositorios al instanciar creators/builders

---

## Testing

### Tests a Crear/Modificar
- Unit: tests/unit/domains/<dominio>/test_<caso_de_uso>.py con mock del repositorio.
- Integration (opcional): tests que llamen a la API real y comprueben que la respuesta coincide con la actual.

### Escenarios de Prueba
1. Caso de uso con repositorio mock retorna DTO correcto.
2. Caso de uso con mock “not found” lanza excepción; route devuelve 404.
3. End-to-end: GET /api/v1/bloques, GET /api/v1/bloques/{id}/particles, etc., misma respuesta que antes del refactor.

---

## Deployment

### Orden de Deployment
1. Backend: rebuild de imagen Docker y restart del contenedor.
2. No hay migraciones de BD; no tocar PostgreSQL schema.
3. Verificar /health y /docs; ejecutar smoke tests de endpoints.

### Verificación Post-Deployment
- [ ] GET /api/v1/bloques devuelve mismo formato.
- [ ] GET /api/v1/bloques/{id}/particles y particle-types igual que antes.
- [ ] GET /api/v1/celestial/state igual.
- [ ] Crear personaje y obtener modelo (characters) sigue funcionando.
- [ ] Logs sin errores de importación o inyección.

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. La migración es grande; se puede dividir en PRs por dominio (Paso 1 + 7 parcial, luego Paso 2, etc.) si se prefiere, manteniendo la API estable en cada PR.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`.
