# JDG-067 - Refactorización del frontend a la estructura elegida (Hexagonal + ECS por dominios)

**Ejecutado (2026-02-02):** Pasos 1–9 y limpieza parcial. Paso 9: ECS reestructurado por dominios (core/, components/, domains/animation|combat|input|physics|collision|render|weapon, factories/). systems/index re-exporta desde domains. Paso 10 (eliminar api/, interfaces/, utils/ cuando se migren) pendiente.

---

## Descripción de la Tarea

Refactorizar el frontend para que coincida con la estructura documentada en `docs/frontend-estructura-elegida.md`: capa Hexagonal (ports + adapters), domain, application (casos de uso), driving (game loop, input, UI), rendering (scene, loaders, ecs, terrain, world, optimizations, geometries, renderers), state, config, shared. Dentro de rendering/ecs/, adoptar la estructura por dominios (core, components, domains/animation|combat|input|physics|collision|render|weapon, factories) con loaders fuera del ECS en rendering/loaders/.

**Comportamiento actual:**
- api/, core/, ecs/, terrain/, world/, interfaces/, state/, config/, utils/ en raíz de src. App y terrain llaman al API directamente. ECS tiene conditions/, states/, combos/, models/ en la raíz del ECS.

**Comportamiento esperado:**
- domain/, application/, ports/, adapters/, driving/, rendering/ (loaders, ecs, scene, terrain, world, optimizations, geometries, renderers), state/, config/, shared/. App recibe ports inyectados; casos de uso orquestan; TerrainManager y ECS reciben datos o ports. ECS bajo rendering/ecs/ con core, components, domains por feature, factories; loaders en rendering/loaders/.

## Criterios de Aceptación

1. ❌ Existe domain/ con world, particles, character (modelos puros).
2. ❌ Existen ports/ y adapters/http/; App y casos de uso usan ports inyectados.
3. ❌ Existen casos de uso en application/ (loadWorld, spawnPlayer, syncCelestial).
4. ❌ Todo lo 3D bajo rendering/; TerrainManager recibe port inyectado; no existe terrain/api/.
5. ❌ ECS en rendering/ecs/ con core/, components/, domains/, factories/; loaders en rendering/loaders/.
6. ❌ Game loop y InputManager en driving/game/ y driving/input/; paneles en driving/ui/panels/.
7. ❌ Utilidades puras en shared/; config y state en raíz.
8. ❌ El juego arranca y funciona sin regresiones.

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- Frontend: HTML5, JavaScript ES6+, Three.js, módulos ES6
- Sin cambios de frameworks; solo reorganización de carpetas, imports y extracción de capas

## Pasos de Implementación

### Paso 1: Crear domain/, ports/ y adapters/http/

**Descripción:**
Definir la capa de dominio (modelos puros sin Three ni fetch), los contratos (ports) y las implementaciones HTTP (adapters). Extraer de api/ los endpoints a adapters/http/ y definir en ports/ las interfaces que consumen application y App.

**Archivos a modificar/crear:**
- `frontend/src/domain/world/` (dimension.js, viewport.js según doc)
- `frontend/src/domain/particles/` (particle-type.js, particle.js si aplica)
- `frontend/src/domain/character/` (character-model.js)
- `frontend/src/ports/world-api.js`, `particles-api.js`, `characters-api.js`, `celestial-api.js`, `agrupaciones-api.js`
- `frontend/src/adapters/http/api-client.js` (desde api/client.js)
- `frontend/src/adapters/http/http-bloques.js`, `http-particles.js`, `http-characters.js`, `http-celestial.js`, `http-agrupaciones.js` (desde api/endpoints/)

**Detalles de implementación:**
- domain: objetos o clases con la forma que devuelve el backend; sin importar Three, fetch ni DOM.
- ports: funciones o objetos con métodos getDimensions(), getParticles(), getCharacter(), etc.; solo firma, sin implementación.
- adapters: implementaciones que llaman a api/client y endpoints; exportan objetos que cumplen los ports.

**Notas:**
- Mantener api/ temporalmente y hacer que adapters/http reutilice la misma lógica (o mover la lógica a adapters y que api/ re-exporte desde adapters hasta actualizar todos los consumidores).
- **⚠️ READMEs:** Añadir README.md en domain/, ports/, adapters/ explicando su rol según docs/frontend-estructura-elegida.md.

---

### Paso 2: Crear application/ (casos de uso)

**Descripción:**
Crear los casos de uso loadWorld, spawnPlayer y syncCelestial que orquestan ports y store (y cuando toque, ecs y scene). Reciben ports y store por parámetro; no conocen adapters ni URLs.

**Archivos a modificar/crear:**
- `frontend/src/application/load-world.js` (usa worldApi, particlesApi; actualiza store; devuelve datos para terrain)
- `frontend/src/application/spawn-player.js` (usa charactersApi, store; llama a PlayerFactory con ecs, scene, loaders; devuelve entityId)
- `frontend/src/application/sync-celestial.js` (usa celestialApi; actualiza store o devuelve estado celestial)
- `frontend/src/application/index.js` (re-exportar casos de uso)

**Detalles de implementación:**
- Extraer la lógica que hoy está en app.js relacionada con “cargar mundo”, “spawnear jugador” y “sincronizar celestial” a estas funciones.
- Firma sugerida: loadWorld(ports, store), spawnPlayer(ports, store, ecs, scene, loaders), syncCelestial(ports, store).

**Notas:**
- **⚠️ READMEs:** Añadir README.md en application/ explicando qué hace cada caso de uso y quién los llama.

---

### Paso 3: Crear driving/game/, driving/input/ y driving/ui/

**Descripción:**
Mover el game loop y bootstrap a driving/game/; mover InputManager a driving/input/; mover interfaces (base-interface, debug-panel, test-interface) a driving/ui/panels/. Mantener la misma lógica; solo cambiar ubicación e imports.

**Archivos a modificar/crear:**
- `frontend/src/driving/game/game-bootstrap.js` (crea ports, store, App; inyecta ports en App)
- `frontend/src/driving/game/game-loop.js` (requestAnimationFrame; llama ecs.update(dt), terrain.update(dt), world, etc.)
- `frontend/src/driving/input/input-manager.js` (mover desde core/input/input-manager.js)
- `frontend/src/driving/ui/base-interface.js` (mover desde interfaces/base-interface.js)
- `frontend/src/driving/ui/panels/debug-panel.js`, `test-interface.js`, `debug-interface.js` (mover desde interfaces/)

**Detalles de implementación:**
- game-bootstrap: instancia ApiClient, crea adapters HTTP, crea objeto ports, crea store, crea App(ports, store) y opcionalmente scene, loaders, ecs, terrain, world, inputManager; devuelve app.
- game-loop: recibe app o referencias a ecs, terrain, world; en cada frame llama app.update(dt) o ecs.update(dt), terrain.update(dt), etc.
- main.js debe llamar a bootstrap (o a App directamente si el bootstrap está dentro de App) y luego app.start().

**Notas:**
- **⚠️ READMEs:** Añadir README.md en driving/ (y opcionalmente en driving/game/, driving/input/, driving/ui/) explicando responsabilidades.

---

### Paso 4: Crear rendering/ y mover scene, core de escena, optimizations, geometries, renderers

**Descripción:**
Crear la carpeta rendering/ y mover todo lo que es “3D”: scene (Scene3D, cámara, luces, renderer desde core/), optimizations (desde core/optimizations/), geometries (desde core/geometries/), renderers (desde core/renderers/), performance (desde core/performance/). Mantener los mismos archivos; solo cambiar rutas e imports.

**Archivos a modificar/crear:**
- `frontend/src/rendering/scene/scene.js`, `camera.js`, `controls.js`, `lights.js`, `renderer.js`, `helpers.js` (desde core/)
- `frontend/src/rendering/optimizations/` (frame-scheduler, frustum-culling, instancing-manager, lod-manager, object-pool, render-batcher, spatial-partition desde core/optimizations/)
- `frontend/src/rendering/geometries/registry.js` (desde core/geometries/)
- `frontend/src/rendering/renderers/base-renderer.js` (desde core/renderers/)
- `frontend/src/rendering/performance/performance-manager.js` (desde core/performance/)

**Detalles de implementación:**
- Copiar o mover archivos; actualizar imports internos para que apunten a la nueva ruta (p. ej. desde rendering/scene/ importar Three, no core/).
- app.js (o bootstrap) debe importar desde rendering/scene/, rendering/optimizations/, etc., en lugar de core/.

**Notas:**
- Eliminar o vaciar core/ solo cuando todos los consumidores apunten a rendering/. Puede hacerse en el mismo paso o en un paso de limpieza posterior.
- **⚠️ READMEs:** Añadir README.md en rendering/ y en rendering/scene/, rendering/optimizations/, etc.

---

### Paso 5: Crear rendering/loaders/ y mover ecs/models/ fuera del ECS

**Descripción:**
Crear rendering/loaders/ y mover ahí todo lo que hoy está en ecs/models/: model-loader.js, model-cache.js, model-utils.js, bones-utils.js, vertex-groups-utils.js. Actualizar imports en ecs (PlayerFactory, RenderSystem, WeaponEquipSystem, etc.) para que importen desde rendering/loaders/ (o desde una ruta relativa que resuelva a loaders).

**Archivos a modificar/crear:**
- `frontend/src/rendering/loaders/model-loader.js`, `model-cache.js`, `model-utils.js`, `bones-utils.js`, `vertex-groups-utils.js` (mover desde ecs/models/)
- `frontend/src/rendering/loaders/index.js` (re-exportar)
- Actualizar en ecs: factories/player-factory.js, systems/render-system.js, weapon-equip-system.js, helpers/weapon/*, y cualquier otro que importe desde ecs/models/

**Detalles de implementación:**
- Las factories y sistemas que cargan modelos deben recibir “loaders” por parámetro o importar desde `../../rendering/loaders/` (o la ruta que corresponda según dónde quede ecs). Si app.js crea loaders y los inyecta en PlayerFactory, las factories no importan loaders directamente; si se prefiere import directo, usar la ruta a rendering/loaders/.

**Notas:**
- **⚠️ READMEs:** Añadir README.md en rendering/loaders/ indicando que es infraestructura de carga de assets 3D, no “modelos de dominio”.

---

### Paso 6: Mover ecs/ a rendering/ecs/ y terrain/ a rendering/terrain/, world/ a rendering/world/

**Descripción:**
Mover la carpeta ecs/ completa a frontend/src/rendering/ecs/. Mover terrain/ a frontend/src/rendering/terrain/ (sin terrain/api/; TerrainManager recibirá port inyectado). Mover world/ a frontend/src/rendering/world/. Actualizar todos los imports en el proyecto (app.js, main.js, bootstrap, interfaces, etc.) para que apunten a rendering/ecs/, rendering/terrain/, rendering/world/.

**Archivos a modificar/crear:**
- Mover `frontend/src/ecs/` → `frontend/src/rendering/ecs/` (estructura interna igual por ahora; models/ ya no existe, está en loaders/)
- Mover `frontend/src/terrain/` → `frontend/src/rendering/terrain/`; eliminar `terrain/api/` (bloques-client, particles-client) y hacer que TerrainManager reciba en constructor (o init) un port `particlesApi` (y opcionalmente worldApi) inyectado. App o bootstrap crea TerrainManager pasando ports.particlesApi.
- Mover `frontend/src/world/` → `frontend/src/rendering/world/`
- Actualizar app.js, main.js, driving/game/, driving/ui/, y cualquier archivo que importe desde 'ecs/', 'terrain/', 'world/' o rutas relativas a ellos.

**Detalles de implementación:**
- En TerrainManager: quitar referencias a particles-client o bloques-client; en su lugar recibir un objeto con getParticles(bloqueId, viewport), getDimensions(), etc. (el port). Quien crea TerrainManager (App o bootstrap) pasa ports.particlesApi y ports.worldApi.
- Si loadWorld ya obtiene partículas y dimensiones y actualiza el store, App puede pasar esos datos a TerrainManager.loadDimension(dimension, particles) en lugar de inyectar el port; la doc recomienda inyectar el port para que TerrainManager pueda pedir partículas por viewport al moverse la cámara.

**Notas:**
- **⚠️ READMEs:** Actualizar READMEs de rendering/, rendering/ecs/, rendering/terrain/, rendering/world/.

---

### Paso 7: Crear shared/ y mover utils (math, geometry, colors, helpers)

**Descripción:**
Crear la carpeta shared/ y mover las utilidades puras que hoy están en utils/: math.js, geometry.js, colors.js, helpers.js (y opcionalmente cursor-manager.js o dejarlo en driving/input). Opcional: utils/config.js puede moverse a config/ o quedarse en shared/. weapon-attachment.js y weapon-utils.js: si son solo cálculos, en shared/; si dependen del ECS, pueden quedarse en rendering/ecs/helpers/weapon/. Actualizar todos los imports.

**Archivos a modificar/crear:**
- `frontend/src/shared/math.js`, `geometry.js`, `colors.js`, `helpers.js` (mover desde utils/)
- `frontend/src/shared/index.js` (re-exportar)
- Opcional: `frontend/src/shared/cursor-manager.js` o mover a driving/input/
- Actualizar imports en domain, application, rendering, adapters que usen utils/math, utils/geometry, etc.

**Notas:**
- **⚠️ READMEs:** Añadir README.md en shared/ indicando que son utilidades puras sin dependencias de state ni driving.

---

### Paso 8: Refactorizar app.js y main.js para usar ports, application y driving

**Descripción:**
Refactorizar app.js para que reciba ports y store por constructor (o setter); no debe importar adapters ni api/. Debe importar casos de uso (loadWorld, spawnPlayer, syncCelestial) y módulos de rendering (scene, ecs, terrain, world, loaders). En start() o loadDemo(): llamar loadWorld(ports, store), luego inicializar TerrainManager con datos o con port inyectado, luego spawnPlayer(ports, store, ecs, scene, loaders), luego arrancar game loop (driving/game/). main.js debe crear el contenedor, llamar al bootstrap (que crea ports, store, App) y luego app.start().

**Archivos a modificar/crear:**
- `frontend/src/app.js` (refactor: recibir ports, store; crear scene, loaders, ecs, terrain, world, inputManager; registrar sistemas en ecs; start() llama loadWorld, spawnPlayer, game loop)
- `frontend/src/main.js` (llamar bootstrap o App; app.start())
- `frontend/src/driving/game/game-bootstrap.js` (crear adapters, ports, store, App(ports, store), pasar loaders/ecs/scene/terrain/world/inputManager a App o crear dentro de App; devolver app)

**Detalles de implementación:**
- App no debe tener `new ApiClient()` ni importar api/endpoints/; eso lo hace el bootstrap, que crea adapters y los agrupa en un objeto ports.
- App.start() llama await loadWorld(ports, store) (o loadWorld síncrono si ya lo es), luego inicializa TerrainManager (con ports.particlesApi inyectado o con datos devueltos por loadWorld), luego spawnPlayer(ports, store, ecs, scene, loaders), luego registra el game loop con requestAnimationFrame.

**Notas:**
- Verificar que no queden imports de api/ o core/ en app.js tras este paso.

---

### Paso 9: Reestructurar rendering/ecs/ por dominios (core, components, domains, factories)

**Descripción:**
Reestructurar el interior de rendering/ecs/ para seguir la estructura elegida: core/ (world.js o manager.js, system.js), components/ (igual que ahora), domains/animation (systems/, state-machine/ con conditions/, helpers/), domains/combat (systems/, combos/, helpers/), domains/input, physics, collision, render, weapon (cada uno con systems/ y helpers/), factories/ (igual). Mover archivos según el árbol de frontend-estructura-elegida.md; actualizar todos los imports dentro del ECS y desde fuera (app.js, driving, etc.).

**Archivos a modificar/crear:**
- `frontend/src/rendering/ecs/core/world.js` (renombrar o copiar manager.js), `system.js` (mover desde ecs/system.js)
- `frontend/src/rendering/ecs/components/` (mantener; ya está en la raíz del ecs)
- `frontend/src/rendering/ecs/domains/animation/systems/` (animation-state-system.js, animation-mixer-system.js), `domains/animation/state-machine/` (state-registry.js, animation-state.js, conditions/*, condition-factory.js), `domains/animation/helpers/`
- `frontend/src/rendering/ecs/domains/combat/systems/`, `domains/combat/combos/`, `domains/combat/helpers/`
- `frontend/src/rendering/ecs/domains/input/systems/`, `domains/input/helpers/`
- `frontend/src/rendering/ecs/domains/physics/systems/`, `domains/physics/helpers/`
- `frontend/src/rendering/ecs/domains/collision/systems/`, `domains/collision/helpers/`
- `frontend/src/rendering/ecs/domains/render/systems/`
- `frontend/src/rendering/ecs/domains/weapon/systems/`, `domains/weapon/helpers/`
- `frontend/src/rendering/ecs/factories/` (mantener en raíz de ecs)
- Actualizar ecs/index.js o puntos de entrada para que exporten desde core/, components/, domains/*, factories/. Actualizar app.js o bootstrap para que registre sistemas importando desde domains/*/systems/*.

**Detalles de implementación:**
- Cada sistema que hoy está en ecs/systems/*.js se mueve a domains/<dominio>/systems/.
- conditions/ y states/ se mueven a domains/animation/state-machine/ (conditions como subcarpeta).
- combos/ se mueve a domains/combat/combos/.
- helpers/animation/, helpers/combat/, etc. se mueven a domains/<dominio>/helpers/.
- Las importaciones entre state-registry, condition-factory, AnimationStateSystem deben seguir funcionando (mismo dominio, rutas relativas).
- core/world.js debe exportar la clase que hoy se llama ECSManager o Manager; system.js la clase base System. Los sistemas extienden System y reciben ecs (world) por setECSManager o por constructor.

**Notas:**
- Este paso es el más laborioso; conviene hacerlo en un PR separado o en sub-pasos (primero solo animation y combat como dominios, luego el resto).
- **⚠️ READMEs:** Actualizar rendering/ecs/README.md con la nueva estructura (core, components, domains, factories) y reglas de dependencias.

---

### Paso 10: Limpieza: eliminar core/, api/, interfaces/, utils/ y referencias obsoletas

**Descripción:**
Eliminar las carpetas y archivos que ya no se usan: core/ (todo movido a rendering/ o driving/input/), api/ (reemplazado por adapters/http/ y ports/), interfaces/ (movido a driving/ui/panels/), utils/ (movido a shared/ o config/). Eliminar scene.js de la raíz si era re-export. Actualizar dev-exposure.js, types.js y cualquier otro archivo que importe rutas antiguas. Verificar que no queden imports rotos.

**Archivos a modificar/eliminar:**
- Eliminar `frontend/src/core/` (si ya está vacío o todo movido)
- Eliminar `frontend/src/api/` (adapters y ports ya existen)
- Eliminar `frontend/src/interfaces/` (contenido en driving/ui/)
- Eliminar `frontend/src/utils/` (contenido en shared/ o config/)
- `frontend/src/scene.js` (eliminar o re-export desde rendering/scene/)
- `frontend/src/dev-exposure.js` (actualizar imports si exponen App o rutas)
- `frontend/src/types.js` (mantener en raíz o mover a domain según doc)
- Revisar README.md de frontend/src y actualizar árbol de carpetas

**Notas:**
- Ejecutar el proyecto (npm run dev o equivalente) y abrir el juego en el navegador; verificar que carga mundo, spawnea jugador, movimiento, animaciones, combate, F3, F6, terreno y cielo sin errores en consola.

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-067_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git
- No editar manualmente a menos que sea estrictamente necesario

---

## Consideraciones Técnicas

### Performance
- No se esperan cambios de rendimiento; solo reorganización. Evitar imports circulares al introducir domain/application/ports.

### Seguridad
- No aplica cambio de seguridad; mismos datos y mismos endpoints.

### Casos Edge
- Imports circulares: mantener dependencias unidireccionales (domain ← application ← app; ports ← adapters; rendering no importa application).
- Rutas relativas al pasar de ecs/ a rendering/ecs/domains/ pueden ser más profundas; verificar que loaders se resuelvan desde factories y sistemas.

### Compatibilidad
- Compatibilidad con el mismo backend y la misma API; solo cambia la organización del frontend.

## Patrones de Código a Usar

- **Frontend (Hexagonal):** Ports = contratos (objetos con métodos); Adapters = implementaciones HTTP; Application = casos de uso que reciben ports y store; App = orquestador que crea rendering y llama casos de uso.
- **ECS:** core = world + system base; components = datos puros; domains = systems + state-machine/combos/helpers por feature; factories = creación de entidades desde DTOs.
- **Driving:** game loop solo llama a update(dt); no obtiene datos ni crea entidades. InputManager inyectado al ECS.

## Dependencias

### Nuevas Dependencias
Ninguna; mismo stack (JavaScript ES6+, Three.js).

### Variables de Entorno
Sin cambios; mismo API_BASE_URL o config que use el adapter.

## Archivos Principales Involucrados

1. `frontend/src/main.js`, `app.js` — Puntos de entrada y orquestador
2. `frontend/src/domain/*`, `ports/*`, `adapters/http/*`, `application/*` — Nuevas capas
3. `frontend/src/driving/game/*`, `driving/input/*`, `driving/ui/*` — Game loop, input, paneles
4. `frontend/src/rendering/*` — scene, loaders, ecs, terrain, world, optimizations, geometries, renderers
5. `frontend/src/state/*`, `config/*`, `shared/*` — Sin cambio de responsabilidad; posible reubicación de utils a shared

## Testing

### Escenarios de Prueba
1. Arranque: main → bootstrap → app.start() → carga mundo y spawnea jugador sin errores.
2. Gameplay: movimiento WASD, saltar, animaciones, combate, colisiones, cámara sigue al jugador.
3. Terrain: partículas visibles y actualización al mover cámara (viewport).
4. F3 y F6: paneles abren y muestran métricas e inspector de entidades.
5. Cielo: sol/luna se renderizan y opcionalmente syncCelestial actualiza estado.

### Casos Edge
- Sin conexión al backend: loadWorld o spawnPlayer pueden fallar; manejar error y mostrar en UI o consola sin romper el loop.

## Deployment

### Orden de Deployment
1. Frontend: desplegar nuevos archivos estáticos (estructura de carpetas cambia; asegurar que el bundler o servidor sirva las nuevas rutas).
2. Verificar en ambiente local que el juego arranca y funciona.

### Verificación Post-Deployment
- [ ] Abrir el juego en el navegador
- [ ] Verificar que carga mundo y jugador
- [ ] Verificar movimiento, animaciones, combate, F3, F6
- [ ] Verificar que no hay 404 en recursos ni errores en consola

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. La Fase 1 (pasos 1–3 y 8) puede ser un PR; la Fase 2 (pasos 4–7 y 10) otro PR; la Fase 3 (paso 9, reestructuración ECS por dominios) puede ser un tercer PR para facilitar la revisión.

**⚠️ IMPORTANTE:** El último paso del plan SIEMPRE debe ser "Generar Descripción del Pull Request" usando `@pr-description.mdc`.
