# JDG-068 - Completar Hexagonal al 100%: ports formales, domain centralizado e inyección TerrainManager

## Descripción de la Tarea

Completar la alineación del frontend con la arquitectura hexagonal documentada: (1) formalizar contratos en `ports/`, (2) centralizar modelos puros en `domain/`, (3) confirmar y documentar que TerrainManager recibe el port de partículas inyectado.

**Comportamiento actual:**
- `ports/` tiene solo README con descripción en prosa; no hay contratos codificados.
- `domain/` tiene modelos parciales; puede haber tipos de dominio repartidos en config/rendering.
- TerrainManager recibe `particlesApi` y `bloquesApi` por constructor desde App, pero no está documentado como requisito arquitectónico.

**Comportamiento esperado:**
- Contratos formales en `ports/` (JSDoc o módulos) que definan la forma de cada API; adapters los implementan.
- Modelos de dominio centralizados en `domain/`; sin dependencias de Three.js, fetch ni DOM.
- TerrainManager documentado como consumidor de ports inyectados; flujo bootstrap → App → TerrainManager verificado.

## Criterios de Aceptación

1. ❌ Existe al menos un mecanismo formal de contrato para los ports (JSDoc o módulos en `ports/`).
2. ❌ Adapters HTTP documentan o cumplen los contratos de `ports/`.
3. ❌ Modelos de dominio usados por aplicación/rendering están en `domain/` o reexportados desde ahí.
4. ❌ Está documentado y verificado que TerrainManager recibe el port de partículas inyectado.

## Contexto del Proyecto

### Proyecto(s) Afectado(s)
- [x] Frontend (Three.js, estructura hexagonal)
- [ ] Backend (FastAPI)
- [ ] Base de Datos (PostgreSQL)
- [ ] Docker/Infraestructura

### Tecnologías Involucradas
- JavaScript ES6+, módulos ES
- JSDoc para interfaces/contratos
- Estructura: `frontend/src/ports/`, `frontend/src/domain/`, `frontend/src/adapters/http/`, `frontend/src/rendering/terrain/`, `frontend/src/driving/game/`

## Pasos de Implementación

### Paso 1: Confirmar y documentar inyección del port de partículas en TerrainManager

**Descripción:**
Verificar en código que TerrainManager recibe `particlesApi` (y `bloquesApi`) por constructor desde App, que a su vez los obtiene del objeto `ports` creado en `game-bootstrap.js`. Documentar este flujo en el constructor de TerrainManager y, si se desea, en `rendering/terrain/README.md`.

**Archivos a modificar/crear:**
- `frontend/src/rendering/terrain/manager.js` – JSDoc del constructor: parámetros `particlesApi` y `bloquesApi` como ports inyectados; opcional comentario que indique “No instanciar adapters aquí”.
- `frontend/src/rendering/terrain/README.md` – Sección breve: “TerrainManager recibe los ports de partículas y bloques inyectados por constructor (App → TerrainManager); el bootstrap crea los adapters y los inyecta en App”.
- `frontend/src/app.js` – Opcional: comentario junto a `new TerrainManager(...)` indicando que se inyectan ports.

**Detalles de implementación:**
```javascript
// manager.js - Ejemplo de JSDoc en constructor
/**
 * @param {THREE.Scene} scene
 * @param {ParticlesPort} particlesApi - Port de partículas (inyectado; no instanciar adapter aquí)
 * @param {BloquesPort} bloquesApi - Port de bloques/dimensiones (inyectado)
 * @param {GeometryRegistry} geometryRegistry
 * @param {PerformanceManager|null} performanceManager
 */
constructor(scene, particlesApi, bloquesApi, geometryRegistry, performanceManager = null) {
```

**Notas:**
- No cambiar la firma del constructor ni el comportamiento.
- **⚠️ READMEs:** Actualizar `rendering/terrain/README.md` con la sección de inyección de ports.

---

### Paso 2: Definir contratos formales en `ports/`

**Descripción:**
Crear en `frontend/src/ports/` definiciones de contrato para cada API usada por App/TerrainManager/casos de uso. Opción A: un único archivo `ports/contracts.js` (o `ports/index.js`) que exporte JSDoc `@typedef` para cada port (ParticlesPort, BloquesPort, WorldPort, CharactersPort, CelestialPort, AgrupacionesPort). Opción B: un archivo por port (ej. `particles-port.js`, `bloques-port.js`) que exporte el contrato. Los contratos deben describir métodos, parámetros y retornos esperados.

**Archivos a modificar/crear:**
- `frontend/src/ports/contracts.js` (o `particles-port.js`, `bloques-port.js`, etc.) – Definir con JSDoc la forma de cada port.
- `frontend/src/ports/README.md` – Actualizar: indicar que los contratos están en `contracts.js` (o en los archivos por port) y que los adapters en `adapters/http/` los implementan.

**Detalles de implementación:**
```javascript
// ports/contracts.js (ejemplo)
/**
 * @typedef {Object} ParticlesPort
 * @property {function(string, import('../domain/world/viewport.js').Viewport): Promise<{particles: Array}>} getParticles
 * @property {function(string, import('../domain/world/viewport.js').Viewport): Promise<Object>} getParticleTypes
 */
// Repetir para BloquesPort (getDimensions, getDimension, ...), CharactersPort, etc.
export const PARTICLES_PORT_METHODS = ['getParticles', 'getParticleTypes'];
```

**Notas:**
- Ajustar rutas de import en JSDoc según la estructura real (viewport, dimension, etc.).
- **⚠️ READMEs:** Actualizar `ports/README.md` con la ubicación de los contratos y la lista de ports.

---

### Paso 3: Documentar conformidad de adapters con los contratos

**Descripción:**
En cada adapter HTTP (`http-particles.js`, `http-bloques.js`, `http-characters.js`, `http-celestial.js`, `http-agrupaciones.js`), añadir en la clase o en el archivo un comentario JSDoc que referencie el contrato que implementa (ej. `@implements {ParticlesPort}` o “Implementa el contrato ParticlesPort definido en ports/contracts.js”). No es obligatorio cambiar firmas si ya coinciden; solo documentar.

**Archivos a modificar/crear:**
- `frontend/src/adapters/http/http-particles.js`
- `frontend/src/adapters/http/http-bloques.js`
- `frontend/src/adapters/http/http-characters.js`
- `frontend/src/adapters/http/http-celestial.js`
- `frontend/src/adapters/http/http-agrupaciones.js`
- `frontend/src/adapters/README.md` – Mencionar que los adapters HTTP implementan los contratos de `ports/`.

**Detalles de implementación:**
En la clase, por ejemplo:
```javascript
/**
 * Implementación HTTP del port de partículas.
 * @implements {ParticlesPort}
 */
export class HttpParticlesApi { ... }
```

**Notas:**
- Si JSDoc no soporta `@implements` con typedef en el proyecto, usar un comentario de texto que referencie `ports/README.md` o `ports/contracts.js`.

---

### Paso 4: Revisar y centralizar modelos en `domain/`

**Descripción:**
Revisar qué tipos se usan como “modelo de dominio” en application (load-world, spawn-player, etc.), en rendering/terrain y en adapters (mapeo JSON → objeto). Asegurar que esos modelos estén definidos o reexportados desde `frontend/src/domain/` (world/, particles/, character/). Si hay tipos que hoy viven en config o en otros módulos pero representan entidades de dominio, moverlos a domain o reexportarlos desde domain; actualizar imports en los consumidores.

**Archivos a modificar/crear:**
- `frontend/src/domain/` – Añadir o mover modelos que falten (ej. Particle, Dimension, Viewport ya existen; verificar que no haya duplicados en config).
- `frontend/src/domain/README.md` – Actualizar lista de modelos y su uso (application, adapters, rendering).
- Archivos que importen tipos de dominio desde fuera de `domain/` – Cambiar imports a `domain/...`.

**Detalles de implementación:**
- Listar en domain/README.md: world (Dimension, Viewport), particles (ParticleType, y si existe Particle), character (CharacterModel).
- Buscar en el repo referencias a “Dimension”, “Viewport”, “ParticleType”, “CharacterModel” y asegurar que el origen canónico sea `domain/`.

**Notas:**
- Mantener domain sin dependencias de Three.js, fetch ni DOM.
- **⚠️ READMEs:** Actualizar `domain/README.md` con la lista final de modelos y responsabilidades.

---

### Paso Final: Generar Descripción del Pull Request

**Descripción:**
Una vez completados todos los pasos anteriores y verificada la implementación, genera la descripción completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `JDG-068_pr-description_[FECHA-HORA].md` en `/instructions/prs/` (con fecha y hora obtenida de `Get-Date -Format "yyyy-MM-dd_HH-mm-ss"`)
- El archivo contendrá una descripción completa del PR lista para copiar y pegar en Git
- Incluirá: título, resumen, motivación, cambios técnicos, testing, referencias y riesgos

**Notas:**
- Este paso se ejecuta DESPUÉS de completar toda la implementación
- La descripción se genera automáticamente basándose en los cambios realizados
- El desarrollador solo necesita copiar y pegar el contenido en Git

---

## Consideraciones Técnicas

### Performance
- No se esperan cambios de rendimiento; solo estructura y documentación.

### Seguridad
- N/A para este ticket.

### Casos Edge
- Adapters con métodos extra no descritos en el contrato: documentarlos en el contrato o en el README.
- Modelos compartidos entre UI y dominio: mantener en domain solo los modelos “puros”; los que dependan de Three.js pueden quedarse en rendering con referencia al modelo de dominio si aplica.

### Compatibilidad
- No cambiar firmas públicas de TerrainManager ni de los adapters; solo añadir documentación y, en domain, centralizar imports.

## Patrones de Código a Usar

- **Ports:** Contratos como tipos JSDoc o módulos que describan la interfaz; sin implementación.
- **Adapters:** Implementaciones concretas (HTTP) que cumplen el contrato; inyectadas en App desde bootstrap.
- **Domain:** Modelos y value objects sin dependencias de infraestructura o framework.

## Dependencias

- JDG-067 completado (frontend ya refactorizado a Hexagonal + ECS).

## Archivos Principales Involucrados

1. `frontend/src/ports/` – Contratos (nuevos o actualizados).
2. `frontend/src/domain/` – Modelos centralizados y README.
3. `frontend/src/adapters/http/*.js` – Documentación de conformidad con ports.
4. `frontend/src/rendering/terrain/manager.js` – Documentación de inyección de ports.
5. `frontend/src/driving/game/game-bootstrap.js` – Origen de los ports (sin cambios funcionales necesarios).

## Testing

### Escenarios de Prueba
1. Cargar demo: mundo, terreno y partículas se cargan correctamente.
2. Spawn de personaje y movimiento: sin regresiones.
3. Revisión manual: TerrainManager no importa ni instancia adapters; App recibe ports desde bootstrap y los pasa a TerrainManager.

### Tests a Crear/Modificar
- No se requieren tests unitarios nuevos para este ticket de estructura/documentación; los existentes deben seguir pasando.

## Deployment

- Sin cambios de infraestructura; solo código frontend. Rebuild/refresh estático si aplica.

### Verificación Post-Deployment
- [ ] Juego carga y terreno se actualiza con partículas.
- [ ] No hay errores en consola por imports rotos (domain/ports).

---

**Nota Final:** Ejecutar los pasos en orden; verificar cada paso antes de continuar. El último paso siempre es generar la descripción del PR con `@pr-description.mdc`.
