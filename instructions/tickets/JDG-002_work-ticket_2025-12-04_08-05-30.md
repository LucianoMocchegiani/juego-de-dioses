# JDG-002 - Mover estilos de partículas a Base de Datos

## Tipo
- [x] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

Los estilos visuales (colores, materiales, propiedades visuales) de las partículas están actualmente hardcodeados en el frontend (`frontend/src/scene.js`, líneas 76-84). Esto limita significativamente la capacidad de la IA para crear y modificar contenido dinámicamente, ya que la IA no tiene acceso al frontend para modificar estos estilos.

**Razón principal**: La IA necesita poder crear nuevos tipos de partículas con estilos personalizados y modificar estilos existentes sin requerir cambios en el código del frontend. Los estilos deben estar en los datos (base de datos) que la IA puede modificar.

**Contexto técnico actual**:
- Backend: Python/FastAPI + PostgreSQL
- Frontend: Three.js
- Sistema: MMO/Action RPG con mundo persistente
- Estado actual: Colores hardcodeados en `scene.js` (líneas 76-84)
- Base de datos ya tiene campo `color_base` en `tipos_particulas` pero no se usa

### Comportamiento Actual

- Los colores de las partículas están definidos en un objeto `colorMap` hardcodeado en `frontend/src/scene.js`
- El mapa incluye: hierba, madera, hojas, tierra, piedra, agua, aire
- Cada tipo de partícula tiene un color hexadecimal fijo
- Las propiedades de material (metalness, roughness) están hardcodeadas
- El campo `color_base` en la tabla `tipos_particulas` existe pero no se utiliza
- La IA no puede modificar estilos sin cambios en el código frontend
- No hay flexibilidad para crear variaciones dinámicas (ej: "hierba seca" vs "hierba verde")
- Múltiples frontends no pueden interpretar estilos de manera independiente

### Comportamiento Esperado

- Los estilos (colores, materiales, propiedades visuales) están almacenados en la base de datos en la tabla `tipos_particulas`
- Los estilos se incluyen en las respuestas del backend cuando se consultan partículas (usando JOIN para evitar queries adicionales)
- El frontend cachea los estilos y los utiliza para renderizar partículas
- La IA puede crear nuevos tipos de partículas con estilos personalizados
- La IA puede modificar estilos existentes sin tocar código frontend
- Los estilos soportan variaciones dinámicas y múltiples frontends
- El rendimiento es equivalente o mejor que el sistema hardcoded actual
- Hay validación en el backend para prevenir valores inválidos de estilos

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [x] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Python 3.11, FastAPI, asyncpg
- Three.js, JavaScript ES6+
- PostgreSQL 16 (JSONB para estilos flexibles)
- Pydantic (validación de estilos)
- asyncpg (queries con JOIN)

### Archivos/Componentes Principales
- `database/init/01-init-schema.sql` - Agregar campo `estilos` JSONB a `tipos_particulas`
- `database/init/02-seed-data.sql` - Migrar colores hardcoded a estilos en BD
- `backend/src/api/routes/particles.py` - Modificar queries para incluir estilos en JOIN
- `backend/src/models/schemas.py` - Agregar validación Pydantic para estilos
- `frontend/src/scene.js` - Implementar cache de estilos y usar estilos de BD
- `frontend/src/api.js` - Manejar estilos en respuestas de API

## Criterios de Aceptación

1. [ ] El campo `estilos` JSONB existe en la tabla `tipos_particulas` con estructura válida
2. [ ] Los colores hardcoded actuales están migrados a la base de datos
3. [ ] Las queries de partículas incluyen estilos usando JOIN (sin queries adicionales)
4. [ ] El backend valida estilos con Pydantic antes de guardarlos
5. [ ] El frontend cachea estilos y los utiliza para renderizar partículas
6. [ ] El frontend tiene fallback a valores por defecto si falta estilo en BD
7. [ ] El rendimiento es equivalente o mejor que el sistema hardcoded (0ms adicionales)
8. [ ] La IA puede crear nuevos tipos de partículas con estilos personalizados
9. [ ] La IA puede modificar estilos existentes sin cambios en código frontend
10. [ ] Se documenta la estructura JSONB de estilos y cómo agregar nuevos campos

**Nota:** Cada criterio debe ser específico, medible y verificable.

## Detalles de Implementación

### Consideraciones Técnicas

- **Performance:**
  - Usar JOIN en queries existentes para incluir estilos (0 queries adicionales)
  - Cache en frontend para evitar procesamiento repetido de estilos
  - Considerar cache en backend si hay múltiples instancias (futuro)
  - Monitorear latencia de queries con estilos incluidos

- **Seguridad:**
  - Validar estructura JSONB con Pydantic antes de guardar
  - Sanitizar valores de color (hex válido, rango 0-0xFFFFFF)
  - Validar propiedades de material (metalness, roughness en rango 0-1)
  - Manejar valores por defecto si estilos son inválidos o corruptos

- **Compatibilidad:**
  - Mantener compatibilidad con partículas existentes que no tienen estilos
  - Fallback a colores hardcoded durante migración (fase transitoria)
  - Soporte para múltiples frontends (móvil, VR, texto)

- **Escalabilidad:**
  - Estructura JSONB flexible para agregar nuevos campos de estilo
  - Diseño preparado para texturas y modelos 3D en el futuro
  - Soporte para variaciones dinámicas de estilos según estado

### Estructura JSONB de Estilos

```json
{
    "color_hex": 9474192,
    "color_rgb": [148, 116, 85],
    "material": {
        "metalness": 0.1,
        "roughness": 0.8,
        "emissive": false
    },
    "visual": {
        "modelo": "cube",
        "escala": 1.0
    }
}
```

### Dependencias

- Depende de: Ninguna
- Bloquea: Creación dinámica de tipos de partículas por IA

## Testing

### Escenarios de Prueba

1. **Escenario 1: Carga inicial de viewport**
   - Cargar viewport con 6,000 partículas
   - Verificar que estilos se incluyen en respuesta
   - Verificar que frontend cachea estilos correctamente
   - Verificar que renderizado es correcto con estilos de BD
   - Medir latencia y comparar con sistema hardcoded

2. **Escenario 2: Nuevo tipo de partícula con estilos**
   - Crear nuevo tipo de partícula con estilos personalizados desde backend
   - Verificar que frontend renderiza con nuevos estilos
   - Verificar que cache se actualiza correctamente

3. **Escenario 3: Modificación de estilos existentes**
   - Modificar estilos de tipo existente en BD
   - Verificar que frontend detecta cambios (invalidación de cache)
   - Verificar que renderizado refleja cambios

4. **Escenario 4: Validación de estilos inválidos**
   - Intentar guardar color inválido (no hex)
   - Intentar guardar material con valores fuera de rango
   - Verificar que backend rechaza valores inválidos
   - Verificar que frontend usa valores por defecto si estilo es inválido

5. **Escenario 5: Partículas sin estilos (compatibilidad)**
   - Verificar partículas antiguas sin campo estilos
   - Verificar que frontend usa fallback a colores hardcoded
   - Verificar que sistema funciona sin errores

### Casos Edge a Considerar

- Estilos JSONB malformados en BD (manejar con try-catch)
- Partículas con tipo_particula_id que no existe (manejar con LEFT JOIN)
- Cache de frontend con estilos desactualizados (implementar invalidación)
- Múltiples tipos con mismo nombre (usar ID único)
- Estilos muy grandes en JSONB (limitar tamaño si es necesario)

## Estimación

- **Complejidad:** Media
- **Tiempo estimado:** 8-12 horas
- **Notas:** 
  - Requiere cambios en BD, backend y frontend
  - Necesita pruebas de rendimiento para validar optimizaciones
  - Migración de datos existentes puede requerir tiempo adicional
  - Testing exhaustivo necesario para asegurar compatibilidad

## Referencias

- **Relacionado con:** Arquitectura frontend-agnostic (Doc 18)
- **Documentación relevante:** 
  - `Juego de Dioses/Ideas/19-Estilos-en-Base-Datos-Analisis.md` - Análisis completo del requerimiento
  - `database/init/01-init-schema.sql` - Esquema actual de `tipos_particulas`
  - `frontend/src/scene.js` - Implementación actual con colores hardcoded
  - `backend/src/api/routes/particles.py` - Queries actuales de partículas
- **Discusiones previas:** Análisis completo en documento de ideas sobre ventajas/desventajas y arquitectura recomendada

## Notas Adicionales

- Este es un cambio arquitectónico importante que habilita creación dinámica de contenido por IA
- La solución optimizada (JOIN) mantiene rendimiento equivalente al hardcoded
- El campo `color_base` existente puede mantenerse para compatibilidad o migrarse a `estilos`
- Estructura JSONB permite extensión futura para texturas, modelos 3D, animaciones
- Considerar implementación en fases para minimizar riesgo:
  1. Fase 1: Agregar campo y migrar datos (sin cambios funcionales)
  2. Fase 2: Backend incluye estilos en respuestas
  3. Fase 3: Frontend usa estilos de BD con fallback
  4. Fase 4: Remover código hardcoded y agregar invalidación de cache

