# JDG-003 - Optimización de rendimiento del frontend y mejoras de UX

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [x] Performance (optimización)
- [ ] Documentation (documentación)
- [x] Chore (tareas de mantenimiento)

## Prioridad
- [x] Alta (bloquea funcionalidad crítica)
- [ ] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El frontend tenía problemas de rendimiento al renderizar terrenos grandes (40m x 40m = 160x160 celdas). Con el método anterior de renderizado individual, el navegador se congelaba o tenía FPS muy bajos (5-10 FPS) al intentar renderizar más de 30x30 celdas. Además, la grilla no estaba alineada con el terreno y había constantes no utilizadas en el código.

**Problemas identificados:**
1. **Rendimiento crítico**: El frontend no podía renderizar terrenos grandes sin congelarse
2. **Límites restrictivos**: Solo se podían cargar 30x30 celdas (7.5m x 7.5m)
3. **Desalineación visual**: La grilla no estaba centrada ni alineada con el terreno
4. **Código innecesario**: Constantes no utilizadas (`GRID_SIZE`, `GRID_DIVISIONS`, `AXES_SIZE`, `VIEWPORT_DEFAULT_Z_MIN`, `VIEWPORT_DEFAULT_Z_MAX`)
5. **Selección de dimensión**: El frontend podía seleccionar la dimensión demo incorrecta si había múltiples dimensiones

### Comportamiento Actual

- El frontend renderiza cada partícula como un mesh individual de Three.js
- Con 100,000 partículas = 100,000 draw calls = 5-10 FPS
- Límite de viewport: 30x30 celdas (7.5m x 7.5m)
- La grilla está fija en tamaño y posición, no se adapta al terreno
- Constantes no utilizadas ocupan espacio en el código
- El frontend busca cualquier dimensión con "Demo" en el nombre, puede seleccionar la incorrecta

### Comportamiento Esperado

- El frontend usa instanced rendering para agrupar partículas del mismo tipo/material
- Con 100,000 partículas en 5 grupos = 5 draw calls = 50-60 FPS
- Límite de viewport: 160x160 celdas (40m x 40m)
- La grilla se ajusta dinámicamente al tamaño del terreno y se centra correctamente
- Solo se mantienen constantes que se utilizan activamente
- El frontend selecciona la dimensión demo correcta por nombre exacto (definido en constante)

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI) - Aumento de límite de viewport
- [x] Frontend (Three.js) - Optimización de renderizado
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Three.js (InstancedMesh para instanced rendering)
- JavaScript ES6+ (agrupación de partículas por tipo/material)
- FastAPI (aumento de límite de validación de viewport)
- PostgreSQL (consultas de viewport más grandes)

### Archivos/Componentes Principales
- `frontend/src/scene.js` - Implementación de instanced rendering
- `frontend/src/main.js` - Cálculo dinámico de viewport y selección de dimensión
- `frontend/src/constants.js` - Limpieza de constantes no usadas
- `backend/src/models/schemas.py` - Aumento de límite de viewport (100k → 500k celdas)

## Criterios de Aceptación

1. [x] El frontend usa instanced rendering para agrupar partículas del mismo tipo/material
2. [x] El rendimiento mejora significativamente: de 5-10 FPS a 50-60 FPS con 100k partículas
3. [x] El viewport puede cargar hasta 160x160 celdas (40m x 40m) sin problemas de rendimiento
4. [x] La grilla se ajusta dinámicamente al tamaño del terreno y se centra correctamente
5. [x] Los ejes se posicionan en el centro del terreno
6. [x] Se eliminan todas las constantes no utilizadas del código
7. [x] El frontend selecciona la dimensión demo correcta por nombre exacto
8. [x] El backend valida viewports de hasta 500,000 celdas
9. [x] El cálculo del viewport considera rangos inclusivos correctamente

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance**: Instanced rendering reduce drásticamente los draw calls (de 100k a ~5)
- **Memoria**: Compartir geometrías y materiales reduce uso de memoria
- **Escalabilidad**: El sistema puede manejar terrenos más grandes sin problemas
- **Compatibilidad**: Los cambios son transparentes para el usuario (mismo resultado visual)

### Dependencias
- Depende de: JDG-001 (terrenos grandes ya creados)
- Bloquea: Ninguno

## Testing

### Escenarios de Prueba
1. **Carga de terreno grande**: Verificar que un terreno de 40m x 40m se carga y renderiza correctamente
2. **Rendimiento**: Verificar que el FPS se mantiene por encima de 50 FPS con 100k+ partículas
3. **Alineación de grilla**: Verificar que la grilla está centrada y alineada con el terreno
4. **Selección de dimensión**: Verificar que se selecciona la dimensión demo correcta cuando hay múltiples dimensiones

### Casos Edge a Considerar
- Terrenos muy grandes (más de 500k celdas) - el backend rechaza con error claro
- Múltiples dimensiones demo - el frontend selecciona la correcta por nombre
- Partículas con diferentes materiales - se agrupan correctamente por material

## Estimación

- **Complejidad:** Media
- **Tiempo estimado:** 3-4 horas
- **Notas:** La implementación de instanced rendering requiere entender bien Three.js, pero el resto es relativamente directo

## Referencias

- **Relacionado con:** JDG-001 (terrenos grandes)
- **Documentación relevante:** 
  - Three.js InstancedMesh: https://threejs.org/docs/#api/en/objects/InstancedMesh
  - Optimización de renderizado en Three.js
- **Discusiones previas:** Optimización necesaria para soportar terrenos de 40m x 40m

## Notas Adicionales

- El instanced rendering es completamente transparente para el usuario (mismo resultado visual)
- La optimización permite expandir el tamaño máximo de terrenos en el futuro
- La grilla dinámica mejora la experiencia visual y la orientación del usuario
- La limpieza de constantes mejora la mantenibilidad del código

