# JDG-004 - Optimización de visualización de árboles y rendimiento

## Tipo
- [x] Performance (optimización)
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [x] Media (importante pero no bloqueante)
- [ ] Alta (bloquea funcionalidad crítica)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento
Después de implementar árboles con alturas aumentadas (multiplicadas por 5), se identificaron dos problemas principales:

1. **Cortes visuales en copas de árboles**: Las copas de los árboles más altos (hasta z=32) no se visualizaban completamente porque el viewport estaba limitado a z=10 y el límite de celdas del backend era insuficiente.

2. **Gaps visuales entre tronco y hojas**: Las hojas parecían "levitar" sobre los troncos debido a que la generación de copas excluía las posiciones del tronco, creando un espacio vacío visual.

3. **Rendimiento degradado**: Al aumentar el tamaño de las copas de los árboles, el número de partículas aumentó significativamente, causando una reducción en los FPS del frontend.

### Comportamiento Actual
- La dimensión demo tiene `altura_maxima = 10`, insuficiente para árboles que llegan hasta z=32
- El viewport del backend está limitado a 500,000 celdas, lo que restringe el rango Z visible
- El cálculo del viewport en frontend no prioriza correctamente la altura sobre la profundidad
- Las copas de árboles se generan excluyendo las posiciones del tronco, creando gaps visuales
- Las hojas se generan con densidad 100% en todas las posiciones, generando demasiadas partículas
- El frontend agrupa todas las partículas del mismo tipo en un solo InstancedMesh, causando problemas de rendimiento con grupos muy grandes

### Comportamiento Esperado
- La dimensión debe tener `altura_maxima = 40` para acomodar árboles hasta z=32 con margen
- El límite de viewport del backend debe aumentar a 1,000,000 celdas para permitir cargar más altura
- El cálculo del viewport debe priorizar altura (árboles) sobre profundidad, usando 3/4 del rango hacia arriba
- Las copas deben generarse incluyendo las posiciones del tronco para eliminar gaps visuales
- Las hojas deben generarse con densidad variable (100% centro, 90% zona media, 70% bordes) para optimizar rendimiento
- El frontend debe dividir grupos grandes de partículas en múltiples InstancedMeshes (máximo 50k instancias por mesh)

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Python 3.11, FastAPI, asyncpg
- Three.js, JavaScript ES6+
- PostgreSQL 16
- Docker, Docker Compose

### Archivos/Componentes Principales
- `backend/src/database/seed_demo.py` - Aumentar altura_maxima de dimensión
- `backend/src/models/schemas.py` - Aumentar MAX_VIEWPORT_CELLS
- `backend/src/database/tree_templates.py` - Optimizar generación de copas con densidad variable
- `frontend/src/main.js` - Ajustar cálculo de viewport para priorizar altura
- `frontend/src/scene.js` - Dividir InstancedMeshes grandes en múltiples grupos

## Criterios de Aceptación

1. [ ] La dimensión demo se crea con `altura_maxima = 40` en lugar de 10
2. [ ] El backend acepta viewports de hasta 1,000,000 celdas (aumentado de 500,000)
3. [ ] El frontend calcula el viewport priorizando altura (3/4 del rango hacia arriba)
4. [ ] Las copas de árboles se generan sin gaps visuales (hojas incluyen posiciones del tronco)
5. [ ] Las hojas se generan con densidad variable (100% centro, 90% media, 70% bordes)
6. [ ] El frontend divide grupos grandes (>50k partículas) en múltiples InstancedMeshes
7. [ ] Los árboles más altos (hasta z=32) se visualizan completamente sin cortes
8. [ ] El rendimiento del frontend mejora o se mantiene estable con más partículas
9. [ ] No hay gaps visuales entre troncos y hojas en ningún árbol

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance**: 
  - Reducir densidad de hojas en bordes y niveles superiores para mantener rendimiento
  - Dividir InstancedMeshes grandes para evitar problemas de memoria y renderizado
  - El límite de 1M celdas permite cargar 160x160x40 = 1,024,000 celdas (justo dentro del límite)
- **Seguridad**: No aplica
- **Compatibilidad**: 
  - Los cambios son compatibles con dimensiones existentes (solo afecta nuevas dimensiones)
  - El aumento del límite de viewport es retrocompatible
- **Escalabilidad**: 
  - La optimización de densidad de hojas reduce el número total de partículas
  - La división de InstancedMeshes mejora el rendimiento con grandes cantidades de partículas

### Dependencias
- Depende de: JDG-003 (Optimizaciones de frontend y viewport)
- Bloquea: Ninguno

## Testing

### Escenarios de Prueba
1. **Verificación de altura de dimensión**: Crear nueva dimensión demo y verificar que `altura_maxima = 40`
2. **Verificación de viewport grande**: Cargar viewport de 160x160x40 y verificar que no se rechaza
3. **Verificación de visualización completa**: Verificar que copas de árboles hasta z=32 sean visibles
4. **Verificación de gaps**: Inspeccionar visualmente que no haya gaps entre troncos y hojas
5. **Verificación de densidad**: Verificar que hojas en bordes tengan menor densidad que en centro
6. **Verificación de rendimiento**: Medir FPS antes y después de los cambios
7. **Verificación de InstancedMeshes**: Verificar en consola que grupos grandes se dividan correctamente

### Casos Edge a Considerar
- Viewport que excede 1M celdas: Debe rechazarse con mensaje claro
- Árboles en bordes de dimensión: Deben generarse correctamente sin salirse de límites
- Árboles muy grandes: Deben visualizarse completamente sin cortes
- Múltiples tipos de árboles: Todos deben verse correctamente sin gaps

## Estimación

- **Complejidad:** Media
- **Tiempo estimado:** 3-4 horas
- **Notas:** 
  - Requiere regenerar seed demo para aplicar cambios
  - Necesita verificación visual exhaustiva
  - Optimizaciones de rendimiento requieren pruebas de FPS

## Referencias

- **Relacionado con:** JDG-003 (Optimizaciones de frontend y viewport)
- **Documentación relevante:** 
  - `instructions/examples/terrenos/bioma-bosque.md`
  - `instructions/RELACION-PARTICULAS-METROS.md`
- **Discusiones previas:** Optimización de árboles después de aumentar alturas por 5x

## Notas Adicionales

- Los cambios en `tree_templates.py` requieren regenerar la seed demo para aplicarse
- El aumento del límite de viewport puede afectar el rendimiento de consultas muy grandes
- La densidad variable de hojas puede hacer que algunos árboles se vean menos frondosos en los bordes, pero mejora el rendimiento general
- La división de InstancedMeshes en el frontend es transparente para el usuario final

