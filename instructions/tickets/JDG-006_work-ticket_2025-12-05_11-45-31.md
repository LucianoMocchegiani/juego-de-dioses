# JDG-006 - Componentización y Reorganización del Frontend para Escalabilidad

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [x] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El frontend actual tiene una estructura monolítica que no escala bien para agregar nuevas funcionalidades y tipos de entidades. Los archivos principales (`main.js`, `scene.js`, `api.js`) contienen toda la lógica mezclada, lo que dificultará agregar:
- **Renderizadores especializados**: Diferentes formas de renderizar árboles, plantas, animales, razas
- **Sistemas de UI**: Inventario, construcción, interacción con entidades
- **Efectos visuales**: Animaciones, partículas, iluminación dinámica
- **Gestión de estado**: Estado del jugador, inventario, selección de entidades
- **Componentes reutilizables**: Botones, paneles, modales, etc.

Cada nueva funcionalidad requerirá modificar archivos existentes, lo que no es sostenible a largo plazo.

### Comportamiento Actual

**Estructura actual:**
```
frontend/
├── index.html          # Página principal
├── src/
│   ├── main.js        # Lógica principal, carga de datos, gestión de estado
│   ├── api.js         # Cliente API (genérico)
│   ├── scene.js       # Escena Three.js, renderizado de partículas (genérico)
│   ├── constants.js   # Constantes
│   └── types.js       # Tipos TypeScript/JSDoc
└── nginx.conf         # Configuración nginx
```

**Problemas identificados:**
1. **Lógica mezclada**: `main.js` tiene lógica de carga, gestión de estado y orquestación mezclada
2. **Renderizado genérico**: `scene.js` renderiza todas las partículas de la misma forma, sin diferenciación por tipo
3. **Sin especialización visual**: No hay diferenciación visual entre tipos de árboles, animales, etc.
4. **Sin componentes reutilizables**: Todo está en archivos monolíticos
5. **Sin separación de responsabilidades**: Renderizado, lógica de negocio y UI están mezclados
6. **Sin gestión de estado centralizada**: Estado disperso en variables globales
7. **Sin sistema de eventos**: No hay comunicación estructurada entre componentes
8. **Difícil testear**: Archivos grandes y acoplados dificultan testing

### Comportamiento Esperado

**Estructura modular propuesta:**
```
frontend/
├── index.html
├── src/
│   ├── main.js                    # Punto de entrada, inicialización
│   ├── app.js                     # Aplicación principal (orquestación)
│   ├── api/
│   │   ├── client.js              # Cliente API base
│   │   └── endpoints.js           # Endpoints específicos
│   ├── core/
│   │   ├── scene.js               # Escena Three.js base
│   │   ├── camera.js              # Gestión de cámara
│   │   ├── controls.js            # Controles de cámara
│   │   └── renderer.js            # Renderizador base
│   ├── renderers/
│   │   ├── base-renderer.js      # Renderizador base abstracto
│   │   ├── particle-renderer.js  # Renderizador genérico de partículas
│   │   ├── tree-renderer.js      # Renderizador especializado para árboles
│   │   ├── plant-renderer.js      # Renderizador especializado para plantas
│   │   └── entity-renderer.js     # Renderizador para animales/razas
│   ├── components/
│   │   ├── ui/                    # Componentes UI reutilizables
│   │   │   ├── button.js
│   │   │   ├── panel.js
│   │   │   └── modal.js
│   │   └── entities/              # Componentes de entidades
│   │       ├── tree-view.js
│   │       └── entity-info.js
│   ├── state/
│   │   ├── store.js               # Gestión de estado centralizada
│   │   └── selectors.js           # Selectores de estado
│   ├── utils/
│   │   ├── colors.js              # Utilidades de colores
│   │   ├── geometry.js            # Utilidades de geometría
│   │   └── helpers.js             # Helpers generales
│   ├── constants.js
│   └── types.js
└── nginx.conf
```

**Beneficios esperados:**
- Separación clara de responsabilidades
- Renderizadores especializados por tipo de entidad
- Componentes reutilizables
- Gestión de estado centralizada
- Fácil agregar nuevos tipos sin modificar código existente
- Código más testeable y mantenible
- Mejor organización y escalabilidad

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI) - No afectado
- [x] Frontend (Three.js) - Principalmente afectado
- [ ] Base de Datos (PostgreSQL) - No afectado
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado
- [ ] API Endpoints - No afectado (solo cambios internos en cliente)

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (renderizado 3D)
- OrbitControls (controles de cámara)
- Patrones de diseño: Strategy, Factory, Observer, Component
- Posiblemente: Sistema de gestión de estado (Redux-like o custom)

### Archivos/Componentes Principales

**Archivos a refactorizar:**
- `frontend/src/main.js` - Separar en `main.js`, `app.js`, y módulos de estado
- `frontend/src/scene.js` - Separar en `core/scene.js`, `core/camera.js`, `core/controls.js`, y renderizadores especializados
- `frontend/src/api.js` - Separar en `api/client.js` y `api/endpoints.js`

**Nuevos archivos a crear:**
- Sistema de renderizadores especializados
- Componentes UI reutilizables
- Sistema de gestión de estado
- Utilidades organizadas

## Criterios de Aceptación

1. [ ] Existe estructura de carpetas modular (`core/`, `renderers/`, `components/`, `state/`, `utils/`)
2. [ ] Renderizado genérico separado de renderizado especializado
3. [ ] Al menos un renderizador especializado implementado (ej: `TreeRenderer`)
4. [ ] Sistema de gestión de estado centralizado implementado
5. [ ] Componentes UI reutilizables creados (al menos 2-3 ejemplos)
6. [ ] Separación clara de responsabilidades entre módulos
7. [ ] El frontend funciona igual que antes (mismo resultado visual)
8. [ ] Agregar nuevo tipo de renderizador solo requiere crear nuevo archivo
9. [ ] Código más testeable (módulos pequeños y desacoplados)
10. [ ] Documentación completa (READMEs en cada módulo siguiendo práctica establecida)
11. [ ] Análisis de arquitectura completado antes de implementación

## Detalles de Implementación

### Consideraciones Técnicas

**Performance:**
- Mantener rendimiento actual o mejorarlo
- Instanced rendering debe seguir funcionando
- Optimizaciones de viewport deben mantenerse

**Compatibilidad:**
- No romper funcionalidad existente
- APIs del backend no cambian
- Mismo resultado visual para el usuario

**Escalabilidad:**
- Fácil agregar nuevos renderizadores
- Fácil agregar nuevos componentes UI
- Fácil agregar nuevas funcionalidades sin modificar código existente

**Testing:**
- Módulos pequeños y desacoplados facilitan testing
- Cada renderizador puede testearse independientemente
- Componentes UI pueden testearse aisladamente

### Dependencias

- Depende de: JDG-005 (Componentización del backend) - Para tener contexto de la estructura modular del backend
- Bloquea: Futuros tickets de UI, sistemas de interacción, animaciones

### Análisis de Arquitectura Requerido

**IMPORTANTE:** Antes de comenzar la implementación, se debe generar un análisis de arquitectura completo usando la regla `@architecture-analysis-rule.mdc`.

**El análisis debe incluir:**
- Situación actual del frontend (estructura, problemas identificados)
- Necesidades futuras (renderizadores especializados, UI, sistemas de interacción)
- Arquitectura propuesta (estructura modular, patrones de diseño)
- Patrones de diseño a usar (Strategy para renderizadores, Factory para creación, etc.)
- Plan de migración (fases incrementales)
- Consideraciones técnicas (performance, compatibilidad, testing)

**Proceso:**
1. Generar análisis usando `@architecture-analysis-rule.mdc` con ticket ID `JDG-006`
2. Revisar y aprobar análisis
3. Generar plan de acción basado en el análisis
4. Ejecutar plan de acción paso a paso

## Testing

### Escenarios de Prueba

1. **Verificación de funcionalidad**: El frontend debe funcionar igual que antes
2. **Renderizado de partículas**: Todas las partículas se renderizan correctamente
3. **Controles de cámara**: OrbitControls funcionan correctamente
4. **Viewport dinámico**: Carga de partículas por viewport funciona
5. **Renderizador especializado**: Si se implementa TreeRenderer, debe renderizar árboles correctamente
6. **Gestión de estado**: Estado se mantiene correctamente entre interacciones
7. **Componentes UI**: Componentes reutilizables funcionan correctamente
8. **Performance**: Rendimiento igual o mejor que antes

### Casos Edge a Considerar

- Viewport vacío o sin partículas
- Cambio de dimensión en tiempo de ejecución
- Múltiples tipos de entidades en la misma escena
- Interacciones del usuario mientras se cargan datos
- Errores de red o API

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 12-16 horas
- **Notas:** 
  - Requiere análisis de arquitectura previo (2-3 horas)
  - Refactorización cuidadosa para mantener compatibilidad
  - Requiere pruebas exhaustivas para asegurar que nada se rompe
  - Documentación completa siguiendo práctica de READMEs

## Referencias

- **Relacionado con:** JDG-005 (Componentización del backend)
- **Documentación relevante:** 
  - `instructions/analysis/JDG-005-architecture-analysis_2025-12-05_08-26-57.md` (como referencia de estructura modular)
  - `instructions/readme-rule.mdc` (práctica de READMEs)
- **Discusiones previas:** Necesidad de escalar frontend para preparar UI, interacciones y renderizado especializado

## Notas Adicionales

- Esta refactorización es importante para el futuro del proyecto, especialmente cuando se agreguen sistemas de UI, interacción con entidades, y renderizado especializado
- Debe hacerse de forma incremental para no romper funcionalidad existente
- La documentación es crucial para que otros desarrolladores puedan agregar nuevos renderizadores y componentes fácilmente
- Se recomienda hacer esta refactorización antes de agregar sistemas de UI complejos o interacciones avanzadas
- El análisis de arquitectura debe ser el primer paso antes de cualquier implementación

