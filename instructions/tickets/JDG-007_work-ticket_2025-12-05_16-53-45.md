# JDG-007 - Optimización de Rendimiento del Frontend (FPS Bajo)

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [x] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [x] Alta (bloquea funcionalidad crítica)
- [ ] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El frontend presenta FPS muy bajos al renderizar terrenos grandes (ej: demo 40x40m con ~400k partículas). El rendimiento actual no es aceptable para una experiencia de usuario fluida, especialmente cuando se renderizan múltiples tipos de partículas con diferentes geometrías.

### Comportamiento Actual

**Problemas identificados:**
1. **FPS bajo**: El frontend corre con FPS muy bajos al renderizar terrenos grandes
2. **Sin frustum culling**: Se renderizan todas las partículas del viewport, incluso las que están fuera del campo de visión de la cámara
3. **Ordenamiento costoso**: Se ordenan partículas múltiples veces (inicial, por grupo, por chunk) lo cual es costoso con grandes cantidades
4. **Múltiples draw calls**: Cada grupo de geometría+material genera múltiples instanced meshes, aumentando draw calls
5. **Sin Level of Detail (LOD)**: Partículas lejanas se renderizan con el mismo detalle que las cercanas
6. **Sin occlusion culling**: Se renderizan partículas que están completamente ocultas por otras
7. **Geometrías no optimizadas**: Algunas geometrías (especialmente sphere con muchos segments) pueden ser costosas
8. **Sin chunking espacial**: No se implementa carga/descarga dinámica de chunks según posición de cámara

**Métricas actuales:**
- Demo 40x40m: ~400,000 partículas renderizadas
- MAX_INSTANCES_PER_MESH: 50,000
- Múltiples geometrías diferentes (box, sphere, cylinder)
- Ordenamiento por profundidad en múltiples niveles

### Comportamiento Esperado

**Objetivos de rendimiento:**
- Mantener mínimo 60 FPS en terrenos grandes (40x40m con ~400k partículas)
- Mantener mínimo 60 FPS en terrenos medianos (20x20m)
- Reducir draw calls significativamente
- Implementar frustum culling para no renderizar partículas fuera del campo de visión
- Implementar LOD básico para partículas lejanas
- Optimizar ordenamiento para que sea más eficiente
- Reducir overhead de creación de geometrías y materiales
- Implementar optimizaciones agresivas necesarias para alcanzar 60 FPS en 40x40m

**Mejoras esperadas:**
- Frustum culling: Solo renderizar partículas visibles por la cámara
- LOD: Reducir detalle de partículas lejanas (menos polígonos, geometrías simplificadas)
- Optimización de ordenamiento: Usar algoritmos más eficientes o reducir número de ordenamientos
- Chunking espacial: Cargar/descargar chunks según posición de cámara
- Optimización de geometrías: Reducir segments de esferas, simplificar geometrías complejas
- Batch optimization: Mejorar agrupación de instancias para reducir draw calls

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI) - No afectado
- [x] Frontend (Three.js) - Principalmente afectado
- [ ] Base de Datos (PostgreSQL) - No afectado
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado
- [ ] API Endpoints - No afectado

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (WebGL, InstancedMesh, Frustum, Raycaster)
- OrbitControls (para frustum culling)
- Posiblemente: Web Workers (para cálculos pesados en background)

### Archivos/Componentes Principales

**Archivos a modificar/crear:**
- `frontend/src/renderers/particle-renderer.js` - Implementar frustum culling y optimizaciones
- `frontend/src/core/camera.js` - Exponer frustum para culling
- `frontend/src/managers/viewport-manager.js` - Posiblemente optimizar cálculos
- `frontend/src/renderers/geometries/registry.js` - Optimizar creación de geometrías (LOD)
- `frontend/src/utils/culling.js` (nuevo) - Utilidades para frustum culling
- `frontend/src/utils/lod.js` (nuevo) - Utilidades para Level of Detail

## Criterios de Aceptación

1. [ ] FPS mínimo de 60 en demo 40x40m (~400k partículas) - **OBJETIVO PRINCIPAL**
2. [ ] FPS mínimo de 60 en demo 20x20m (~100k partículas)
3. [ ] Frustum culling implementado: solo se renderizan partículas visibles por la cámara
4. [ ] LOD básico implementado: partículas lejanas usan geometrías simplificadas
5. [ ] Reducción de draw calls: menos instanced meshes creados (objetivo: reducir en al menos 50%)
6. [ ] Optimización de ordenamiento: ordenamiento más eficiente o reducido
7. [ ] Geometrías optimizadas: esferas con menos segments cuando están lejos
8. [ ] Sin degradación visual significativa: la calidad visual se mantiene aceptable
9. [ ] Performance profiling: se puede medir FPS y draw calls antes/después
10. [ ] Optimizaciones adicionales si es necesario: occlusion culling básico, chunking espacial, o reducción de partículas renderizadas

**Nota:** Cada criterio debe ser específico, medible y verificable usando herramientas de profiling del navegador.

## Detalles de Implementación

### Consideraciones Técnicas

**Performance:**
- Implementar frustum culling usando `THREE.Frustum` y `camera.matrixWorldInverse`
- Usar `Box3` para bounding boxes de grupos de partículas
- Implementar LOD basado en distancia a la cámara
- Optimizar ordenamiento: usar algoritmos más eficientes o hacerlo solo cuando sea necesario
- Cachear cálculos de frustum culling entre frames si la cámara no se mueve

**Compatibilidad:**
- Mantener funcionalidad existente (mismo resultado visual)
- No romper renderizado actual
- Hacer optimizaciones opcionales/configurables

**Escalabilidad:**
- Las optimizaciones deben funcionar con cualquier cantidad de partículas
- Preparar para futuras mejoras (occlusion culling, chunking espacial)

### Optimizaciones Propuestas

**1. Frustum Culling:**
```javascript
// Filtrar partículas fuera del frustum de la cámara antes de renderizar
const frustum = new THREE.Frustum();
frustum.setFromProjectionMatrix(camera.projectionMatrix);
// Filtrar partículas que no están en el frustum
```

**2. Level of Detail (LOD):**
```javascript
// Reducir detalle de geometrías según distancia
const distance = camera.position.distanceTo(particlePosition);
if (distance > LOD_DISTANCE_THRESHOLD) {
    // Usar geometría simplificada (menos segments, menos polígonos)
}
```

**3. Optimización de Ordenamiento:**
- Reducir número de ordenamientos (hacer solo uno al inicio)
- Usar algoritmos más eficientes (radix sort para números enteros)
- Cachear ordenamiento si las partículas no cambian

**4. Batch Optimization:**
- Mejorar agrupación de instancias para reducir draw calls
- Agrupar partículas por distancia para aplicar LOD más eficientemente

**5. Geometrías Optimizadas:**
- Reducir `segments` de esferas según distancia
- Usar geometrías más simples para partículas lejanas
- Cachear geometrías LOD para reutilización

**6. Optimizaciones Adicionales (si 60 FPS no se alcanza con las anteriores):**
- Occlusion culling básico: no renderizar partículas completamente ocultas
- Chunking espacial: cargar/descargar chunks según posición de cámara
- Reducción agresiva de partículas: limitar número máximo de partículas renderizadas simultáneamente
- Simplificación de geometrías: usar geometrías más simples por defecto
- Optimización de materiales: reducir cálculos de iluminación para partículas lejanas

### Dependencias

- Depende de: JDG-006 (Componentización del Frontend) - Para tener estructura modular donde implementar optimizaciones
- Bloquea: Futuros tickets de UI interactiva, sistemas de interacción en tiempo real

## Testing

### Escenarios de Prueba

1. **Demo 40x40m (Objetivo principal):**
   - Cargar demo completo (~400k partículas)
   - Medir FPS antes y después de optimizaciones
   - **Objetivo: Alcanzar 60 FPS estables**
   - Verificar que frustum culling funciona (rotar cámara, verificar que solo se renderizan partículas visibles)
   - Verificar que LOD funciona (acercar/alejar cámara, verificar cambio de detalle)
   - Verificar que FPS se mantiene estable durante movimiento de cámara

2. **Demo 20x20m:**
   - Cargar demo mediano
   - Medir FPS (debe ser >= 60)
   - Verificar que no hay degradación visual

3. **Movimiento de cámara:**
   - Rotar cámara rápidamente
   - Verificar que FPS se mantiene estable
   - Verificar que frustum culling se actualiza correctamente

4. **Zoom in/out:**
   - Acercar cámara (verificar LOD aumenta detalle)
   - Alejar cámara (verificar LOD reduce detalle)
   - Verificar que FPS mejora cuando se aleja

5. **Performance profiling:**
   - Usar Chrome DevTools Performance tab
   - Medir draw calls antes/después
   - Medir tiempo de renderizado
   - Identificar cuellos de botella

### Casos Edge a Considerar

- Cámara muy cerca del terreno (todas las partículas visibles)
- Cámara muy lejos (todas las partículas deberían usar LOD)
- Rotación rápida de cámara (frustum culling debe actualizarse rápidamente)
- Terrenos con muchas partículas transparentes (agua)
- Múltiples tipos de geometrías en la misma escena
- Cambio de viewport dinámico mientras se mueve la cámara

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 20-24 horas
- **Notas:** 
  - Requiere profiling detallado para identificar cuellos de botella específicos
  - Implementación incremental: frustum culling primero, luego LOD, luego optimizaciones adicionales
  - Requiere pruebas exhaustivas para asegurar que no se rompe funcionalidad existente
  - Puede requerir ajustes finos según hardware del usuario
  - **Objetivo ambicioso**: 60 FPS en 40x40m puede requerir optimizaciones adicionales más agresivas (occlusion culling, reducción de partículas renderizadas, chunking espacial)
  - Puede ser necesario implementar múltiples niveles de optimización y ajustar según resultados de profiling

## Referencias

- **Relacionado con:** JDG-006 (Componentización del Frontend)
- **Documentación relevante:**
  - Three.js Frustum Culling: https://threejs.org/docs/#api/en/math/Frustum
  - Three.js InstancedMesh: https://threejs.org/docs/#api/en/objects/InstancedMesh
  - WebGL Performance Best Practices
- **Discusiones previas:** Problema identificado durante pruebas del demo 40x40m

## Notas Adicionales

- Las optimizaciones deben ser configurables para poder ajustar según hardware
- Considerar agregar opciones de configuración para usuarios con hardware potente (desactivar LOD, aumentar detalle)
- Implementar métricas de performance para monitorear FPS en tiempo real (opcional, para debugging)
- Las optimizaciones deben funcionar sin romper el renderizado actual
- Considerar implementar occlusion culling en el futuro si frustum culling y LOD no son suficientes
- Profiling inicial es crucial para identificar los cuellos de botella específicos antes de optimizar

