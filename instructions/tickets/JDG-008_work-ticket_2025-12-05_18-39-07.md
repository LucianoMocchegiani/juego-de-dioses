# JDG-008 - Mejora del ParticleLimiter para Alcanzar 60 FPS

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [x] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [x] Alta (bloquea funcionalidad crítica)
- [ ] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El `ParticleLimiter` implementado en JDG-007 mejora el FPS de 14-20 a 27-31 FPS, pero aún no alcanza el objetivo de 60 FPS en el demo 40x40m (~400k partículas). Se necesita mejorar la estrategia de limitación de partículas para alcanzar el objetivo de rendimiento.

### Comportamiento Actual

**Implementación actual:**
- Límite máximo: 150,000 partículas
- Estrategia: Ordena por distancia y toma las N más cercanas
- Se aplica después de frustum culling y LOD
- No considera densidad espacial
- No tiene estrategias adaptativas según FPS

**Métricas actuales:**
- FPS: 27-31 FPS en demo 40x40m
- Partículas renderizadas: ~150k (limitadas desde ~400k)
- Objetivo: 60 FPS

### Comportamiento Esperado

**Mejoras esperadas:**
- Alcanzar 60 FPS estables en demo 40x40m
- Estrategias más inteligentes de limitación:
  - Limitación con densidad reducida (cada N partículas lejanas)
  - Adaptación dinámica según FPS actual
  - Priorización por importancia visual (partículas visibles, tipos importantes)
  - Sampling espacial inteligente
- Configuración flexible según hardware
- Mantener calidad visual aceptable

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI) - No afectado
- [x] Frontend (Three.js) - Principalmente afectado
- [ ] Base de Datos (PostgreSQL) - No afectado
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (Vector3, distancia)
- Performance API (para medir FPS y adaptar)

### Archivos/Componentes Principales

**Archivos a modificar:**
- `frontend/src/renderers/optimizations/particle-limiter.js` - Mejorar estrategias de limitación
- `frontend/src/renderers/particle-renderer.js` - Integrar limitación adaptativa
- `frontend/src/managers/performance-manager.js` - Exponer métricas para adaptación

**Nuevos archivos (si aplica):**
- `frontend/src/renderers/optimizations/adaptive-limiter.js` (opcional) - Limitador adaptativo basado en FPS

## Criterios de Aceptación

1. [ ] FPS mínimo de 60 en demo 40x40m (~400k partículas) - **OBJETIVO PRINCIPAL**
2. [ ] FPS mínimo de 60 en demo 20x20m (~100k partículas)
3. [ ] Limitación con densidad reducida implementada: reduce densidad de partículas lejanas (cada N partículas)
4. [ ] Limitación adaptativa implementada: ajusta límite según FPS actual
5. [ ] Sampling espacial inteligente: mantiene distribución visual de partículas
6. [ ] Configuración flexible: límites configurables según hardware
7. [ ] Sin degradación visual significativa: calidad visual aceptable
8. [ ] Logs de limitación mejorados: mostrar estrategia aplicada y resultados

## Detalles de Implementación

### Consideraciones Técnicas

**Performance:**
- Implementar limitación con densidad reducida (ya existe método `limitParticlesWithDensity` pero no se usa)
- Implementar adaptación dinámica basada en FPS actual
- Optimizar cálculo de distancias (usar distancia al cuadrado cuando sea posible)
- Considerar sampling espacial para mantener distribución visual

**Estrategias propuestas:**

1. **Limitación con Densidad Reducida:**
   - Cercanas (< 20m): 100% de partículas
   - Medianas (20-50m): 50% de partículas (cada 2)
   - Lejanas (> 50m): 25% de partículas (cada 4)

2. **Limitación Adaptativa:**
   - Si FPS < 45: Reducir límite a 100k partículas
   - Si FPS 45-55: Límite 120k partículas
   - Si FPS >= 60: Límite 150k partículas

3. **Sampling Espacial:**
   - Dividir espacio en chunks
   - Mantener al menos N partículas por chunk visible
   - Priorizar chunks cercanos a cámara

4. **Priorización por Tipo:**
   - Priorizar partículas de tipos importantes (árboles, agua)
   - Reducir densidad de tipos menos importantes (tierra, piedra)

**Compatibilidad:**
- Mantener API existente de `ParticleLimiter`
- Hacer estrategias configurables
- No romper funcionalidad existente

**Escalabilidad:**
- Las estrategias deben funcionar con cualquier cantidad de partículas
- Preparar para futuras mejoras (occlusion culling, chunking espacial)

### Optimizaciones Propuestas

**1. Usar limitación con densidad:**
```javascript
// En lugar de limitParticles, usar limitParticlesWithDensity
particlesToRender = this.particleLimiter.limitParticlesWithDensity(
    particlesToRender,
    cameraPosition,
    cellSize,
    20,  // nearDistance
    50   // farDistance
);
```

**2. Implementar adaptación dinámica:**
```javascript
// En ParticleRenderer, ajustar límite según FPS
const currentFPS = this.performanceManager.getMetrics().fps;
if (currentFPS < 45) {
    this.particleLimiter.setMaxParticles(100000);
} else if (currentFPS < 55) {
    this.particleLimiter.setMaxParticles(120000);
} else {
    this.particleLimiter.setMaxParticles(150000);
}
```

**3. Sampling espacial:**
- Dividir viewport en grid 3D
- Mantener representación de cada celda visible
- Priorizar celdas cercanas

**4. Reducir límite inicial:**
- Probar con límites más bajos (100k, 80k)
- Medir impacto en FPS y calidad visual

### Dependencias

- Depende de: JDG-007 (Optimización de Rendimiento del Frontend)
- Bloquea: Futuros tickets de UI interactiva, sistemas de interacción en tiempo real

## Testing

### Escenarios de Prueba

1. **Demo 40x40m (Objetivo principal):**
   - Cargar demo completo (~400k partículas)
   - Verificar que limitación con densidad funciona
   - Verificar que adaptación dinámica ajusta límite según FPS
   - **Objetivo: Alcanzar 60 FPS estables**
   - Verificar que calidad visual se mantiene aceptable

2. **Demo 20x20m:**
   - Cargar demo mediano
   - Medir FPS (debe ser >= 60)
   - Verificar que no hay degradación visual

3. **Adaptación dinámica:**
   - Simular diferentes cargas de FPS
   - Verificar que límite se ajusta correctamente
   - Verificar que FPS mejora con ajuste

4. **Limitación con densidad:**
   - Verificar que partículas cercanas se mantienen al 100%
   - Verificar que partículas lejanas se reducen correctamente
   - Verificar que distribución visual se mantiene

5. **Sampling espacial:**
   - Verificar que cada región visible tiene representación
   - Verificar que no hay "huecos" visibles
   - Verificar que priorización por distancia funciona

### Casos Edge a Considerar

- Cámara muy cerca del terreno (todas las partículas cercanas, alta densidad)
- Cámara muy lejana (todas las partículas lejanas, baja densidad)
- Cambio rápido de FPS (adaptación debe ser suave)
- Terrenos con distribución desigual de partículas
- Múltiples tipos de partículas con diferentes importancias visuales

## Estimación

- **Complejidad:** Media-Alta
- **Tiempo estimado:** 8-12 horas
- **Notas:** 
  - Requiere pruebas iterativas para encontrar límites óptimos
  - Puede requerir ajustes finos según resultados de profiling
  - Implementación incremental: densidad primero, luego adaptación, luego sampling
  - Requiere pruebas exhaustivas para asegurar calidad visual

## Referencias

- **Relacionado con:** JDG-007 (Optimización de Rendimiento del Frontend)
- **Documentación relevante:**
  - `frontend/src/renderers/optimizations/particle-limiter.js` - Implementación actual
  - `frontend/src/renderers/optimizations/README.md` - Documentación del módulo
  - Three.js Performance Best Practices
- **Discusiones previas:** Problema identificado durante verificación de JDG-007 (FPS 27-31, objetivo 60)

## Notas Adicionales

- El método `limitParticlesWithDensity` ya existe pero no se está usando actualmente
- Considerar hacer las estrategias configurables para ajustar según hardware
- Implementar métricas detalladas para monitorear efectividad de cada estrategia
- Considerar implementar sampling espacial solo si densidad y adaptación no son suficientes
- Las optimizaciones deben funcionar sin romper funcionalidad existente
- Profiling continuo es crucial para identificar límites óptimos

