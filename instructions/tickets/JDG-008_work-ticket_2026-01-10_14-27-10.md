# JDG-008 - Optimización de Renderizado de Partículas para Alcanzar 60 FPS

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [x] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [x] Alta (bloquea funcionalidad crítica)
- [ ] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El sistema actual presenta FPS extremadamente bajos cuando la cámara apunta a las partículas del terreno. Mientras que cuando la cámara apunta al cielo el rendimiento es aceptable, al mirar hacia el terreno (donde están las partículas) el FPS cae drásticamente. Se necesita optimizar el renderizado de partículas para alcanzar 60 FPS estables, considerando además las funcionalidades futuras de interacción con partículas (romper tierra para farmear recursos, recolectar agua, talar árboles, etc.).

### Comportamiento Actual

**Problema principal:**
- FPS muy bajos cuando la cámara apunta a las partículas del terreno
- FPS aceptable (presumiblemente 60+) cuando la cámara apunta al cielo
- Esto indica que el problema es específico del renderizado de partículas visibles

**Implementación actual:**
- Límite máximo estático: 150,000 partículas
- Estrategia: Ordena por distancia y toma las N más cercanas (`limitParticles()`)
- `limitParticlesWithDensity()` existe pero NO se está usando
- Se aplica después de frustum culling y LOD
- No considera densidad espacial (reduce todas las partículas por igual)
- No tiene estrategias adaptativas según FPS actual
- Sin actualización incremental: cuando se modifica una partícula, recarga toda la dimensión

**Métricas actuales:**
- FPS: Muy bajos cuando cámara apunta a partículas (~27-31 FPS en demo 40x40m)
- FPS: OK cuando cámara apunta al cielo
- Partículas renderizadas: ~150k (limitadas desde ~400k)
- Objetivo: 60 FPS estables cuando cámara apunta a partículas

**Problema de actualización:**
- `TerrainManager.updateParticle()` recarga toda la dimensión al modificar una partícula
- Esto es extremadamente costoso y no permitirá gameplay fluido de interacciones
- No hay actualización incremental de instanced meshes

### Comportamiento Esperado

**Mejoras esperadas:**
- Alcanzar 60 FPS estables cuando cámara apunta a partículas (demo 40x40m)
- Estrategias más inteligentes de limitación:
  - **Limitación con densidad reducida**: Activar `limitParticlesWithDensity()` que reduce densidad de partículas lejanas (cada N partículas) manteniendo distribución visual
  - **Adaptación dinámica**: Ajustar límite de partículas según FPS actual (si FPS < 45, reducir a 80k, etc.)
  - **Priorización por importancia visual**: Mantener partículas de tipos importantes (agua, árboles) cuando se limita
- **Actualización incremental**: Modificar partículas individuales sin re-renderizar todo el terreno
- Configuración flexible según hardware
- Mantener calidad visual aceptable
- Preparado para interacciones futuras (romper, recolectar, farmear) sin impactar rendimiento

**Funcionalidades futuras a considerar:**
- Romper partículas (tierra, piedra) para farmear recursos
- Recolectar agua (partículas líquidas)
- Talar árboles (partículas de madera/hojas en agrupaciones)
- Colocar partículas (construir estructuras)
- Todas estas interacciones requieren actualización eficiente sin re-renderizar todo

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI) - No afectado (endpoints de actualización pueden implementarse en el futuro)
- [x] Frontend (Three.js) - Principalmente afectado
- [ ] Base de Datos (PostgreSQL) - No afectado (ya soporta interacciones)
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (InstancedMesh, Vector3, frustum culling)
- Performance API (para medir FPS y adaptar)
- InstancedMesh permite actualizar instancias individuales sin recrear mesh completo

### Archivos/Componentes Principales

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js` - Usar `limitParticlesWithDensity`, integrar adaptación dinámica, implementar actualización incremental
- `frontend/src/terrain/optimizations/particle-limiter.js` - Mejorar y optimizar métodos, agregar soporte para cambios dinámicos de límite
- `frontend/src/terrain/manager.js` - Usar actualización incremental en lugar de recargar dimensión completa
- `frontend/src/terrain/systems/update-system.js` - Implementar actualización incremental de instanced meshes
- `frontend/src/core/performance/performance-manager.js` - Exponer métricas para adaptación (ya tiene `getMetrics()`)

**Nuevos archivos:**
- `frontend/src/terrain/optimizations/adaptive-limiter.js` - Limitador adaptativo basado en FPS

## Criterios de Aceptación

1. [ ] FPS mínimo de 60 cuando cámara apunta a partículas en demo 40x40m (~400k partículas) - **OBJETIVO PRINCIPAL**
2. [ ] FPS mínimo de 60 en demo 20x20m (~100k partículas)
3. [ ] Limitación con densidad reducida implementada y activa: reduce densidad de partículas lejanas (cada N partículas) manteniendo distribución visual
4. [ ] Limitación adaptativa implementada: ajusta límite según FPS actual automáticamente
5. [ ] Actualización incremental funcionando: modificar partícula individual no requiere recargar dimensión completa
6. [ ] Sistema preparado para interacciones futuras: puede actualizar/eliminar partículas individuales eficientemente
7. [ ] Sin degradación visual significativa: calidad visual aceptable con densidad reducida
8. [ ] Configuración flexible: límites y distancias configurables según hardware
9. [ ] Logs/métricas mejoradas: mostrar estrategia aplicada, FPS, partículas renderizadas

## Detalles de Implementación

### Consideraciones Técnicas

**Performance:**
- Activar `limitParticlesWithDensity()` en lugar de `limitParticles()` (método ya existe)
- Implementar adaptación dinámica basada en FPS actual con debounce para estabilidad
- Optimizar cálculo de distancias reutilizando cálculos de LOD cuando sea posible
- Implementar actualización incremental usando `instanceMatrix.setMatrixAt()` de Three.js
- Mantener índice de partículas para acceso rápido: `Map<particleId, {meshKey, instanceIndex}>`

**Interacciones Futuras:**
- Actualización incremental es crítica para gameplay fluido
- Sistema debe manejar cambios de tipo de partícula (ej: agua → aire cuando se recolecta)
- Batch updates son esenciales para acciones que afectan múltiples partículas (ej: talar árbol)
- Mantener sincronización entre cache local (`currentParticles`) y renderizado (`instancedMeshes`)

**Estrategias propuestas:**

1. **Limitación con Densidad Reducida (ACTIVAR existente):**
   - Cercanas (< 20m): 100% de partículas
   - Medianas (20-50m): 50% de partículas (cada 2)
   - Lejanas (> 50m): 25% de partículas (cada 4)
   - **Mantiene distribución visual** (no solo toma las N más cercanas)

2. **Limitación Adaptativa (NUEVO):**
   - Si FPS < 45: Reducir límite a 80k partículas
   - Si FPS 45-55: Límite 100k partículas
   - Si FPS 55-59: Límite 120k partículas
   - Si FPS >= 60: Límite 150k partículas (máximo)
   - Debounce de 2-3 segundos para evitar oscilación

3. **Actualización Incremental (NUEVO - Crítico para interacciones):**
   - Mantener índice: `particleIndex: Map<particleId, {meshKey, instanceIndex}>`
   - Actualizar instancia: `instancedMesh.setMatrixAt(instanceIndex, newMatrix)`
   - Eliminar instancia: Marcar como invisible (escala 0) o actualizar matriz fuera de vista
   - No recrear instanced mesh completo al modificar una partícula

4. **Optimizaciones Adicionales (Si es necesario):**
   - Reducir `MAX_INSTANCES_PER_MESH` de 100k a 50k si draw calls siguen siendo altos
   - Optimizar ordenamiento para una sola pasada cuando sea posible
   - Priorización por tipo de partícula para mantener tipos importantes visibles

**Compatibilidad:**
- Mantener API existente de `ParticleLimiter` cuando sea posible
- Hacer estrategias configurables
- No romper funcionalidad existente
- Permitir deshabilitar adaptación dinámica si es necesario

**Escalabilidad:**
- Las estrategias deben funcionar con cualquier cantidad de partículas
- Preparar para futuras mejoras (occlusion culling, chunking espacial)
- Sistema debe soportar miles de interacciones sin degradación

### Optimizaciones Propuestas

**1. Activar limitación con densidad:**
```javascript
// En ParticleRenderer.renderParticles(), cambiar de:
particlesToRender = this.particleLimiter.limitParticles(...)

// A:
particlesToRender = this.particleLimiter.limitParticlesWithDensity(
    particlesToRender,
    cameraPosition,
    cellSize,
    20,  // nearDistance (metros)
    50   // farDistance (metros)
);
```

**2. Implementar adaptación dinámica:**
```javascript
// Crear AdaptiveLimiter
class AdaptiveLimiter {
    constructor(performanceManager) {
        this.performanceManager = performanceManager;
        this.currentLimit = 150000;
        this.lastAdjustmentTime = 0;
        this.adjustmentDebounce = 2000; // 2 segundos
    }
    
    getCurrentLimit() {
        const fps = this.performanceManager.getMetrics().fps;
        const now = performance.now();
        
        // Debounce
        if (now - this.lastAdjustmentTime < this.adjustmentDebounce) {
            return this.currentLimit;
        }
        
        // Ajustar según FPS
        let newLimit;
        if (fps < 45) {
            newLimit = 80000;
        } else if (fps < 55) {
            newLimit = 100000;
        } else if (fps < 59) {
            newLimit = 120000;
        } else {
            newLimit = 150000;
        }
        
        if (newLimit !== this.currentLimit) {
            this.currentLimit = newLimit;
            this.lastAdjustmentTime = now;
        }
        
        return this.currentLimit;
    }
}
```

**3. Implementar actualización incremental:**
```javascript
// En ParticleRenderer
class ParticleRenderer {
    constructor(...) {
        // ... existente ...
        this.particleIndex = new Map(); // particleId -> {meshKey, instanceIndex}
    }
    
    // Mantener índice al renderizar
    renderParticles(particles, ...) {
        // ... renderizado existente ...
        
        // Actualizar índice
        instancedMeshes.forEach((mesh, meshKey) => {
            mesh.particles.forEach((particle, instanceIndex) => {
                this.particleIndex.set(particle.id, { meshKey, instanceIndex });
            });
        });
    }
    
    // Actualizar partícula individual
    updateParticleInstance(particleId, newData) {
        const index = this.particleIndex.get(particleId);
        if (!index) return;
        
        const mesh = this.currentMeshes.get(index.meshKey);
        if (!mesh) return;
        
        if (newData === null) {
            // Eliminar: marcar como invisible o mover fuera de vista
            const matrix = new THREE.Matrix4();
            matrix.setPosition(-1000, -1000, -1000); // Fuera de vista
            mesh.setMatrixAt(index.instanceIndex, matrix);
        } else {
            // Actualizar posición
            const matrix = new THREE.Matrix4();
            matrix.setPosition(
                newData.celda_x * cellSize,
                newData.celda_z * cellSize,
                newData.celda_y * cellSize
            );
            mesh.setMatrixAt(index.instanceIndex, matrix);
        }
        
        mesh.instanceMatrix.needsUpdate = true;
    }
}
```

### Dependencias

- Depende de: JDG-007 (Optimización de Rendimiento del Frontend), JDG-047/048/049 (Optimizaciones de FPS)
- Bloquea: Funcionalidades de interacción con terreno (romper, recolectar, farmear) - estas requieren actualización incremental para ser viables
- Relacionado con: JDG-024 (Sistema de Ambiente - detección de agua para recolectar), futuros tickets de interacción con partículas

## Testing

### Testing Manual

1. **Demo 40x40m con cámara apuntando a partículas (Objetivo principal):**
   - Cargar demo completo (~400k partículas)
   - Apuntar cámara hacia el terreno
   - Verificar que limitación con densidad funciona
   - Verificar que adaptación dinámica ajusta límite según FPS
   - **Objetivo: Alcanzar 60 FPS estables**
   - Verificar que calidad visual se mantiene aceptable

2. **Cámara apuntando al cielo:**
   - Verificar que FPS se mantiene alto (confirmar que frustum culling funciona bien)
   - Comparar con FPS cuando apunta a partículas

3. **Adaptación dinámica:**
   - Simular diferentes cargas de FPS moviendo cámara
   - Verificar que límite se ajusta correctamente con debounce
   - Verificar que FPS mejora con ajuste
   - Verificar que no oscila entre límites

4. **Limitación con densidad:**
   - Verificar que partículas cercanas se mantienen al 100%
   - Verificar que partículas lejanas se reducen correctamente
   - Verificar que distribución visual se mantiene (no hay "huecos" visibles)
   - Verificar que partículas importantes (agua) se mantienen cuando es posible

5. **Actualización incremental (cuando esté implementado):**
   - Simular romper una partícula
   - Verificar que solo se actualiza esa instancia específica
   - Verificar que NO se recarga toda la dimensión
   - Verificar que no hay stutters o lag
   - Medir tiempo de actualización (debe ser < 1ms para una partícula)

6. **Batch updates:**
   - Simular talar árbol (múltiples partículas)
   - Verificar que actualización en batch es eficiente
   - Verificar que no hay lag perceptible

### Casos Edge a Considerar

- Cámara muy cerca del terreno (todas las partículas cercanas, alta densidad)
- Cámara muy lejana (todas las partículas lejanas, baja densidad)
- Cambio rápido de dirección de cámara (adaptación debe ser suave)
- Terrenos con distribución desigual de partículas
- Múltiples tipos de partículas con diferentes importancias visuales
- Actualización de partícula mientras se está renderizando (race conditions)
- Partícula que cambia de tipo (ej: agua → aire) y necesita cambiar mesh

## Estimación

- **Complejidad:** Media-Alta
- **Tiempo estimado:** 10-14 horas
- **Notas:** 
  - Requiere pruebas iterativas para encontrar límites y distancias óptimas
  - Puede requerir ajustes finos según resultados de profiling
  - Implementación incremental: densidad primero, luego adaptación, luego actualización incremental
  - Actualización incremental es crítica para interacciones futuras
  - Requiere pruebas exhaustivas para asegurar calidad visual y rendimiento

## Referencias

- **Análisis de arquitectura:** `instructions/analysis/JDG-008-architecture-analysis_2026-01-10_14-27-10.md`
- **Relacionado con:** JDG-007 (Optimización de Rendimiento del Frontend), JDG-047/048/049 (Optimizaciones de FPS)
- **Documentación relevante:**
  - `frontend/src/terrain/optimizations/particle-limiter.js` - Implementación actual (tiene `limitParticlesWithDensity` sin usar)
  - `frontend/src/terrain/renderers/particle-renderer.js` - Renderizador principal
  - `frontend/src/terrain/manager.js` - TerrainManager (actualmente recarga todo al actualizar partícula)
  - `frontend/src/terrain/systems/update-system.js` - Sistema de actualización (preparar para incremental)
  - Three.js InstancedMesh documentation (para actualización incremental)
- **Problema identificado:** FPS bajísimos cuando cámara apunta a partículas vs OK cuando apunta al cielo
- **Contexto futuro:** Necesidad de mantener funcionalidades de interacción (romper, recolectar, farmear)

## Notas Adicionales

- El método `limitParticlesWithDensity` ya existe en `ParticleLimiter` pero no se está usando actualmente
- `ParticleRenderer` usa `limitParticles()` que solo toma las N más cercanas sin considerar densidad espacial
- El problema de FPS bajo cuando cámara apunta a partículas vs cielo indica que frustum culling no es suficiente - se necesitan estrategias más agresivas
- Actualización incremental es crítica: sin esto, las interacciones futuras (romper, recolectar) causarán stutters al recargar toda la dimensión
- Three.js InstancedMesh permite actualizar instancias individuales usando `setMatrixAt()` sin recrear el mesh completo
- Considerar hacer las estrategias configurables para ajustar según hardware del usuario
- Implementar métricas detalladas para monitorear efectividad de cada estrategia
- Profiling continuo es crucial para identificar límites y distancias óptimas
- Las optimizaciones deben funcionar sin romper funcionalidad existente
- Preparar para futuras optimizaciones (occlusion culling, chunking espacial) si es necesario
