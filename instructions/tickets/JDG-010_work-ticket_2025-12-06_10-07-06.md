# JDG-010 - Primer Personaje Jugable (Humano)

## Tipo
- [x] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [x] Alta (bloquea funcionalidad crítica)
- [ ] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

Se necesita implementar el primer personaje jugable del juego: un humano que pueda ser controlado por el jugador con las siguientes acciones básicas:
- **Agacharse**: Reducir altura del personaje para pasar por espacios bajos
- **Caminar**: Movimiento básico en todas las direcciones
- **Correr**: Movimiento rápido (más rápido que caminar)
- **Saltar**: Salto vertical para superar obstáculos o terrenos elevados
- **Golpear**: Acción de ataque/impacto con las manos o herramientas
- **Agarrar**: Interacción para tomar objetos o partículas del mundo

Este personaje será la base para futuras expansiones del sistema de jugadores y NPCs.

### Comportamiento Actual

Actualmente el juego solo permite visualizar el terreno y las partículas desde una cámara orbital (OrbitControls). No existe ningún sistema de personajes jugables, controles de jugador, física de movimiento, ni interacciones con el mundo.

### Comportamiento Esperado

**Sistema de Personaje:**
- Personaje humano renderizado en Three.js (modelo 3D básico o primitivo)
- Posición del personaje sincronizada con el terreno (coordenadas x, y, z en celdas)
- Personaje visible en la escena y controlable por el jugador
- Cámara que sigue al personaje (tercera persona o primera persona)

**Controles de Movimiento:**
- **WASD** o **Flechas**: Movimiento en 4 direcciones (adelante, atrás, izquierda, derecha)
- **Shift + WASD**: Correr (velocidad aumentada)
- **Espacio**: Saltar (solo si está en el suelo)
- **Ctrl** o **C**: Agacharse (mantener presionado)
- **Click Izquierdo**: Golpear
- **Click Derecho** o **E**: Agarrar/interactuar

**Física y Colisiones:**
- Detección de colisión con el terreno (partículas sólidas)
- Gravedad aplicada al personaje
- Detección de suelo para permitir saltos
- Prevención de atravesar partículas sólidas

**Acciones:**
- **Golpear**: Animación/acción que puede afectar partículas cercanas
- **Agarrar**: Sistema de interacción que permite tomar partículas u objetos del mundo

**Renderizado:**
- Personaje visible en la escena 3D
- Animaciones básicas (idle, caminar, correr, saltar, agacharse)
- Orientación del personaje según dirección de movimiento

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI) - Posiblemente para guardar posición del jugador
- [x] Frontend (Three.js) - Sistema completo de personaje jugable
- [ ] Base de Datos (PostgreSQL) - Posiblemente para persistir estado del jugador
- [ ] Cache (Redis) - No afectado inicialmente
- [ ] Docker/Infraestructura - No afectado
- [ ] API Endpoints - Posiblemente endpoints para guardar/cargar posición
- [ ] WebSockets - Posiblemente para sincronización en tiempo real (futuro)

### Tecnologías Involucradas
- **Three.js**: Renderizado 3D del personaje, cámara, escena
- **JavaScript ES6+**: Lógica de movimiento, física, controles
- **Cannon.js** o **Ammo.js** (opcional): Motor de física para colisiones y gravedad
- **Keyboard API**: Detección de teclas presionadas
- **Mouse Events**: Detección de clicks para golpear y agarrar
- **Animation Mixer** (Three.js): Sistema de animaciones del personaje

### Archivos/Componentes Principales

**Frontend - Nuevos archivos:**
- `frontend/src/entities/player.js` - Clase principal del personaje jugable
- `frontend/src/entities/player-controller.js` - Sistema de controles de entrada
- `frontend/src/entities/player-physics.js` - Sistema de física y colisiones
- `frontend/src/entities/player-animations.js` - Sistema de animaciones
- `frontend/src/entities/player-renderer.js` - Renderizado del modelo 3D del personaje
- `frontend/src/systems/collision-detector.js` - Detección de colisiones con partículas
- `frontend/src/systems/input-manager.js` - Gestor centralizado de inputs (teclado, mouse)

**Frontend - Archivos a modificar:**
- `frontend/src/app.js` - Integrar personaje en el loop principal
- `frontend/src/core/scene.js` - Agregar personaje a la escena
- `frontend/src/core/camera.js` - Modificar cámara para seguir al personaje
- `frontend/src/core/controls.js` - Deshabilitar OrbitControls cuando el personaje está activo

**Backend - Posibles archivos (opcional inicial):**
- `backend/src/api/routes/players.py` - Endpoints para guardar/cargar posición del jugador
- `backend/src/database/models/player.py` - Modelo de datos del jugador

## Criterios de Aceptación

1. [ ] El personaje se renderiza correctamente en la escena 3D del terreno de prueba
2. [ ] El personaje puede moverse en 4 direcciones usando WASD o flechas
3. [ ] El personaje puede correr manteniendo Shift + dirección de movimiento
4. [ ] El personaje puede saltar presionando Espacio (solo si está en el suelo)
5. [ ] El personaje puede agacharse manteniendo Ctrl o C
6. [ ] El personaje no atraviesa partículas sólidas del terreno
7. [ ] El personaje tiene gravedad y cae si no hay suelo debajo
8. [ ] El personaje puede golpear con click izquierdo (visual y funcional)
9. [ ] El personaje puede agarrar/interactuar con click derecho o E
10. [ ] La cámara sigue al personaje (tercera persona o primera persona)
11. [ ] El personaje se orienta según la dirección de movimiento
12. [ ] Las animaciones básicas funcionan (idle, caminar, correr, saltar, agacharse)
13. [ ] El sistema de colisiones detecta correctamente las partículas sólidas
14. [ ] El personaje puede interactuar con el terreno de prueba (JDG-009)

**Nota:** Cada criterio debe ser específico, medible y verificable.

## Detalles de Implementación

### Consideraciones Técnicas

**Performance:**
- El sistema de colisiones debe ser eficiente (no verificar todas las partículas, solo las cercanas)
- Las animaciones deben usar instancing o sistemas optimizados de Three.js
- El renderizado del personaje no debe afectar significativamente el FPS del renderizado de partículas

**Física:**
- Implementar sistema de gravedad simple (velocidad vertical negativa constante)
- Detección de suelo: verificar partículas sólidas en la posición (x, y, z-1)
- Detección de colisiones: verificar partículas sólidas en la dirección de movimiento
- Sistema de saltos: aplicar velocidad vertical positiva al presionar Espacio

**Controles:**
- Sistema de input centralizado que detecte teclas presionadas
- Estados de movimiento (idle, caminando, corriendo, saltando, agachado)
- Transiciones suaves entre estados
- Prevención de acciones múltiples simultáneas cuando corresponda

**Renderizado:**
- Modelo 3D básico del personaje (puede ser primitivo inicial: cilindro + esfera para cabeza)
- Sistema de animaciones usando AnimationMixer de Three.js
- Orientación del personaje usando quaternions o euler angles
- Sombra del personaje (opcional pero recomendado)

**Colisiones:**
- Sistema de detección que consulte las partículas del viewport actual
- Verificar partículas en posición actual y posiciones adyacentes
- Considerar tamaño de celda (0.25m) para cálculos de colisión
- Optimizar consultas usando el sistema de viewport existente

**Cámara:**
- Modo tercera persona: cámara detrás y arriba del personaje
- Modo primera persona: cámara en la posición de la cabeza del personaje
- Transición suave entre modos (opcional)
- Cámara que rota con el personaje o independientemente

### Pasos de Implementación

**Fase 1: Sistema Base del Personaje**
1. Crear clase `Player` con posición (x, y, z) y estado básico
2. Crear renderizado básico del personaje (primitivo Three.js)
3. Integrar personaje en la escena
4. Implementar sistema de input básico (teclado)

**Fase 2: Movimiento y Física**
1. Implementar movimiento básico (WASD)
2. Implementar sistema de gravedad
3. Implementar detección de suelo
4. Implementar sistema de saltos
5. Implementar sistema de colisiones con partículas

**Fase 3: Acciones Avanzadas**
1. Implementar correr (Shift + movimiento)
2. Implementar agacharse (Ctrl/C)
3. Implementar golpear (click izquierdo)
4. Implementar agarrar (click derecho/E)

**Fase 4: Cámara y Animaciones**
1. Implementar cámara que sigue al personaje
2. Implementar orientación del personaje
3. Implementar animaciones básicas (idle, caminar, correr, saltar, agacharse)
4. Integrar AnimationMixer

**Fase 5: Refinamiento**
1. Ajustar velocidades y parámetros de física
2. Mejorar detección de colisiones
3. Optimizar rendimiento
4. Agregar feedback visual (partículas al golpear, etc.)

### Dependencias

- **Depende de:** JDG-009 (Terreno de Prueba) - Para probar el personaje en un terreno controlado
- **Depende de:** Sistema de renderizado de partículas existente - Para detectar colisiones
- **Bloquea:** Tickets futuros de interacción con el mundo (recolección, construcción, combate)
- **Bloquea:** Tickets futuros de NPCs (usará sistema similar)

## Testing

### Escenarios de Prueba

1. **Movimiento básico:**
   - Presionar W: personaje se mueve hacia adelante
   - Presionar S: personaje se mueve hacia atrás
   - Presionar A: personaje se mueve hacia la izquierda
   - Presionar D: personaje se mueve hacia la derecha
   - Presionar Shift + W: personaje corre hacia adelante (más rápido)

2. **Física y colisiones:**
   - Personaje cae si no hay suelo debajo
   - Personaje no atraviesa partículas sólidas (tierra, piedra)
   - Personaje puede caminar sobre partículas sólidas
   - Personaje no puede caminar a través de partículas sólidas

3. **Saltos:**
   - Presionar Espacio en el suelo: personaje salta
   - Presionar Espacio en el aire: no salta (solo una vez)
   - Personaje cae después del salto

4. **Agacharse:**
   - Presionar Ctrl/C: personaje se agacha (altura reducida)
   - Soltar Ctrl/C: personaje vuelve a altura normal
   - Personaje puede moverse mientras está agachado

5. **Acciones:**
   - Click izquierdo: personaje ejecuta acción de golpear
   - Click derecho/E: personaje ejecuta acción de agarrar
   - Acciones funcionan en dirección que mira el personaje

6. **Cámara:**
   - Cámara sigue al personaje cuando se mueve
   - Cámara rota con el personaje o independientemente
   - Cámara no atraviesa objetos

7. **Orientación:**
   - Personaje se orienta hacia la dirección de movimiento
   - Personaje mantiene orientación al detenerse

8. **Animaciones:**
   - Animación idle cuando está quieto
   - Animación caminar cuando se mueve
   - Animación correr cuando corre
   - Animación saltar cuando salta
   - Animación agacharse cuando está agachado

### Casos Edge a Considerar

- Personaje en el borde del terreno (prevenir caída infinita o teleportar)
- Personaje dentro de partículas sólidas (corrección de posición)
- Múltiples teclas presionadas simultáneamente
- Personaje saltando y golpeando simultáneamente
- Personaje agachado y moviéndose en espacios bajos
- Personaje intentando agarrar partículas que no existen
- Personaje en áreas con muchas partículas (performance de colisiones)
- Cámara colisionando con objetos cuando sigue al personaje
- Personaje moviéndose muy rápido (prevenir atravesar partículas)

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 20-30 horas
- **Notas:**
  - Sistema completo desde cero (no existe base previa)
  - Requiere implementar física, colisiones, animaciones, controles
  - Puede requerir iteraciones para ajustar parámetros
  - Sistema de colisiones puede ser complejo de optimizar
  - Animaciones pueden requerir modelos 3D o sistemas de animación

## Referencias

- **Relacionado con:** JDG-009 (Terreno de Prueba) - Terreno donde se probará el personaje
- **Documentación relevante:**
  - Three.js Animation System: https://threejs.org/docs/#manual/en/animation/AnimationMixer
  - Three.js Camera Controls: https://threejs.org/docs/#examples/en/controls/OrbitControls
  - Keyboard Events API: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent
  - Mouse Events API: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
  - Cannon.js Physics: https://github.com/schteppe/cannon.js (opcional)
  - `frontend/src/core/controls.js` - Sistema de controles existente (OrbitControls)
  - `frontend/src/app.js` - Loop principal de la aplicación
  - `frontend/src/core/scene.js` - Gestión de la escena 3D
- **Discusiones previas:** Necesidad identificada para crear el primer humano jugable

## Notas Adicionales

- **Modelo 3D inicial:** Puede ser un primitivo simple (cilindro para cuerpo, esfera para cabeza) para MVP. Modelos más detallados pueden agregarse después.
- **Física simple:** Inicialmente puede implementarse física simple sin motor externo (Cannon.js/Ammo.js). Si se requiere física más compleja, considerar integrar un motor.
- **Colisiones optimizadas:** El sistema de colisiones debe ser eficiente. Considerar usar el viewport actual para limitar las partículas a verificar.
- **Cámara:** Decidir entre primera persona o tercera persona (o ambas con toggle). Tercera persona es más común para juegos de este tipo.
- **Animaciones:** Inicialmente pueden ser simples (cambios de escala, rotación). Animaciones más complejas requieren modelos 3D con bones.
- **Interacción con partículas:** El sistema de "agarrar" debe poder identificar partículas cercanas y permitir interactuar con ellas. Esto puede requerir endpoints de API para modificar partículas.
- **Persistencia:** Considerar si la posición del jugador debe guardarse en la base de datos o solo en memoria del cliente inicialmente.
- **Extensibilidad:** El sistema debe ser extensible para futuras acciones (construir, usar herramientas, combate, etc.).

