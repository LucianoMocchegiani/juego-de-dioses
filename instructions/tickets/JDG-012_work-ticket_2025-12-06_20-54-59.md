# JDG-012 - Sistema de Modelos 3D para Personajes

## Tipo
- [x] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

Actualmente los personajes se renderizan usando geometrías primitivas (esfera, cilindros) definidas en `geometria_agrupacion`. Se requiere implementar un sistema para almacenar y cargar modelos 3D reales (GLTF/GLB, OBJ, etc.) desde la base de datos, permitiendo personajes con modelos más detallados y realistas.

El modelo debe estar almacenado en el backend (BD o sistema de archivos), y al entrar al juego, el frontend debe cargarlo desde la BD y renderizarlo como mesh en Three.js.

### Comportamiento Actual

- Los personajes se renderizan usando primitivas Three.js (SphereGeometry, CylinderGeometry)
- La geometría se define en `geometria_agrupacion` como JSON con tipos y parámetros
- El sistema funciona pero es limitado a formas geométricas simples
- No hay soporte para modelos 3D complejos con texturas, animaciones, etc.

### Comportamiento Esperado

- Los modelos 3D se almacenan en el backend (BD o sistema de archivos)
- Cada personaje puede tener un modelo 3D asociado en su agrupación
- El frontend carga el modelo desde la BD/API al inicializar el personaje
- El modelo se renderiza usando Three.js loaders (GLTFLoader, OBJLoader, etc.)
- El sistema mantiene compatibilidad con el sistema actual (fallback a primitivas)
- Los modelos pueden tener texturas, materiales, y opcionalmente animaciones

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [x] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Python 3.11, FastAPI, asyncpg
- Three.js, JavaScript ES6+
- GLTFLoader, OBJLoader (Three.js loaders)
- PostgreSQL 16 (JSONB para metadatos de modelos)
- Sistema de archivos o almacenamiento de objetos (S3, local, etc.)
- Opcional: GLB/GLTF para modelos optimizados

### Archivos/Componentes Principales
- `backend/src/api/routes/characters.py` - Agregar endpoint para servir modelos
- `backend/src/models/schemas.py` - Agregar schema para modelo 3D
- `backend/src/database/builders/biped_builder.py` - Agregar soporte para modelos
- `frontend/src/ecs/factories/player-factory.js` - Cargar y renderizar modelos 3D
- `frontend/src/renderers/model-loader.js` - Nuevo: Loader de modelos 3D
- `frontend/src/api/endpoints/characters.js` - Agregar método para obtener modelo
- Base de datos: Tabla o campo para almacenar referencias a modelos

## Criterios de Aceptación

1. [ ] Existe sistema para almacenar modelos 3D en el backend (BD o sistema de archivos)
2. [ ] Los modelos se pueden asociar a personajes en la agrupación
3. [ ] Existe endpoint de API para obtener modelo 3D de un personaje
4. [ ] El frontend puede cargar modelos GLTF/GLB desde la API
5. [ ] El frontend puede cargar modelos OBJ desde la API (opcional)
6. [ ] El modelo se renderiza correctamente en Three.js
7. [ ] El sistema mantiene compatibilidad con primitivas (fallback si no hay modelo)
8. [ ] Los modelos pueden tener texturas y materiales
9. [ ] El sistema maneja errores correctamente (modelo no encontrado, formato no soportado, etc.)
10. [ ] Los modelos se cachean en el frontend para evitar recargas innecesarias
11. [ ] La posición y escala del modelo se respetan según configuración de la agrupación
12. [ ] Documentación de cómo agregar nuevos modelos al sistema

**Nota:** Cada criterio debe ser específico, medible y verificable.

## Detalles de Implementación

### Consideraciones Técnicas

**Almacenamiento de Modelos:**
- **Opción A**: Almacenar modelos en sistema de archivos del backend, referencias en BD
- **Opción B**: Almacenar modelos en BD como BLOB (no recomendado para archivos grandes)
- **Opción C**: Almacenar modelos en servicio externo (S3, CDN), URLs en BD
- **Recomendación**: Opción A o C (sistema de archivos o servicio externo)

**Formato de Modelos:**
- **GLTF/GLB**: Formato recomendado (optimizado, soporta texturas, materiales, animaciones)
- **OBJ**: Formato alternativo (más simple, ampliamente soportado)
- **FBX**: Formato avanzado (requiere licencia, más complejo)

**Estructura de Datos:**
```json
{
  "modelo_3d": {
    "tipo": "gltf",
    "ruta": "/models/characters/humano.glb",
    "escala": 1.0,
    "offset": {"x": 0, "y": 0, "z": 0},
    "rotacion": {"x": 0, "y": 0, "z": 0}
  }
}
```

**Performance:**
- Cachear modelos cargados en el frontend
- Usar instancing si múltiples personajes usan el mismo modelo
- Optimizar modelos (reducir polígonos, comprimir texturas)
- Lazy loading: cargar modelos solo cuando se necesitan

**Seguridad:**
- Validar rutas de archivos para prevenir path traversal
- Validar tipos de archivo permitidos
- Limitar tamaño de archivos
- Sanitizar nombres de archivos

**Compatibilidad:**
- Mantener sistema actual de primitivas como fallback
- Si no hay modelo 3D, usar `geometria_agrupacion` actual
- Migración gradual: personajes pueden tener modelo o primitivas

### Dependencias
- Depende de: JDG-011 (Sistema de Personajes desde BD)
- Bloquea: (ninguno por ahora)

## Testing

### Escenarios de Prueba
1. **Cargar personaje con modelo GLTF**: Crear personaje con modelo GLTF asociado, verificar que se carga y renderiza correctamente
2. **Cargar personaje sin modelo**: Verificar que usa fallback a primitivas
3. **Modelo no encontrado**: Intentar cargar personaje con modelo inexistente, verificar fallback
4. **Múltiples personajes con mismo modelo**: Verificar que se cachea correctamente
5. **Modelo con texturas**: Verificar que texturas se cargan y aplican correctamente
6. **Modelo con animaciones**: Verificar que animaciones se pueden reproducir (si se implementa)
7. **Diferentes formatos**: Probar GLTF, GLB, OBJ (si se soportan)
8. **Escala y posición**: Verificar que offset y escala se aplican correctamente

### Casos Edge a Considerar
- Modelo muy grande (más de 10MB) - ¿límite de tamaño?
- Modelo corrupto o formato inválido - manejo de errores
- Modelo sin texturas - renderizado con materiales por defecto
- Múltiples personajes cargando simultáneamente - performance
- Modelo con jerarquía compleja - manejo de grupos y transformaciones
- Modelo con múltiples materiales - aplicación correcta de materiales
- Conexión lenta - mostrar placeholder mientras carga
- Modelo que falla al cargar - fallback a primitivas

## Estimación

- **Complejidad:** Media-Alta
- **Tiempo estimado:** 3-5 días
- **Notas:** 
  - Depende de la decisión de almacenamiento (archivos vs servicio externo)
  - Implementar loaders de Three.js es relativamente simple
  - La integración con el sistema actual requiere cuidado para mantener compatibilidad
  - Testing de diferentes formatos y casos edge puede tomar tiempo adicional

## Referencias

- **Relacionado con:** JDG-011 (Sistema de Personajes desde BD)
- **Documentación relevante:**
  - Three.js GLTFLoader: https://threejs.org/docs/#examples/en/loaders/GLTFLoader
  - Three.js OBJLoader: https://threejs.org/docs/#examples/en/loaders/OBJLoader
  - GLTF Specification: https://www.khronos.org/gltf/
  - `frontend/src/ecs/factories/player-factory.js` - Sistema actual de renderizado
  - `backend/src/database/builders/biped_builder.py` - Builder de personajes
- **Discusiones previas:** Arquitectura de modelos 3D para objetos únicos (Ideas/17-Objetos-Unicos-y-Rasgos.md)

## Notas Adicionales

**Decisiones de Diseño Pendientes:**
1. ¿Dónde almacenar modelos? (sistema de archivos, S3, BD)
2. ¿Qué formatos soportar inicialmente? (GLTF/GLB recomendado)
3. ¿Soporte para animaciones? (puede ser fase 2)
4. ¿Sistema de variaciones de modelos? (diferentes modelos para mismo personaje)
5. ¿Optimización de modelos? (reducción de polígonos, compresión)

**Fases de Implementación Sugeridas:**
- **Fase 1**: Almacenamiento básico y carga de modelos GLTF/GLB
- **Fase 2**: Soporte para texturas y materiales
- **Fase 3**: Sistema de cache y optimizaciones
- **Fase 4**: Soporte para animaciones (opcional)
- **Fase 5**: Sistema de variaciones y personalización

**Alternativas Consideradas:**
- Usar solo primitivas mejoradas (más formas geométricas)
- Sistema híbrido: primitivas para LOD bajo, modelos para LOD alto
- Generación procedural de modelos (más complejo, menos control artístico)

