# JDG-014 - Sistema de Daño por Partes del Cuerpo (Limb Damage System)

## Tipo
- [x] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [ ] Media (importante pero no bloqueante)
- [x] Baja (mejora o nice-to-have)

## Estado
**⚠️ POSPUESTO PARA MÁS ADELANTE** - Este ticket está documentado pero no se implementará en el corto plazo. Se mantiene como referencia para futura implementación.

## Descripción

### Problema/Requerimiento

Implementar un sistema avanzado donde cada parte del cuerpo (cabeza, brazos, piernas, torso) puede ser cortada/dañada, afectando el gameplay de manera significativa y permitiendo que las partes cortadas sean objetos físicos recogibles en el mundo del juego.

Este sistema añade profundidad táctica al combate, permitiendo que los jugadores puedan desmembrar enemigos y que las partes cortadas tengan efectos mecánicos reales (muerte instantánea si se corta la cabeza, inmovilización si se cortan las piernas, etc.).

### Comportamiento Actual

- Los personajes tienen un modelo único sin diferenciación de partes del cuerpo
- El sistema de daño es global (vida total) sin considerar partes específicas
- No hay sistema de desmembramiento o corte de partes
- No hay objetos físicos de partes cortadas en el mundo
- No hay efectos de gameplay basados en partes del cuerpo dañadas

### Comportamiento Esperado

- **Modelo único con grupos de vértices**: Cada parte del cuerpo es un grupo de vértices nombrado (cabeza, brazos, piernas, torso)
- **Sistema híbrido de núcleos**: 
  - Núcleo principal (torso) = vida total
  - Núcleos secundarios (cabeza, brazos, piernas) = partes críticas
- **Partes cortadas como objetos físicos**: Cuando se corta una parte, se convierte en objeto independiente en el suelo
- **Regeneración**: Las partes pueden regenerarse, haciendo desaparecer las partes cortadas del suelo
- **Animaciones de corte**: Animación visual cuando se corta una parte
- **Partes recogibles**: Las partes cortadas pueden ser recogidas/usadas
- **Efectos de Gameplay**:
  - Cabeza cortada → Muerte instantánea
  - Torso dañado → Muerte instantánea
  - Piernas cortadas → Inmovilización o reducción de velocidad
  - Brazos cortados → No puede atacar

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Python 3.11, FastAPI, asyncpg
- Three.js, JavaScript ES6+
- PostgreSQL 16
- GLB/GLTF models con vertex groups
- TWEEN.js (opcional) - Para animaciones suaves
- Cannon.js / Ammo.js (opcional) - Para física avanzada

### Archivos/Componentes Principales

**Backend:**
- `backend/src/database/schemas.py` - Agregar campo `partes_criticas` a schema `Model3D`
- `backend/src/services/particula_service.py` - Sistema de núcleos híbrido
- `backend/src/api/routes/agrupaciones.py` - Endpoints para partes cortadas

**Frontend:**
- `frontend/src/ecs/components/limb-damage.js` - Nuevo componente `LimbDamageComponent`
- `frontend/src/ecs/systems/limb-damage-system.js` - Nuevo sistema `LimbDamageSystem`
- `frontend/src/ecs/systems/limb-regeneration-system.js` - Nuevo sistema `LimbRegenerationSystem`
- `frontend/src/ecs/systems/pickup-system.js` - Sistema de recogida de partes
- `frontend/src/factories/player-factory.js` - Modificar para cargar grupos de vértices

**Base de Datos:**
- `database/init/schemas.sql` - Agregar campo `partes_criticas` JSONB a `modelo_3d`
- Migraciones para soportar núcleos secundarios

## Criterios de Aceptación

1. [ ] Campo `partes_criticas` agregado a schema `Model3D` en base de datos
2. [ ] Componente `LimbDamageComponent` implementado con estructura de partes
3. [ ] Sistema `LimbDamageSystem` detecta destrucción de núcleos secundarios
4. [ ] Sistema separa visualmente las partes del modelo cuando se cortan
5. [ ] Animación de corte funciona correctamente (física o keyframe)
6. [ ] Partes cortadas se convierten en objetos físicos en el suelo
7. [ ] Efectos de gameplay se aplican correctamente (muerte, no atacar, reducir velocidad)
8. [ ] Sistema de regeneración funciona según tiempos configurados
9. [ ] Partes cortadas pueden ser recogidas por el jugador
10. [ ] Sistema de sincronización funciona en multijugador (WebSocket)

## Detalles de Implementación

### Consideraciones Técnicas

- **Performance**: Limitar número de partes cortadas en el mundo, usar instancing si múltiples partes del mismo tipo, pool de objetos para reutilizar partes cortadas
- **Sincronización**: Partes cortadas deben sincronizarse entre clientes (WebSocket), estado de regeneración debe ser consistente
- **Física**: Considerar usar librería de física (Cannon.js, Ammo.js) para objetos físicos, o implementar física simple con Three.js
- **Vertex Groups**: Los modelos GLB deben tener vertex groups nombrados para cada parte del cuerpo
- **Núcleos Híbridos**: Sistema complejo que requiere núcleo principal (torso) y núcleos secundarios (partes críticas)

### Estructura de Datos Propuesta

#### Campo `partes_criticas` en `modelo_3d` JSONB:
```json
{
  "partes_criticas": {
    "cabeza": {
      "grupo_vertices": "head",
      "nucleo_id": "uuid-cabeza",
      "efecto_destruccion": "muerte",
      "es_critica": true,
      "puede_regenerar": true,
      "tiempo_regeneracion": 30000
    },
    "brazo_izquierdo": {
      "grupo_vertices": "left_arm",
      "nucleo_id": "uuid-brazo-izq",
      "efecto_destruccion": "no_atacar",
      "es_critica": false,
      "puede_regenerar": true,
      "tiempo_regeneracion": 20000
    }
    // ... etc
  }
}
```

### Fases de Implementación

**Fase 1: Estructura Base**
- Agregar campo `partes_criticas` a schema `Model3D`
- Crear `LimbDamageComponent`
- Crear `LimbDamageSystem` básico
- Modificar `PlayerFactory` para cargar grupos de vértices

**Fase 2: Sistema de Corte**
- Implementar detección de destrucción de núcleos secundarios
- Implementar separación visual de partes
- Implementar animación de corte básica

**Fase 3: Objetos Físicos**
- Crear sistema de objetos físicos en el suelo
- Implementar creación de agrupaciones para partes cortadas
- Integrar con sistema de partículas

**Fase 4: Efectos de Gameplay**
- Implementar efectos (muerte, no atacar, reducir velocidad)
- Integrar con sistema de movimiento
- Integrar con sistema de combate

**Fase 5: Regeneración**
- Implementar sistema de regeneración
- Timer de regeneración
- Restauración de partes

**Fase 6: Recogida**
- Implementar sistema de recogida
- UI de interacción
- Inventario o efectos inmediatos

### Dependencias
- Depende de: JDG-013 (Reemplazar Modelo de Personaje con Human.glb) - ya completado, prepara vertex groups
- Bloquea: Ninguna (sistema independiente)

## Testing

### Escenarios de Prueba
1. **Escenario 1 - Corte de cabeza**: Verificar que cortar la cabeza causa muerte instantánea
2. **Escenario 2 - Corte de brazo**: Verificar que cortar un brazo impide atacar
3. **Escenario 3 - Corte de pierna**: Verificar que cortar una pierna reduce velocidad
4. **Escenario 4 - Objeto físico**: Verificar que parte cortada se convierte en objeto físico en el suelo
5. **Escenario 5 - Regeneración**: Verificar que parte se regenera después del tiempo configurado
6. **Escenario 6 - Recogida**: Verificar que parte cortada puede ser recogida
7. **Escenario 7 - Sincronización**: Verificar que partes cortadas se sincronizan en multijugador

### Casos Edge a Considerar
- **Múltiples partes cortadas**: Manejar correctamente cuando múltiples partes están cortadas simultáneamente
- **Regeneración simultánea**: Manejar regeneración de múltiples partes al mismo tiempo
- **Partes en inventario**: Qué sucede si se recoge una parte mientras se regenera
- **Performance con muchas partes**: Optimizar cuando hay muchas partes cortadas en el mundo

## Estimación

- **Complejidad:** Muy Alta
- **Tiempo estimado:** 40-60 horas (distribuidas en 6 fases)
- **Notas:** Sistema complejo que requiere múltiples fases de implementación. Requiere modelos GLB con vertex groups preparados. Puede requerir librerías adicionales de física.

## Referencias

- **Relacionado con:** JDG-013 (Reemplazar Modelo de Personaje con Human.glb) - prepara vertex groups
- **Documentación relevante:** 
  - `instructions/analysis/JDG-014-limb-damage-system-analysis.md` - Análisis completo del sistema
  - Three.js Groups: https://threejs.org/docs/#api/en/objects/Group
  - Three.js Object3D.getObjectByName(): https://threejs.org/docs/#api/en/core/Object3D.getObjectByName
  - GLTF Specification: https://www.khronos.org/gltf/
  - Blender Vertex Groups: https://docs.blender.org/manual/en/latest/modeling/meshes/properties/vertex_groups.html
- **Discusiones previas:** Análisis creado el 2025-12-08

## Notas Adicionales

**⚠️ IMPORTANTE - ESTADO DEL TICKET:**

Este ticket está **POSPUESTO PARA MÁS ADELANTE**. Aunque está completamente documentado y analizado, no se implementará en el corto plazo debido a:

1. **Complejidad alta**: Requiere múltiples sistemas nuevos y cambios significativos en arquitectura
2. **Dependencias de modelos**: Requiere modelos GLB con vertex groups preparados específicamente
3. **Prioridades actuales**: Hay otras funcionalidades más críticas que requieren atención primero
4. **Tiempo de desarrollo**: Estimado en 40-60 horas, requiere planificación cuidadosa

**Cuándo considerar implementar:**
- Cuando se tengan modelos GLB con vertex groups preparados
- Cuando el sistema de combate base esté completamente estable
- Cuando haya tiempo disponible para un proyecto de esta magnitud
- Cuando se necesite añadir profundidad táctica al combate

**Preparación realizada:**
- JDG-013 ya preparó el terreno almacenando `vertexGroups` y `vertexGroupsList` en `mesh.userData`
- El análisis completo está disponible en `instructions/analysis/JDG-014-limb-damage-system-analysis.md`
- La arquitectura está completamente diseñada y lista para implementación cuando se decida proceder

**Mantener este ticket como referencia** para cuando se decida implementar el sistema en el futuro.
