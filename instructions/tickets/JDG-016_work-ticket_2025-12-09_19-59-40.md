# JDG-016 - Refactorizar Sistema de Animaciones para Escalabilidad

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [x] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El sistema de animaciones actual (`AnimationSystem` y `AnimationMixerSystem`) tiene limitaciones de escalabilidad que dificultan agregar nuevas acciones o estados de animación. Actualmente, el código utiliza cadenas de `if/else` hardcodeadas con prioridades fijas, mapeos manuales de estados a animaciones, y configuración dispersa en múltiples archivos.

Cada nueva acción (por ejemplo: `block`, `dodge`, `cast_spell`, `pickup`) requiere modificar múltiples archivos y lugares del código:
- Agregar `if/else` en `AnimationSystem`
- Agregar mapeo en `AnimationMixerSystem`
- Actualizar `ANIMATION_FILES` constante
- Modificar `InputComponent` para agregar flags
- Modificar `InputSystem` para detectar input
- Reordenar prioridades manualmente si es necesario

Esto hace que el sistema sea difícil de mantener y escalar conforme se agreguen más acciones al juego.

### Comportamiento Actual

- **AnimationSystem**: Utiliza cadena de `if/else` hardcodeada con prioridades fijas (líneas 29-53)
  - Cada nueva acción requiere agregar un nuevo `if/else` en el código
  - Las prioridades están fijas en el orden del código
  - No hay separación entre condiciones y prioridades
  - Dificulta cambiar prioridades o agregar condiciones complejas

- **AnimationMixerSystem**: Mapeo manual de estados a animaciones (líneas 308-318)
  - Cada nuevo estado requiere un nuevo `else if`
  - No hay fallback automático para estados sin animación definida
  - La configuración de archivos está hardcodeada en `ANIMATION_FILES` (líneas 16-21)

- **Falta de abstracción**: 
  - Prioridades mezcladas con lógica de condiciones
  - Condiciones acopladas al código
  - No hay sistema de transiciones explícito
  - Difícil de testear individualmente

### Comportamiento Esperado

- **Sistema de configuración declarativo**: Estados, prioridades, condiciones y animaciones definidos en configuración
- **Sistema de prioridades dinámico**: Prioridades definidas como números, ordenadas automáticamente
- **Mapeo declarativo**: Tabla/mapa de estado → animación con fallback automático
- **Separación de responsabilidades**: 
  - `AnimationStateSystem`: Determina estados
  - `AnimationMixerSystem`: Reproduce animaciones
  - `AnimationConfig`: Define configuración
- **Extensibilidad**: Agregar nuevas acciones solo requiere agregar configuración, no modificar código
- **Mantenibilidad**: Cambiar prioridades o condiciones no requiere tocar lógica de negocio

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (AnimationMixer, AnimationAction)
- ECS (Entity Component System)
- Patrones de diseño: State Machine, Configuration, Strategy

### Archivos/Componentes Principales
- `frontend/src/ecs/systems/animation-system.js` - Sistema actual de determinación de estados
- `frontend/src/ecs/systems/animation-mixer-system.js` - Sistema actual de reproducción de animaciones
- `frontend/src/ecs/components/animation.js` - Componente de animación
- `frontend/src/ecs/components/input.js` - Componente de input
- `frontend/src/ecs/systems/input-system.js` - Sistema de input

## Criterios de Aceptación

1. [ ] Se puede agregar una nueva acción (ej: `block`, `dodge`) solo modificando un archivo de configuración
2. [ ] Las prioridades de estados están definidas como números y se ordenan automáticamente
3. [ ] El sistema de estados utiliza una máquina de estados finita (FSM) o sistema de configuración equivalente
4. [ ] El mapeo estado → animación está declarado en configuración, no hardcodeado
5. [ ] Agregar un nuevo estado requiere cambios mínimos (< 5 líneas) en código existente
6. [ ] Cambiar prioridades entre estados existentes solo requiere modificar configuración
7. [ ] El sistema mantiene compatibilidad con las animaciones y estados actuales (idle, walk, run, attack, jump, crouch)
8. [ ] Las transiciones entre estados son explícitas y configurables
9. [ ] El código es más testeable (se pueden testear condiciones y prioridades independientemente)
10. [ ] La documentación explica cómo agregar nuevas acciones y estados

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance**: El nuevo sistema no debe ser más lento que el actual
- **Compatibilidad**: Debe mantener compatibilidad con el código existente durante la migración
- **Escalabilidad**: Debe soportar fácilmente 20+ acciones diferentes sin degradación de performance
- **Mantenibilidad**: El código debe ser más fácil de entender y modificar

### Patrones de Diseño a Considerar

1. **State Machine (FSM)**: Para gestionar estados y transiciones
2. **Configuration Pattern**: Para definir estados y prioridades externamente
3. **Strategy Pattern**: Para diferentes estrategias de evaluación de condiciones
4. **Registry Pattern**: Para registrar y descubrir estados dinámicamente

### Dependencias
- Depende de: JDG-015 (Sistema de animaciones básico debe estar funcionando)
- Bloquea: Futuros tickets que requieran agregar nuevas acciones de animación

## Testing

### Escenarios de Prueba
1. **Agregar nueva acción**: Verificar que se puede agregar una acción `block` solo modificando configuración
2. **Cambiar prioridades**: Verificar que cambiar prioridad entre `attack` y `jump` solo requiere modificar configuración
3. **Estado sin animación**: Verificar que estados sin animación definida usan fallback apropiado
4. **Compatibilidad**: Verificar que todas las animaciones actuales (idle, walk, run, attack) siguen funcionando
5. **Transiciones**: Verificar que las transiciones entre estados son suaves y correctas
6. **Performance**: Verificar que el nuevo sistema no es más lento que el actual (benchmark)

### Casos Edge a Considerar
- Estados conflictivos con misma prioridad (definir orden de resolución)
- Animación faltante para un estado configurado (fallback a combat_stance o idle)
- Cambio de estado mientras animación anterior está en transición (manejar fadeOut/fadeIn)
- Múltiples entidades con diferentes configuraciones de animación (soportar por entidad o tipo)

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 2-3 días
- **Notas:** 
  - Requiere análisis arquitectónico detallado (JDG-016-analysis)
  - Requiere refactorización cuidadosa para no romper funcionalidad existente
  - Puede requerir migración incremental para mantener compatibilidad

## Referencias

- **Relacionado con:** JDG-015 (Animaciones básicas para personaje humano)
- **Documentación relevante:** 
  - Three.js AnimationMixer: https://threejs.org/docs/#api/en/animation/AnimationMixer
  - State Machine patterns: https://gameprogrammingpatterns.com/state.html
- **Discusiones previas:** Análisis de escalabilidad del sistema de animaciones (conversación actual)

## Notas Adicionales

Este refactor debe ser cuidadoso para no romper la funcionalidad actual. Se recomienda:
1. Realizar análisis arquitectónico completo antes de implementar (JDG-016-analysis)
2. Implementar el nuevo sistema en paralelo al actual
3. Migrar gradualmente, estado por estado
4. Mantener el sistema anterior hasta que el nuevo esté completamente probado
5. Documentar claramente cómo agregar nuevas acciones después del refactor

