# JDG-028 - Simplificación y Optimización del Sistema de Animaciones y Combate

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [x] Refactor (mejora de código sin cambiar funcionalidad)
- [x] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento
El sistema de animaciones y combate tenía múltiples problemas de arquitectura y performance:
1. **Duplicación de estado**: `AnimationComponent` copiaba `comboAnimationName` y `combatAnimationName` desde otros componentes, creando riesgo de desincronización
2. **Múltiples rutas condicionales**: Resolución de nombres de animación distribuida en varias partes del código
3. **Lógica de limpieza distribuida**: Limpieza de estado de combate duplicada en múltiples lugares
4. **Performance subóptimo**: Accesos repetidos a componentes y lookups O(n) en lugar de O(1)
5. **Código difícil de mantener**: Métodos largos (~160 líneas) con múltiples responsabilidades
6. **Valores mágicos**: Strings y constantes hardcodeadas dispersas en el código

### Comportamiento Actual
**Simplificación (JDG-028):**
- `AnimationComponent` almacena copias de `comboAnimationName` y `combatAnimationName` que pueden desincronizarse
- `AnimationStateSystem` copia nombres de animación a `AnimationComponent`
- `AnimationMixerSystem` tiene tres rutas condicionales diferentes para resolver nombres de animación
- Lógica de limpieza de estado distribuida en múltiples lugares
- Mapa `stateToAnimationMap` duplicado

**Optimización (JDG-028-2):**
- Sistemas acceden a los mismos componentes múltiples veces en el mismo frame (redundante)
- `CombatSystem` busca en arrays con `Array.find()` (O(n)) cada vez que se ejecuta una acción
- `AnimationMixerSystem.update()` tiene ~160 líneas con múltiples responsabilidades mezcladas
- Lógica de parry/dodge duplicada en dos lugares diferentes
- Magic values y strings hardcodeados dispersos en el código (`'parry'`, `'dodge'`, `0.95`, etc.)

### Comportamiento Esperado
**Simplificación:**
- Single Source of Truth: Nombres de animación se resuelven directamente desde componentes fuente (`ComboComponent.comboAnimation`, `CombatComponent.combatAnimation`)
- `AnimationStateSystem` solo determina estados, no copia nombres
- `AnimationMixerSystem` usa función centralizada `resolveAnimationName()` para resolver nombres
- Limpieza de estado centralizada en `CombatComponent.clearCombatState()`
- Eliminado mapa duplicado `stateToAnimationMap`

**Optimización:**
- Componentes se cachean al inicio del loop y se reutilizan (reduce accesos ~30-50%)
- Configuraciones se cachean en constructores (lookup O(1) en lugar de O(n))
- Métodos grandes divididos en métodos privados más pequeños y enfocados
- Lógica de parry/dodge centralizada en `CombatComponent.cleanupDefenseType()`
- Constantes centralizadas en `combat-constants.js` (evita valores mágicos)

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js
- ECS (Entity Component System)
- AnimationMixerSystem
- CombatSystem
- AnimationStateSystem

### Archivos/Componentes Principales

**Archivos Nuevos:**
- `frontend/src/config/combat-constants.js` - Constantes centralizadas para sistema de combate

**Archivos Modificados:**

**Componentes:**
- `frontend/src/ecs/components/animation.js` - Eliminadas propiedades `comboAnimationName` y `combatAnimationName`
- `frontend/src/ecs/components/combat.js` - Agregados métodos `clearCombatState()` y `cleanupDefenseType()`

**Sistemas:**
- `frontend/src/ecs/systems/animation-state-system.js` - Simplificado para solo determinar estados
- `frontend/src/ecs/systems/animation-mixer-system.js` - Agregado `resolveAnimationName()`, extraídos métodos privados, cacheo de componentes
- `frontend/src/ecs/systems/combat-system.js` - Cacheo de configuraciones, uso de constantes centralizadas

**Documentación:**
- `frontend/src/config/README.md` - Actualizado con `combat-constants.js`

## Criterios de Aceptación

**Simplificación (JDG-028):**
1. [x] `AnimationComponent` ya no tiene `comboAnimationName` ni `combatAnimationName`
2. [x] `AnimationStateSystem` solo determina estados, no copia nombres
3. [x] `AnimationMixerSystem` resuelve nombres usando función `resolveAnimationName()`
4. [x] `CombatComponent` tiene método `clearCombatState()` para limpieza centralizada
5. [x] Eliminado `stateToAnimationMap` duplicado
6. [x] Funcionalidad existente no se rompe (todas las animaciones funcionan)

**Optimización (JDG-028-2):**
1. [x] Componentes se cachean al inicio de loops en sistemas
2. [x] `CombatSystem` usa cache de `ANIMATION_STATES` en lugar de `Array.find()` (O(1) lookup)
3. [x] `AnimationMixerSystem.update()` se divide en métodos privados más pequeños
4. [x] `CombatComponent` tiene método `cleanupDefenseType()` para lógica de parry/dodge centralizada
5. [x] Constantes centralizadas en archivo de config (evita strings y valores mágicos hardcodeados)
6. [x] Performance mejorado (menos accesos a componentes, lookups O(1))

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance**: 
  - Cacheo de componentes reduce accesos repetidos en ~30-50% en algunos casos
  - Cacheo de configuraciones cambia lookups de O(n) a O(1)
  - Especialmente beneficioso con múltiples entidades y acciones
- **Compatibilidad**: Los cambios son completamente compatibles con el sistema ECS existente, no rompen funcionalidad
- **Escalabilidad**: La nueva arquitectura facilita agregar nuevas fuentes de animación (ej: emotes, habilidades especiales)
- **Mantenibilidad**: Métodos privados extraídos hacen el código más testeable y mantenible
- **Extensibilidad**: Agregar nuevas acciones o constantes es más fácil y menos propenso a errores

### Dependencias
- Depende de: JDG-027 (Sistema de Dodge Estilo Dark Souls - Refactor)
- Bloquea: (ninguno)

## Testing

### Escenarios de Prueba
1. **Animaciones Normales**: Verificar que idle, walk, run, jump, crouch funcionan correctamente
2. **Animaciones de Combate**: Verificar que attack, parry, dodge funcionan correctamente
3. **Animaciones de Combo**: Verificar que los combos funcionan correctamente
4. **Prioridad de Animaciones**: Verificar prioridad correcta (combo > combat > normal)
5. **Limpieza de Estado**: Verificar que el estado se limpia correctamente cuando terminan animaciones
6. **Parry Reactivo**: Verificar que parry se reactiva si la tecla sigue presionada
7. **Dodge Single Press**: Verificar que dodge solo se activa una vez por press
8. **Performance**: Verificar que no hay degradación de performance (mejoría esperada)

### Casos Edge a Considerar
- Transiciones rápidas entre animaciones
- Múltiples acciones presionadas simultáneamente
- Interrupciones durante animaciones one-shot
- Caché de componentes con entidades que se agregan/eliminan dinámicamente

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 6-8 horas
- **Notas:** 
  - Requiere cambios en múltiples sistemas
  - Necesita testing exhaustivo para asegurar que no se rompe funcionalidad
  - Dividido en dos fases: Simplificación (JDG-028) y Optimización (JDG-028-2)

## Referencias

- **Relacionado con:** 
  - JDG-027 (Sistema de Dodge Estilo Dark Souls - Refactor)
  - JDG-026 (Corrección de Inputs y Dodge Básico)
- **Documentación relevante:** 
  - `frontend/src/ecs/README.md`
  - `frontend/src/config/README.md`
  - `instructions/analysis/JDG-028-architecture-analysis_2025-12-13_17-08-18.md` (Análisis de Arquitectura - Simplificación)
  - `instructions/analysis/JDG-028-2-architecture-analysis_2025-12-13_17-47-00.md` (Análisis de Arquitectura - Optimización)
  - `instructions/tasks/JDG-028-action-plan_2025-12-13_17-27-49.md` (Plan de Acción - Simplificación)
  - `instructions/tasks/JDG-028-2-action-plan_2025-12-13_18-05-41.md` (Plan de Acción - Optimización)
  - `instructions/prs/JDG-028_pr-description_2025-12-13_17-35-55.md` (PR Description)
- **Discusiones previas:** Refactor planificado para mejorar mantenibilidad, performance y escalabilidad del sistema de animaciones

## Notas Adicionales

### Implementación Completada
Este ticket ha sido completado exitosamente. La refactorización se realizó en dos fases:

**Fase 1 - Simplificación (JDG-028):**
- Eliminada duplicación de estado entre componentes
- Centralizada resolución de nombres de animación
- Simplificada separación de responsabilidades
- Eliminadas ~50 líneas de código duplicado

**Fase 2 - Optimización (JDG-028-2):**
- Implementado cacheo de componentes y configuraciones
- Extraídos métodos privados para mejorar modularidad
- Centralizadas constantes para evitar valores mágicos
- Mejorada performance mediante lookups O(1)

### Beneficios Logrados
- **Código más limpio**: Single Source of Truth, menos duplicación
- **Mejor performance**: Cacheo reduce accesos y lookups O(1)
- **Más mantenible**: Métodos más pequeños, constantes centralizadas
- **Más escalable**: Fácil agregar nuevas fuentes de animación
- **Menos bugs**: Elimina riesgo de desincronización de estado

### Flujo de Datos Mejorado
El nuevo flujo es más directo:
```
CombatSystem → combat.combatAnimation → AnimationMixerSystem.resolveAnimationName() → reproduce animación
```

En lugar del flujo anterior con copias intermedias:
```
CombatSystem → combat.combatAnimation → AnimationStateSystem (copia) → AnimationComponent.combatAnimationName → AnimationMixerSystem
```

