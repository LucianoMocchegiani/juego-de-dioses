# JDG-037 - Sistema de Física Avanzado

## Tipo
- [x] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [x] Alta (bloquea funcionalidad crítica)
- [ ] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El juego actualmente tiene un sistema de física básico que maneja:
- Gravedad simple
- Velocidad y aceleración básicas
- Colisiones con partículas sólidas del mundo (voxels)
- Fricción básica

Sin embargo, para un MMO completo se necesita un sistema de física más robusto que soporte:
- **Interacciones entre entidades** (jugadores, NPCs, objetos)
- **Física de objetos** (cajas, proyectiles, objetos que se pueden empujar)
- **Colisiones precisas** entre entidades dinámicas
- **Fuerzas y momentos** (empujones, golpes, explosiones)
- **Física de cuerpos rígidos** (rotación, inercia)
- **Optimización para múltiples entidades** (50-100+ jugadores simultáneos)
- **Sincronización servidor-cliente** (física autoritativa del servidor)

### Comportamiento Actual

1. **PhysicsSystem básico:**
   - Gravedad simple (-9.8 celdas/seg²)
   - Velocidad y aceleración en X, Y, Z
   - Fricción básica (suelo/aire)
   - Timestep fijo (1/60 segundos)

2. **CollisionSystem básico:**
   - Detecta colisiones con partículas sólidas del mundo
   - Verifica suelo, paredes laterales
   - Usa consultas async al backend para partículas cercanas
   - Cache de colisiones por entidad

3. **Limitaciones actuales:**
   - ❌ No hay colisiones entre entidades (jugador vs jugador, jugador vs NPC)
   - ❌ No hay física de objetos (cajas, proyectiles)
   - ❌ No hay rotación ni momentos angulares
   - ❌ No hay fuerzas aplicadas (empujones, golpes)
   - ❌ No hay optimización espacial para múltiples entidades
   - ❌ Física solo en cliente (no autoritativa del servidor)

### Comportamiento Esperado

Después de la implementación, el sistema debería soportar:

1. **Física de entidades dinámicas:**
   - Colisiones precisas entre jugadores, NPCs y objetos
   - Rotación y momentos angulares
   - Fuerzas aplicadas (empujones, golpes, explosiones)
   - Física de cuerpos rígidos

2. **Física de objetos:**
   - Objetos que se pueden empujar (cajas, rocas)
   - Proyectiles con trayectoria física
   - Objetos que caen y ruedan

3. **Optimización:**
   - Spatial partitioning (grid/quadtree) para colisiones eficientes
   - Broad phase y narrow phase para detección de colisiones
   - Cache inteligente de colisiones

4. **Arquitectura servidor-cliente:**
   - Física autoritativa en el servidor
   - Predicción del cliente con corrección del servidor
   - Sincronización eficiente de estados físicos

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [x] WebSockets

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (renderizado)
- **Opciones de librerías de física:**
  - Cannon.js (física 3D completa, madura)
  - Rapier (física moderna, muy rápida, escrita en Rust compilada a WASM)
  - Ammo.js (port de Bullet Physics a JavaScript)
  - Custom physics (extender sistema actual)
- WebSockets (sincronización servidor-cliente)
- Spatial partitioning algorithms (grid, quadtree, octree)

### Archivos/Componentes Principales
- `frontend/src/ecs/systems/physics-system.js` - Sistema de física actual
- `frontend/src/ecs/systems/collision-system.js` - Sistema de colisiones actual
- `frontend/src/ecs/components/physics.js` - Componente de física actual
- `frontend/src/world/collision-detector.js` - Detector de colisiones con partículas
- `frontend/src/config/animation-constants.js` - Constantes de física
- **Nuevos archivos a crear:**
  - `frontend/src/ecs/systems/entity-collision-system.js` - Colisiones entre entidades
  - `frontend/src/ecs/systems/spatial-partitioning-system.js` - Optimización espacial
  - `frontend/src/ecs/components/rigid-body.js` - Cuerpo rígido (si se usa librería)
  - `backend/src/physics/` - Sistema de física del servidor (si se implementa autoritativo)

## Criterios de Aceptación

1. [ ] **Colisiones entre entidades:** Las entidades (jugadores, NPCs) pueden colisionar entre sí y con objetos dinámicos
2. [ ] **Física de objetos:** Los objetos (cajas, proyectiles) se comportan físicamente (caen, ruedan, se empujan)
3. [ ] **Rotación y momentos:** Las entidades pueden rotar y tener momentos angulares
4. [ ] **Fuerzas aplicadas:** Se pueden aplicar fuerzas a entidades (empujones, golpes, explosiones)
5. [ ] **Optimización espacial:** El sistema usa spatial partitioning para manejar 50+ entidades eficientemente
6. [ ] **Rendimiento:** El sistema mantiene 60 FPS con 50+ entidades activas
7. [ ] **Sincronización:** Si se implementa servidor autoritativo, la física se sincroniza correctamente entre servidor y clientes

**Nota:** Cada criterio debe ser específico, medible y verificable.

## Detalles de Implementación

### Consideraciones Técnicas

#### Opción 1: Extender Sistema Actual (Custom Physics)
- **Pros:**
  - Control total sobre la implementación
  - Optimizado específicamente para voxels/partículas
  - Sin dependencias externas
  - Más ligero
- **Contras:**
  - Requiere implementar todo desde cero
  - Más tiempo de desarrollo
  - Posibles bugs y edge cases
  - Menos características avanzadas

#### Opción 2: Integrar Cannon.js
- **Pros:**
  - Librería madura y estable
  - Física 3D completa (cuerpos rígidos, rotación, momentos)
  - Buena documentación
  - Comunidad activa
- **Contras:**
  - Dependencia externa (~200KB)
  - Puede ser más pesada de lo necesario
  - Integración con sistema de partículas/voxels puede ser compleja

#### Opción 3: Integrar Rapier
- **Pros:**
  - Muy rápida (escrita en Rust, compilada a WASM)
  - Moderna y bien mantenida
  - Excelente rendimiento con muchas entidades
  - API limpia
- **Contras:**
  - Dependencia externa
  - WASM puede tener overhead de inicialización
  - Menos madura que Cannon.js
  - Integración con voxels puede requerir trabajo adicional

#### Opción 4: Híbrido (Custom + Librería)
- **Pros:**
  - Custom physics para partículas/voxels (optimizado)
  - Librería para entidades dinámicas (completo)
  - Mejor de ambos mundos
- **Contras:**
  - Más complejo de mantener
  - Dos sistemas de física diferentes
  - Posibles inconsistencias

**Recomendación:** Ver análisis de arquitectura para evaluación detallada de cada opción.

### Performance
- El sistema debe manejar 50-100+ entidades simultáneas
- Mantener 60 FPS en cliente
- Spatial partitioning para optimizar colisiones
- Cache inteligente de colisiones

### Seguridad
- Si se implementa servidor autoritativo, validar todas las acciones físicas en el servidor
- Prevenir exploits de física (noclip, speed hacks)

### Compatibilidad
- Mantener compatibilidad con sistema de partículas actual
- No romper sistema de colisiones con voxels existente

### Escalabilidad
- Sistema debe escalar a múltiples jugadores simultáneos
- Optimización para áreas con muchas entidades

### Dependencias
- Depende de: Sistema ECS actual (JDG-010)
- Bloquea: Sistema de combate avanzado, sistema de objetos interactivos, sistema de NPCs con física

## Testing

### Escenarios de Prueba
1. **Colisiones entre entidades:**
   - Dos jugadores chocan → se empujan correctamente
   - Jugador choca con NPC → ambos reaccionan físicamente
   - Múltiples entidades (10+) chocan simultáneamente → rendimiento aceptable

2. **Física de objetos:**
   - Caja se empuja → se mueve y rueda correctamente
   - Proyectil se lanza → sigue trayectoria física correcta
   - Objeto cae → acelera por gravedad y rebota en suelo

3. **Fuerzas aplicadas:**
   - Empujón aplicado a entidad → se mueve en dirección correcta
   - Golpe aplicado → entidad recibe impulso y rota
   - Explosión → múltiples entidades reciben fuerza radial

4. **Optimización:**
   - 50+ entidades en área pequeña → mantiene 60 FPS
   - Spatial partitioning funciona correctamente
   - Cache de colisiones reduce consultas innecesarias

### Casos Edge a Considerar
- Entidades que se mueven muy rápido (tunneling)
- Entidades que se superponen (penetración)
- Entidades en bordes de chunks/viewport
- Entidades que caen fuera del mundo
- Múltiples colisiones simultáneas
- Fuerzas muy grandes que causan movimientos extremos

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 2-4 semanas (dependiendo de opción elegida)
  - Opción 1 (Custom): 3-4 semanas
  - Opción 2 (Cannon.js): 2-3 semanas
  - Opción 3 (Rapier): 2-3 semanas
  - Opción 4 (Híbrido): 3-4 semanas
- **Notas:** 
  - La estimación varía según la opción de implementación elegida
  - Implementar servidor autoritativo añade 1-2 semanas adicionales
  - Testing y optimización añade 1 semana adicional

## Referencias

- **Relacionado con:** JDG-010 (Sistema ECS), JDG-XXX (Sistema de combate), JDG-XXX (Sistema de NPCs)
- **Documentación relevante:**
  - [Cannon.js Documentation](https://github.com/schteppe/cannon.js)
  - [Rapier Documentation](https://rapier.rs/docs/)
  - [Ammo.js Documentation](https://github.com/kripken/ammo.js)
  - Análisis de arquitectura: `JDG-037-architecture-analysis_2025-12-22_15-59-42.md`
- **Discusiones previas:** 
  - `Juego de Dioses/Ideas/20-ECS-y-MMO-Conceptos-Basicos.md`
  - `Juego de Dioses/Ideas/22-IA-Como-Jugador.md`
  - `Juego de Dioses/Ideas/26-Personajes-Particulas-MMO.md`

## Notas Adicionales

- **Importante:** Este ticket requiere un análisis de arquitectura previo para decidir qué opción de implementación usar
- El sistema actual de física funciona para casos básicos, pero necesita extenderse para soportar un MMO completo
- La decisión entre custom physics vs librería afectará significativamente el tiempo de desarrollo y las capacidades del sistema
- Si se implementa servidor autoritativo, se necesitará también implementar física en el backend (Python)
- Considerar usar la misma librería de física en frontend y backend para consistencia

