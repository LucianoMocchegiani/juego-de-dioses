# JDG-038 - Fase 1: Fundación del Sistema de Partículas

## Tipo
- [x] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [x] Alta (bloquea funcionalidad crítica)
- [ ] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

Implementar la fundación del sistema de partículas del juego, estableciendo la base de datos, estructura de bloques y funciones auxiliares básicas. Esta fase es crítica ya que bloquea todas las demás fases del desarrollo del sistema de partículas.

### Comportamiento Actual

- El sistema actual tiene una estructura básica de partículas pero no está completamente implementado según el diseño final
- La tabla `dimensiones` existe pero necesita ser renombrada a `bloques` y extendida
- Faltan funciones auxiliares básicas para consultar y manipular partículas
- No existe un sistema unificado de bloques para organizar el mundo

### Comportamiento Esperado

- Tablas de base de datos creadas/actualizadas según el diseño final (`tipos_particulas`, `particulas`, `transiciones_particulas`, `bloques`)
- Sistema de bloques unificado implementado con `WorldBloque` y `WorldBloqueManager`
- Funciones auxiliares básicas implementadas para consultar partículas y bloques
- Migración completa de `dimensiones` a `bloques` con todas las referencias actualizadas
- Base sólida establecida para las siguientes fases del sistema

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI)
- [ ] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Python 3.11, FastAPI, asyncpg
- PostgreSQL 16
- SQL para migraciones y consultas
- JavaScript ES6+ (para funciones auxiliares si se implementan en frontend)

### Archivos/Componentes Principales
- `database/init/01-init-schema.sql` - Esquema base de datos
- `database/migrations/` - Migraciones para renombrar dimensiones a bloques
- `backend/src/database/` - Conexión y queries
- `backend/src/models/` - Modelos Pydantic para partículas y bloques
- `backend/src/services/` - Servicios para bloques y partículas
- `Juego de Dioses/Ideas/29-Diseno-Final-Particulas.md` - Diseño de partículas
- `Juego de Dioses/Ideas/36-Sistema-Bloques-Unificado.md` - Diseño de bloques
- `Juego de Dioses/Ideas/35-Funciones-Auxiliares-Sistema-Particulas.md` - Funciones auxiliares

## Criterios de Aceptación

1. [ ] Tabla `tipos_particulas` creada con todos los campos según diseño final (incluyendo `integridad`, `conductividad_electrica`, `magnetismo`)
2. [ ] Tabla `particulas` creada con todos los campos según diseño final (incluyendo `integridad`, `carga_electrica`, `temperatura`)
3. [ ] Tabla `transiciones_particulas` creada con estructura básica
4. [ ] Tabla `dimensiones` renombrada a `bloques` con campo `tamano_bloque` agregado
5. [ ] Todas las referencias a `dimension_id` migradas a `bloque_id` en tabla `particulas`
6. [ ] Clase `WorldBloque` implementada con métodos para calcular temperatura
7. [ ] Clase `WorldBloqueManager` implementada con métodos para obtener bloques por posición y partícula
8. [ ] Funciones auxiliares básicas implementadas: `getParticula()`, `getTipoParticula()`, `getParticulasVecinas()`, `getBloqueForPosition()`, `getBloqueForParticle()`
9. [ ] Rutas de API actualizadas para usar `bloques` en consultas SQL (manteniendo compatibilidad de API)
10. [ ] Schema inicial completo y funcional (sin migraciones)
11. [ ] Índices creados para optimizar consultas frecuentes
12. [ ] READMEs actualizados para documentar nuevos módulos y cambios

**Nota:** Cada criterio debe ser específico, medible y verificable.

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance**: Crear índices apropiados en tablas para consultas frecuentes (por posición, por tipo, por bloque)
- **Seguridad**: Usar consultas parametrizadas para prevenir SQL injection
- **Compatibilidad**: Asegurar que las migraciones sean reversibles
- **Escalabilidad**: Diseñar estructura de bloques para manejar millones de partículas

### Dependencias
- Depende de: Ninguna (es la fase fundacional)
- Bloquea: Todas las demás fases (2-8) del sistema de partículas

### Sub-tareas

#### 1.1 Diseño Final de Partículas
- Crear/actualizar tablas `tipos_particulas`, `particulas`, `transiciones_particulas`
- Agregar campos nuevos: `integridad`, `conductividad_electrica`, `magnetismo`, `carga_electrica`
- Crear índices apropiados
- Migrar datos existentes si los hay

#### 1.2 Sistema de Bloques Unificado
- Renombrar tabla `dimensiones` a `bloques`
- Agregar campo `tamano_bloque` a `bloques`
- Migrar `dimension_id` a `bloque_id` en `particulas`
- Implementar `WorldBloque` y `WorldBloqueManager` en backend
- Actualizar foreign keys y constraints

#### 1.3 Funciones Auxiliares Base
- Implementar funciones de consulta básicas
- Implementar funciones de cálculo de bloques
- Crear servicios/modulos organizados
- Documentar funciones con docstrings

#### 1.4 Corregir Breaking Changes (dimensiones → bloques)
- Actualizar rutas de API para usar `bloques` en consultas SQL
- Mapear `bloque_id` (BD) → `dimension_id` (API) para compatibilidad con frontend
- Actualizar `main.py` para verificar `bloques` en seeds
- Mantener compatibilidad de API (endpoints `/dimensions` siguen funcionando)

## Testing

### Escenarios de Prueba
1. **Crear tipo de partícula**: Verificar que se crea correctamente con todos los campos
2. **Crear partícula**: Verificar que se asocia correctamente con bloque y tipo
3. **Renombrar dimensiones a bloques**: Verificar que la migración funciona sin pérdida de datos
4. **Obtener bloque por posición**: Verificar que se calcula correctamente el bloque para coordenadas dadas
5. **Obtener partículas vecinas**: Verificar que retorna partículas dentro del radio especificado
6. **Consultar partícula por ID**: Verificar que retorna datos correctos
7. **Migración de datos existentes**: Si hay datos, verificar que se migran correctamente

### Casos Edge a Considerar
- Partículas en coordenadas negativas o muy grandes
- Bloques con tamaño diferente al default (40)
- Consultas con radio 0 o muy grande
- Partículas sin tipo asociado (debe fallar con constraint)
- Bloques sin partículas asociadas
- Migración con datos existentes en producción

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 7-10 días (2-3 días por sub-tarea + 1 día de integración y testing)
- **Notas:** 
  - Depende de la cantidad de datos existentes a migrar
  - Requiere cuidado especial en las migraciones para no perder datos
  - Testing exhaustivo necesario antes de considerar completa

## Referencias

- **Relacionado con:** Fase 1 del documento `52-Orden-Prioridad-Desarrollo.md`
- **Documentación relevante:**
  - `Juego de Dioses/Ideas/29-Diseno-Final-Particulas.md` - Diseño completo de partículas
  - `Juego de Dioses/Ideas/36-Sistema-Bloques-Unificado.md` - Diseño de sistema de bloques
  - `Juego de Dioses/Ideas/35-Funciones-Auxiliares-Sistema-Particulas.md` - Especificación de funciones auxiliares
  - `Juego de Dioses/Ideas/52-Orden-Prioridad-Desarrollo.md` - Roadmap completo
- **Discusiones previas:** Decisión de renombrar `dimensiones` a `bloques` y usar "bloques" en lugar de "chunks"

## Notas Adicionales

- Esta es la fase fundacional más crítica del sistema de partículas
- Todas las demás fases dependen de esta
- Se recomienda implementar las 3 sub-tareas en orden (1.1 → 1.2 → 1.3) debido a dependencias
- Es importante crear backups antes de ejecutar migraciones en producción
- Considerar crear un script de rollback para cada migración
- Documentar todos los cambios en READMEs correspondientes
- Usar transacciones SQL para asegurar atomicidad en migraciones

