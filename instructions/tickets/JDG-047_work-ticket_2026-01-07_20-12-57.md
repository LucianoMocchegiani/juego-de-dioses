# JDG-047 - Optimizaciones de Bajo Riesgo para Mejorar FPS (Fase 1)

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [x] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El frontend tiene varias optimizaciones de bajo riesgo que pueden mejorar inmediatamente el FPS sin cambiar funcionalidad. Estas optimizaciones incluyen: object pooling para objetos temporales, cachear el ordenamiento de sistemas ECS, y usar dirty flags para actualizar el color del cielo solo cuando es necesario.

### Comportamiento Actual

**Object Pooling:**
- Se crean nuevos objetos `THREE.Vector3`, `THREE.Quaternion`, `THREE.Euler` en cada frame para cálculos temporales
- Estos objetos se crean especialmente en `weapon-equip-system.js` para cálculos de posición de armas
- El garbage collector debe limpiar estos objetos frecuentemente, causando stutters

**Ordenamiento de Sistemas ECS:**
- El ECS Manager ordena todos los sistemas por prioridad en cada frame: `const sortedSystems = [...this.systems].sort((a, b) => a.priority - b.priority);`
- Esto ejecuta O(n log n) en cada frame (60 veces por segundo) aunque los sistemas raramente cambian

**Actualización de Color del Cielo:**
- `updateSkyColor()` se llama cada frame y realiza cálculos complejos de color RGB
- Conversiones de color (hex ↔ RGB), cálculos de brillo, interpolaciones
- Estas operaciones se ejecutan incluso cuando el estado celestial no cambia significativamente

### Comportamiento Esperado

**Object Pooling:**
- Objetos temporales (Vectores, Quaterniones, Eulers) se reutilizan desde un pool
- No se crean nuevos objetos en cada frame para cálculos temporales
- El garbage collector tiene menos trabajo, reduciendo stutters

**Ordenamiento de Sistemas ECS:**
- El ordenamiento solo se recalcula cuando se agregan o remueven sistemas
- El array ordenado se cachea y se reutiliza mientras los sistemas no cambien
- Reducción de overhead en el loop principal

**Dirty Flag para Color del Cielo:**
- El color del cielo solo se recalcula cuando el estado celestial cambia significativamente
- Se usa un threshold para detectar cambios mínimos
- Reducción de cálculos innecesarios en cada frame

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Three.js
- JavaScript ES6+
- Patrón Object Pool
- Patrón Dirty Flag

### Archivos/Componentes Principales
- `frontend/src/core/optimizations/object-pool.js` (nuevo)
- `frontend/src/ecs/manager.js` (modificar)
- `frontend/src/ecs/systems/weapon-equip-system.js` (modificar)
- `frontend/src/core/renderer.js` (modificar)
- `frontend/src/app.js` (modificar para inicializar pools)

## Criterios de Aceptación

1. [ ] Se implementa un sistema de object pooling reutilizable para objetos Three.js (Vector3, Quaternion, Euler)
2. [ ] `weapon-equip-system.js` usa object pooling para todos sus objetos temporales
3. [ ] El ECS Manager cachea el ordenamiento de sistemas y solo lo recalcula cuando cambian los sistemas
4. [ ] El color del cielo solo se actualiza cuando el estado celestial cambia significativamente (threshold configurable)
5. [ ] Las optimizaciones no cambian la funcionalidad visible del juego
6. [ ] Se observa mejora de +5-10 FPS después de implementar object pooling
7. [ ] Se observa mejora de +1-2 FPS después de cachear ordenamiento de sistemas
8. [ ] Se observa mejora de +1-2 FPS después de implementar dirty flag para color del cielo
9. [ ] El código es mantenible y bien documentado
10. [ ] No hay memory leaks (los objetos del pool se liberan correctamente)

**Nota:** Cada criterio debe ser específico, medible y verificable.

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance:** Las optimizaciones deben reducir garbage collection y overhead de cálculos
- **Compatibilidad:** No debe romper funcionalidad existente
- **Escalabilidad:** El object pool debe poder crecer dinámicamente si es necesario
- **Testing:** Verificar que no hay memory leaks y que el rendimiento mejora

### Dependencias
- Depende de: Ninguno
- Bloquea: JDG-048 (Fase 2 de optimizaciones)
- Relacionado con: JDG-046 (Análisis de arquitectura)

## Testing

### Escenarios de Prueba

1. **Object Pooling:**
   - Verificar que el juego funciona igual visualmente
   - Medir FPS antes y después de la implementación
   - Verificar que no hay memory leaks (usar Chrome DevTools Memory Profiler)
   - Verificar que el pool crece dinámicamente cuando es necesario

2. **Cache de Ordenamiento:**
   - Verificar que los sistemas se ejecutan en el orden correcto
   - Agregar un sistema nuevo y verificar que se reordena
   - Medir overhead antes y después

3. **Dirty Flag para Color del Cielo:**
   - Verificar que el color del cielo cambia correctamente cuando el estado celestial cambia
   - Verificar que no se actualiza innecesariamente cuando el cambio es mínimo
   - Probar con diferentes estados celestiales (día, noche, amanecer, atardecer)

### Casos Edge a Considerar

- **Object Pool agotado:** El pool debe poder crear nuevos objetos si se agotan
- **Sistemas que cambian frecuentemente:** El cache debe invalidarse correctamente
- **Cambios mínimos en estado celestial:** El threshold debe funcionar correctamente
- **Memory leaks:** Verificar que los objetos se liberan correctamente

## Estimación

- **Complejidad:** Baja
- **Tiempo estimado:** 4-6 horas
- **Notas:**
  - Las optimizaciones son relativamente simples
  - Requiere testing cuidadoso para verificar mejoras de rendimiento
  - La documentación del código es importante para mantenibilidad

## Referencias

- **Relacionado con:** JDG-046 (Análisis de Arquitectura - Optimización de FPS)
- **Documentación relevante:**
  - Análisis de arquitectura: `instructions/analysis/JDG-046-architecture-analysis_2026-01-07_20-00-39.md`
  - Three.js Object Pooling: Patrón común en optimización de juegos
  - Dirty Flag Pattern: Patrón de diseño para evitar cálculos innecesarios

## Notas Adicionales

- Esta es la Fase 1 de un plan de optimización de 3 fases
- Las optimizaciones de esta fase son de bajo riesgo y se pueden implementar sin afectar funcionalidad
- Los resultados de esta fase ayudarán a justificar las siguientes fases
- Es importante medir el impacto de cada optimización individualmente para entender qué funciona mejor
