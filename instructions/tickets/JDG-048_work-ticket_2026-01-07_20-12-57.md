# JDG-048 - Optimizaciones de Medio Riesgo para Mejorar FPS (Fase 2)

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [x] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

Después de las optimizaciones de bajo riesgo (Fase 1), se necesitan optimizaciones de medio riesgo que proporcionen mejoras más significativas de FPS. Estas incluyen: frustum culling para solo renderizar entidades visibles, un sistema de LOD (Level of Detail) para reducir complejidad de entidades lejanas, y render batching para agrupar operaciones similares.

### Comportamiento Actual

**Frustum Culling:**
- El Render System itera sobre todas las entidades cada frame, actualizando posiciones incluso si están fuera del view frustum
- No hay verificación de visibilidad antes de actualizar meshes
- Todas las entidades se procesan incluso si no son visibles

**LOD (Level of Detail):**
- Todas las entidades se renderizan con el mismo nivel de detalle
- Entidades lejanas usan la misma complejidad de animaciones y meshes que cercanas
- No hay reducción de calidad para objetos lejanos

**Render Batching:**
- Cada sistema actualiza meshes individualmente
- No hay agrupación de actualizaciones similares
- Faltan optimizaciones por caché de CPU

### Comportamiento Esperado

**Frustum Culling:**
- Solo se actualizan y renderizan entidades visibles dentro del frustum de la cámara
- Las entidades fuera de vista no se procesan
- Reducción significativa de trabajo cuando hay muchas entidades fuera de vista

**LOD System:**
- Entidades cercanas se renderizan con alta calidad
- Entidades lejanas se renderizan con menor calidad (menos polígonos, animaciones simplificadas, etc.)
- Transición suave entre niveles de detalle

**Render Batching:**
- Las actualizaciones de meshes se agrupan por material o tipo similar
- Reducción de cambios de estado de GPU
- Mejor uso del caché de CPU

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Three.js (Frustum, InstancedMesh)
- JavaScript ES6+
- Spatial Partitioning (para frustum culling eficiente)
- LOD System patterns

### Archivos/Componentes Principales
- `frontend/src/core/optimizations/frustum-culling.js` (nuevo)
- `frontend/src/core/optimizations/lod-manager.js` (nuevo)
- `frontend/src/core/optimizations/render-batcher.js` (nuevo)
- `frontend/src/ecs/systems/render-system.js` (modificar para usar frustum culling)
- `frontend/src/ecs/systems/animation-mixer-system.js` (modificar para usar LOD)
- `frontend/src/app.js` (modificar para inicializar sistemas)

## Criterios de Aceptación

1. [ ] Se implementa un sistema de frustum culling que verifica visibilidad de entidades
2. [ ] El Render System solo actualiza entidades visibles dentro del frustum
3. [ ] Se observa mejora de +10-20 FPS con muchas entidades cuando se implementa frustum culling
4. [ ] Se implementa un sistema de LOD básico con al menos 2 niveles de detalle (cerca/lejos)
5. [ ] Las entidades lejanas usan menor calidad de animaciones/meshes
6. [ ] Se observa mejora de +5-15 FPS después de implementar LOD
7. [ ] Se implementa render batching que agrupa actualizaciones por material
8. [ ] Se observa mejora de +3-8 FPS después de implementar render batching
9. [ ] Las optimizaciones no causan artefactos visuales o bugs
10. [ ] La transición entre niveles de LOD es suave y no es notable durante gameplay
11. [ ] El código es mantenible y bien documentado

**Nota:** Cada criterio debe ser específico, medible y verificable.

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance:** Las optimizaciones deben reducir significativamente el trabajo por frame
- **Compatibilidad:** No debe romper funcionalidad existente
- **Calidad visual:** LOD debe ser sutil y no afectar experiencia del jugador negativamente
- **Escalabilidad:** Los sistemas deben funcionar bien con muchas entidades
- **Testing:** Verificar que la visibilidad y calidad visual son correctas

### Dependencias
- Depende de: JDG-047 (Fase 1 - optimizaciones de bajo riesgo)
- Bloquea: JDG-049 (Fase 3 - optimizaciones avanzadas)
- Relacionado con: JDG-046 (Análisis de arquitectura)

## Testing

### Escenarios de Prueba

1. **Frustum Culling:**
   - Verificar que entidades visibles se renderizan correctamente
   - Verificar que entidades fuera de vista no se procesan
   - Probar con cámara moviéndose rápidamente
   - Probar con muchas entidades (50+)
   - Medir FPS con y sin frustum culling

2. **LOD System:**
   - Verificar que entidades cercanas tienen alta calidad
   - Verificar que entidades lejanas tienen menor calidad
   - Probar transición entre niveles de LOD (acercarse/alejarse)
   - Verificar que no hay artefactos visuales
   - Medir FPS con y sin LOD

3. **Render Batching:**
   - Verificar que el renderizado funciona correctamente
   - Verificar que las actualizaciones se agrupan correctamente
   - Medir FPS con y sin batching
   - Verificar que no hay bugs visuales

### Casos Edge a Considerar

- **Entidades parcialmente visibles:** Deben procesarse correctamente
- **Cámara rotando rápidamente:** El frustum debe actualizarse correctamente
- **Transición LOD:** Debe ser suave y no causar "pop-in"
- **Muchas entidades del mismo material:** El batching debe funcionar correctamente
- **Entidades que entran/salen del frustum:** Deben actualizarse correctamente

## Estimación

- **Complejidad:** Media
- **Tiempo estimado:** 8-12 horas
- **Notas:**
  - Requiere más cuidado que Fase 1 porque puede afectar visualmente
  - Necesita testing extensivo para verificar calidad visual
  - La implementación de LOD puede requerir ajustes de parámetros

## Referencias

- **Relacionado con:** JDG-046 (Análisis de Arquitectura - Optimización de FPS), JDG-047 (Fase 1)
- **Documentación relevante:**
  - Análisis de arquitectura: `instructions/analysis/JDG-046-architecture-analysis_2026-01-07_20-00-39.md`
  - Three.js Frustum: https://threejs.org/docs/#api/en/math/Frustum
  - LOD patterns en juegos
  - Render batching best practices

## Notas Adicionales

- Esta es la Fase 2 de un plan de optimización de 3 fases
- Requiere que JDG-047 esté completado primero
- Las optimizaciones pueden afectar la calidad visual, por lo que se necesita testing cuidadoso
- Los parámetros de LOD y frustum culling pueden necesitar ajuste según el gameplay
