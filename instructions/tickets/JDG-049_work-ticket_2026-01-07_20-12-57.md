# JDG-049 - Optimizaciones Avanzadas para Mejorar FPS (Fase 3)

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [x] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

Después de las optimizaciones de bajo y medio riesgo (Fases 1 y 2), se necesitan optimizaciones avanzadas para maximizar el rendimiento. Estas incluyen: instancing para entidades similares usando `InstancedMesh` de Three.js, frame scheduling para distribuir trabajo pesado a lo largo de múltiples frames, y spatial partitioning para optimizar detección de colisiones y frustum culling.

### Comportamiento Actual

**Instancing:**
- Cada entidad renderizada tiene su propio mesh individual
- No se usa `InstancedMesh` de Three.js para entidades del mismo tipo
- Draw calls excesivos cuando hay muchas entidades similares (ej: partículas del mismo estilo, NPCs del mismo tipo)

**Frame Scheduling:**
- Todas las entidades se actualizan cada frame
- Trabajo pesado (actualizaciones de entidades lejanas, cálculos complejos) se ejecuta en el mismo frame
- Esto puede causar frames largos cuando hay muchas entidades

**Spatial Partitioning:**
- El sistema de colisiones consulta todas las partículas/entidades para cada verificación
- No hay estructura espacial (octree, grid) para queries más eficientes
- Las búsquedas espaciales son O(n) para cada query

### Comportamiento Esperado

**Instancing:**
- Entidades con mismo mesh/material se agrupan en `InstancedMesh`
- Reducción drástica de draw calls cuando hay muchas entidades similares
- Cada instancia puede tener su propia transformación (posición, rotación, escala)

**Frame Scheduling:**
- Entidades lejanas se actualizan cada 2-3 frames en lugar de cada frame
- Trabajo pesado se distribuye a lo largo de múltiples frames
- Reducción de carga por frame, manteniendo 60 FPS

**Spatial Partitioning:**
- Se implementa una estructura espacial (octree o grid) para organizar entidades/partículas
- Queries espaciales (frustum culling, detección de colisiones) son más eficientes (O(log n) o mejor)
- Reducción significativa de complejidad para búsquedas espaciales

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Three.js (InstancedMesh, BufferGeometry)
- JavaScript ES6+
- Spatial Partitioning (Octree o Grid)
- Frame scheduling patterns

### Archivos/Componentes Principales
- `frontend/src/core/optimizations/instancing-manager.js` (nuevo)
- `frontend/src/core/optimizations/frame-scheduler.js` (nuevo)
- `frontend/src/core/optimizations/spatial-partition.js` (nuevo)
- `frontend/src/ecs/systems/render-system.js` (modificar para usar instancing)
- `frontend/src/ecs/systems/collision-system.js` (modificar para usar spatial partitioning)
- `frontend/src/ecs/manager.js` (modificar para usar frame scheduling)
- `frontend/src/app.js` (modificar para inicializar sistemas)

## Criterios de Aceptación

1. [ ] Se implementa un sistema de instancing que agrupa entidades similares en `InstancedMesh`
2. [ ] Entidades con mismo mesh/material se renderizan usando instancing
3. [ ] Se observa mejora de +20-40 FPS con muchas entidades del mismo tipo cuando se implementa instancing
4. [ ] Draw calls se reducen significativamente (50-70% menos)
5. [ ] Se implementa frame scheduling que distribuye actualizaciones de entidades lejanas
6. [ ] Entidades lejanas se actualizan cada 2-3 frames en lugar de cada frame
7. [ ] Se observa mejora de +5-10 FPS después de implementar frame scheduling
8. [ ] Se implementa spatial partitioning (octree o grid) para organizar entidades/partículas
9. [ ] Las queries espaciales (colisiones, frustum culling) usan spatial partitioning
10. [ ] Se observa mejora de +3-7 FPS después de implementar spatial partitioning
11. [ ] Las optimizaciones no causan bugs o artefactos visuales
12. [ ] El código es mantenible y bien documentado

**Nota:** Cada criterio debe ser específico, medible y verificable.

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance:** Las optimizaciones deben maximizar el rendimiento, especialmente con muchas entidades
- **Compatibilidad:** No debe romper funcionalidad existente
- **Complejidad:** Estas optimizaciones son más complejas y requieren más cuidado
- **Escalabilidad:** Debe funcionar bien con cientos de entidades
- **Testing:** Verificar que todas las funcionalidades funcionan correctamente

### Dependencias
- Depende de: JDG-047 (Fase 1), JDG-048 (Fase 2)
- Bloquea: Ninguno
- Relacionado con: JDG-046 (Análisis de arquitectura)

## Testing

### Escenarios de Prueba

1. **Instancing:**
   - Verificar que entidades instanciadas se renderizan correctamente
   - Verificar que cada instancia tiene su propia transformación
   - Probar con muchas entidades del mismo tipo (50+)
   - Verificar que no hay artefactos visuales
   - Medir draw calls con y sin instancing

2. **Frame Scheduling:**
   - Verificar que entidades lejanas se actualizan correctamente (aunque menos frecuentemente)
   - Verificar que entidades cercanas se actualizan cada frame
   - Probar moviendo entidades de lejos a cerca
   - Verificar que no hay bugs de sincronización
   - Medir FPS con y sin frame scheduling

3. **Spatial Partitioning:**
   - Verificar que las colisiones funcionan correctamente
   - Verificar que frustum culling funciona correctamente
   - Probar con muchas entidades/partículas
   - Verificar que las queries son más rápidas
   - Medir tiempo de queries con y sin spatial partitioning

### Casos Edge a Considerar

- **Entidades que cambian de tipo:** El instancing debe manejarlo correctamente
- **Instancias que entran/salen del frustum:** Deben actualizarse correctamente
- **Entidades moviéndose rápidamente:** El frame scheduling no debe causar lag visual
- **Spatial partitioning con entidades muy grandes:** Deben estar en múltiples celdas si es necesario
- **Entidades en límites de celdas:** Deben ser manejadas correctamente

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 12-16 horas
- **Notas:**
  - Requiere comprensión profunda de Three.js y optimización de juegos
  - Puede requerir múltiples iteraciones para ajustar parámetros
  - Necesita testing extensivo para verificar que todo funciona correctamente
  - La implementación de spatial partitioning puede ser compleja

## Referencias

- **Relacionado con:** JDG-046 (Análisis de Arquitectura - Optimización de FPS), JDG-047 (Fase 1), JDG-048 (Fase 2)
- **Documentación relevante:**
  - Análisis de arquitectura: `instructions/analysis/JDG-046-architecture-analysis_2026-01-07_20-00-39.md`
  - Three.js InstancedMesh: https://threejs.org/docs/#api/en/objects/InstancedMesh
  - Spatial Partitioning: Octree, Grid patterns
  - Frame scheduling patterns en juegos

## Notas Adicionales

- Esta es la Fase 3 (final) de un plan de optimización de 3 fases
- Requiere que JDG-047 y JDG-048 estén completados primero
- Estas son las optimizaciones más complejas y pueden requerir más tiempo y cuidado
- Después de esta fase, se espera tener 60 FPS constantes incluso con muchas entidades
- Puede requerir ajustes de parámetros según el gameplay real
