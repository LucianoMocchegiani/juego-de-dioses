# JDG-050 - Refactorizar renderParticles() en Métodos Más Pequeños

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [x] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El método `renderParticles()` en `ParticleRenderer` tiene aproximadamente 330 líneas de código, violando el principio de responsabilidad única. Esto dificulta el mantenimiento, la comprensión del código, el testing y futuras modificaciones. Se necesita dividir este método en métodos más pequeños y enfocados.

### Comportamiento Actual

**Problema principal:**
- El método `renderParticles()` tiene ~330 líneas (líneas 179-508 en `particle-renderer.js`)
- Realiza múltiples responsabilidades en un solo método:
  - Aplicar frustum culling
  - Aplicar optimización LOD
  - Aplicar ajuste adaptativo de límite
  - Aplicar limitación por densidad
  - Agrupar partículas por geometría+material
  - Separar grupos opacos de transparentes
  - Crear instanced meshes
  - Construir índice de partículas
- Dificulta la comprensión del flujo completo
- Dificulta el testing unitario de cada optimización
- Dificulta futuras modificaciones o extensiones

**Código actual:**
- Todo el flujo está en un solo método `renderParticles()`
- Las optimizaciones se aplican secuencialmente dentro del mismo método
- Los logs están mezclados con la lógica
- La agrupación y creación de meshes están en el mismo método

### Comportamiento Esperado

**Mejoras esperadas:**
- `renderParticles()` refactorizado en métodos más pequeños y enfocados
- Cada método privado tiene una responsabilidad única y clara
- El flujo principal en `renderParticles()` es fácil de seguir (orquestación)
- Los métodos helper son reutilizables y testables
- Mantener exactamente la misma funcionalidad (sin regresiones)
- Todos los logs se mantienen
- Código más legible y mantenible

**Métodos a extraer:**
1. `_applyFrustumCulling(particles, camera, cellSize)` - Aplicar frustum culling
2. `_applyLODOptimization(particles, playerPosition, camera, cellSize)` - Aplicar LOD
3. `_applyAdaptiveLimiting()` - Ajustar límite según FPS
4. `_applyParticleLimiting(particles, playerPosition, camera, cellSize)` - Aplicar limitación por densidad
5. `_buildParticleGroups(particles, tiposEstilos, agrupacionesGeometria, cellSize)` - Agrupar por geometría
6. `_createInstancedMeshes(groups, cellSize, scene)` - Crear instanced meshes

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI) - No afectado
- [x] Frontend (Three.js) - Principalmente afectado
- [ ] Base de Datos (PostgreSQL) - No afectado
- [ ] Cache (Redis) - No afectado
- [ ] Docker/Infraestructura - No afectado

### Tecnologías Involucradas
- JavaScript ES6+
- Three.js (InstancedMesh, Vector3, Matrix4)
- Refactorización siguiendo principios SOLID (Single Responsibility Principle)

### Archivos/Componentes Principales

**Archivos a modificar:**
- `frontend/src/terrain/renderers/particle-renderer.js` - Refactorizar método `renderParticles()`

## Criterios de Aceptación

1. [ ] Método `renderParticles()` refactorizado en 6 métodos helper privados más pequeños
2. [ ] Cada método helper tiene una responsabilidad única y clara
3. [ ] El método `renderParticles()` actúa como orquestador que llama a los helpers en orden
4. [ ] Funcionalidad idéntica al código anterior (sin regresiones)
5. [ ] Todos los logs se mantienen en los lugares correctos
6. [ ] Código más legible y fácil de entender
7. [ ] Sin errores de compilación o linting
8. [ ] Verificado que el renderizado funciona correctamente

## Detalles de Implementación

### Consideraciones Técnicas

**Refactorización:**
- Mantener exactamente la misma funcionalidad
- No cambiar ninguna lógica, solo reorganizar código
- Los métodos privados deben tener prefijo `_`
- Mantener todos los logs existentes
- Preservar todas las condiciones y validaciones

**Testing:**
- Verificar que el renderizado funciona idénticamente
- Probar que las optimizaciones se aplican correctamente
- Verificar que los logs aparecen como antes
- Probar casos edge (sin cámara, sin partículas, etc.)

**Compatibilidad:**
- No cambiar la firma pública de `renderParticles()`
- Mantener compatibilidad con código que llama a `renderParticles()`
- No afectar otros métodos de la clase

### Dependencias

- Depende de: JDG-008 (Optimización de Renderizado de Partículas), JDG-008-2 (Mejoras de Buenas Prácticas)
- No bloquea otros tickets

## Testing

### Escenarios de Prueba

1. **Renderizado básico:**
   - Cargar demo y verificar que las partículas se renderizan correctamente
   - Verificar que el número de partículas renderizadas es el mismo
   - Verificar que las partículas aparecen en las posiciones correctas

2. **Optimizaciones funcionando:**
   - Verificar que frustum culling se aplica (si está habilitado)
   - Verificar que LOD se aplica correctamente
   - Verificar que limitación por densidad funciona
   - Verificar que adaptive limiting se aplica (si está habilitado)

3. **Logs:**
   - Verificar que todos los logs aparecen como antes
   - Verificar que la información de los logs es correcta

4. **Casos edge:**
   - Sin partículas
   - Sin cámara
   - Sin posición de jugador
   - Todas las optimizaciones deshabilitadas

### Casos Edge a Considerar

- Partículas vacías: Debe manejarse correctamente
- Cámara nula: Debe funcionar sin errores
- Posición de jugador nula: Debe usar cámara como fallback
- Optimizaciones deshabilitadas: Debe funcionar normalmente

## Estimación

- **Complejidad:** Media-Alta
- **Tiempo estimado:** 4-6 horas
- **Notas:**
  - Requiere cuidado para no romper funcionalidad existente
  - Requiere testing extensivo para verificar que no hay regresiones
  - Puede requerir ajustes iterativos durante la implementación

## Referencias

- **Relacionado con:** JDG-008 (Optimización de Renderizado de Partículas), JDG-008-2 (Mejoras de Buenas Prácticas)
- **Plan de acción JDG-008-2:** `instructions/tasks/JDG-008-2-action-plan_2026-01-11_20-55-07.md` (Paso 3)
- **Documentación relevante:**
  - `frontend/src/terrain/renderers/particle-renderer.js` - Implementación actual
  - Three.js InstancedMesh documentation

## Notas Adicionales

- Este es un refactor puro: no cambia funcionalidad, solo mejora la organización del código
- Es seguro hacerlo después de JDG-008 y JDG-008-2 porque el código ya está funcionando
- Puede hacerse de forma incremental, método por método, para facilitar el testing
- Los métodos helper son privados (prefijo `_`) y no afectan la API pública
- Es importante mantener todos los logs para debugging
- Esta refactorización facilita futuras mejoras y mantenimiento
