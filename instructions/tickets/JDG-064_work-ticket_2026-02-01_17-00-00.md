# JDG-064 - Preparación para Mesh Builder (Partículas y Diseño)

## Tipo
- [x] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

Preparar el juego (partículas, agrupaciones, API y base de datos) para integrar una **fase inicial** del constructor in-game (mesh-builder): recetas, piezas mesh y colocación. Hoy no existen tablas de recetas, no hay API de escritura para agrupaciones desde el cliente. La forma de las piezas puede vivir en la **receta** (campo `forma`); el frontend obtiene la forma vía GET receta(receta_id), **sin necesidad** de exponer `geometria_agrupacion` en GET agrupaciones (actualmente `geometria_agrupacion` no se usa en el flujo de terreno; solo la API de characters la devuelve para bipeds, y el player-factory la usa como fallback cuando falla el GLB). Este ticket implementa la base de datos y APIs necesarias para que un siguiente paso pueda implementar el editor y la colocación de piezas.

### Comportamiento Actual

- Solo existe GET de partículas por viewport y GET de particle-types; no hay POST para crear/actualizar partículas.
- Las agrupaciones se crean solo vía scripts (seed_terrain, builders); no hay endpoint POST para que el cliente cree una agrupación (pieza colocada).
- No existe tabla `recetas` ni concepto de pieza como instancia de receta; `agrupaciones` no tiene `receta_id`. En el flujo de terreno no se usa `geometria_agrupacion` (TerrainManager pasa siempre null al renderer; árboles se renderizan por tipo de partícula).

### Comportamiento Esperado

- Tabla `recetas` creada (nombre, categoría, tipo_particula_id, proceso, **forma** JSONB, pérdida, creador); opcional `receta_id` en `agrupaciones`.
- API GET receta (por id) devuelve `forma` para que el frontend renderice piezas; **no es necesario** que GET agrupaciones devuelva geometria_agrupacion.
- API POST receta (crear receta con validación básica material–proceso).
- API POST agrupación (crear pieza colocada con receta_id y posición; la forma se obtiene de la receta vía GET receta, no es obligatorio duplicar en agrupación).
- Frontend: para piezas colocadas, GET agrupaciones (receta_id + posición) + GET receta(receta_id) para obtener forma y dibujar piezas (capa propia o instancing por receta).

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI)
- [x] Frontend (Three.js)
- [x] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [x] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- Python 3.11, FastAPI, asyncpg
- PostgreSQL 16
- JavaScript ES6+, Three.js (cliente API y uso de geometría en renderer)
- Pydantic (schemas Receta con forma, Agrupacion con receta_id opcional)

### Archivos/Componentes Principales
- `database/init/` o `database/migrations/` – tabla `recetas`, columna `receta_id` en `agrupaciones`
- `backend/src/api/routes/recetas.py` – nuevo router GET/POST recetas
- `backend/src/api/routes/agrupaciones.py` – POST crear agrupación (pieza con receta_id). GET agrupaciones puede seguir sin devolver geometria (la forma viene de GET receta).
- `backend/src/models/schemas.py` – RecetaCreate, RecetaResponse (con campo forma); AgrupacionResponse con receta_id opcional
- `frontend/src/api/endpoints/recetas.js` – nuevo cliente getRecetas, getReceta (devuelve forma), createReceta
- `frontend/src/api/endpoints/agrupaciones.js` – createAgrupacion; para piezas, frontend usa receta_id + GET receta para obtener forma
- `instructions/analysis/JDG-064-architecture-analysis_2026-02-01_16-50-00.md` – análisis de referencia
- `Juego de Dioses/Ideas/53-Constructor-In-Game-Recetas-Piezas-Mesh.md` – diseño de recetas y procesos
- `Juego de Dioses/mesh-builder/` – alcance y categorías

## Criterios de Aceptación

1. [ ] Tabla `recetas` creada con campos: id, nombre, categoria, subcategoria (opcional), tipo_particula_id (FK), proceso, forma (JSONB), perdida_porcentaje (opcional), creador_id (opcional), creado_en.
2. [ ] Columna `receta_id` (UUID, FK a recetas, nullable) añadida a `agrupaciones`.
3. [ ] Endpoint GET receta (por id) devuelve `forma` (JSONB) para que el frontend pueda renderizar la pieza; no es requisito que GET agrupaciones devuelva geometria_agrupacion.
4. [ ] Endpoint POST recetas: crear receta con validación de que tipo_particula_id existe y proceso sea uno permitido (sustractivo, fundicion, forja u otros definidos).
5. [ ] Endpoint GET recetas: listar recetas (por bloque o global); GET por id.
6. [ ] Endpoint POST agrupación: crear agrupación con tipo "pieza" (o "construccion"), receta_id, posicion_x/y/z (no es obligatorio copiar forma a agrupación; la forma se obtiene de GET receta).
7. [ ] Schemas Pydantic: RecetaCreate, RecetaResponse (con campo forma); AgrupacionResponse con receta_id opcional.
8. [ ] Frontend: cliente API para recetas (getRecetas, getReceta, createReceta) y para crear agrupación (createAgrupacion).
9. [ ] Frontend: para agrupaciones con receta_id, obtener forma vía getReceta(receta_id) y dibujar piezas (capa de piezas colocadas o instancing por receta); no depende de agrupacionesGeometria del ParticleRenderer.
10. [ ] Documentación: README o comentarios que enlacen a Ideas/53 y mesh-builder para reglas material–proceso.

**Nota:** POST partículas (crear/actualizar celdas) puede quedar para un ticket posterior (Fase 2 del análisis).

## Detalles de Implementación

### Consideraciones Técnicas
- **Performance:** La forma vive en la receta; GET agrupaciones no necesita devolver geometría (el frontend hace GET receta por cada receta_id distinto y puede cachear por receta_id).
- **Seguridad:** Validar que forma (JSONB) no exceda tamaño razonable; validar proceso contra lista permitida.
- **Compatibilidad:** GET agrupaciones sigue igual; solo añadir receta_id en respuesta cuando aplique.
- **Escalabilidad:** Índices en recetas (categoria, creador_id); en agrupaciones (receta_id).

### Dependencias
- Depende de: Ninguna (preparación fundacional para mesh-builder).
- Bloquea: Tickets futuros de editor in-game, colocación de piezas, POST partículas desde cliente.

## Testing

### Escenarios de Prueba
1. Crear receta vía POST con tipo_particula_id válido y proceso "sustractivo"; verificar que se persiste y GET devuelve la receta.
2. Crear agrupación vía POST con receta_id y posición; verificar que se persiste con receta_id.
3. GET receta por id; verificar que devuelve campo forma.
4. Frontend: obtener agrupaciones con receta_id, GET receta para cada receta_id distinto, y comprobar que se puede dibujar la pieza (o placeholder) usando la forma de la receta.

### Casos Edge a Considerar
- Receta con tipo_particula_id inexistente: rechazar con 400.
- Proceso no permitido para el material: rechazar con 400 (según tabla Ideas/53).
- POST agrupación con receta_id inexistente: rechazar con 400.

## Estimación

- **Complejidad:** Media
- **Tiempo estimado:** 2–4 días (BD + backend + frontend mínimo)
- **Notas:** La validación material–proceso puede ser inicialmente permisiva (cualquier proceso) y endurecerse en un siguiente ticket según Ideas/53.

## Referencias

- **Análisis de arquitectura:** `instructions/analysis/JDG-064-architecture-analysis_2026-02-01_16-50-00.md`
- **Idea recetas y mesh-builder:** `Juego de Dioses/Ideas/53-Constructor-In-Game-Recetas-Piezas-Mesh.md`
- **Alcance y categorías:** `Juego de Dioses/mesh-builder/alcance-categorias.md`
- **Plan de fases:** `Juego de Dioses/mesh-builder/plan-fases.md`

## Notas Adicionales

Este ticket corresponde a la **Fase 1: Datos y API** del análisis JDG-064. La Fase 2 (POST partículas, colocación completa) y Fase 3 (editor in-game con UI de constructor) se tratarán en tickets posteriores.
