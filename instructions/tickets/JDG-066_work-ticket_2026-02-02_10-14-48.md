# JDG-066 - Análisis y posible migración del backend a Hexagonal + DDD

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [x] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento

El backend tiene actualmente una **estructura por dominio** (domains/bloques, particles, characters, celestial, agrupaciones) y un único **puerto hexagonal** (almacenamiento: `BaseStorage`). La persistencia (PostgreSQL) se usa de forma directa desde routes y services (`get_connection()` + SQL), sin puertos ni repositorios. No hay capa de aplicación explícita (casos de uso) ni entidades de dominio ricas.

Se requiere **evaluar en profundidad** si merece la pena migrar hacia una arquitectura **Hexagonal (Puertos y Adaptadores)** combinada con **DDD (Domain-Driven Design)**, considerando la temática del proyecto (Juego de Dioses: mundo persistente, partículas, MMO-like, múltiples frontends posibles), la escala futura descrita en Ideas, y la relación con una posible organización tipo **micro-frontend** en el frontend.

### Comportamiento Actual

- Dominios bajo `src/domains/` con schemas, routes y en algunos casos service.py.
- Persistencia: acceso directo a PostgreSQL desde routes y services; no hay interfaces de repositorio.
- Un puerto: `BaseStorage` (storage) con adaptador `LocalFileStorage`.
- Sin capa de casos de uso; lógica repartida en endpoints y servicios.
- Sin entidades de dominio con comportamiento; solo DTOs Pydantic.

### Comportamiento Esperado

Tras el **análisis** (no necesariamente la migración completa):

1. Documento de análisis que contenga: pros/contras de Hexagonal + DDD en este proyecto, rentabilidad según temática y escala (Ideas), y relación con micro-frontend.
2. Si se decide avanzar: criterios de aceptación y fases para una migración incremental (puertos de persistencia, casos de uso, opcionalmente entidades de dominio).
3. Claridad sobre si micro-frontend es independiente del patrón de organización del backend o si hay sinergias.

## Contexto Técnico

### Componentes Afectados
- [x] Backend (FastAPI)
- [ ] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [x] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas

- Python 3.11, FastAPI, asyncpg
- PostgreSQL 16
- Patrones: Hexagonal (ports/adapters), DDD (bounded contexts, entidades, repositorios, casos de uso)

### Archivos/Componentes Principales

- `backend/src/domains/` (todos los dominios)
- `backend/src/database/connection.py`
- `backend/src/storage/storage_interface.py`, `local_file_storage.py`
- `docs/comparacion-hexagonal-ddd.md` (referencia)
- `Juego de Dioses/Ideas/` (contexto de escala y temática)
- `instructions/analysis/` (análisis de arquitectura a generar)

## Criterios de Aceptación

1. [ ] Existe un ticket (este) que describe el objetivo y alcance del análisis.
2. [ ] Existe un análisis de arquitectura (`JDG-066-architecture-analysis_*.md`) que incluye:
   - Situación actual del backend respecto a Hexagonal y DDD.
   - Pros y contras de adoptar Hexagonal + DDD en Juego de Dioses.
   - Rentabilidad: si es rentable según temática (mundo persistente, partículas, MMO-like, múltiples frontends) y escala futura (Ideas).
   - Relación entre organización del backend (Hexagonal+DDD) y opción de micro-frontend en el frontend.
3. [ ] El análisis propone recomendación clara: migración completa, incremental, o mantener actual con mejoras acotadas.
4. [ ] Si se recomienda migración: fases y criterios de aceptación por fase descritos en el análisis (no obligación de implementar en este ticket).

## Detalles de Implementación

### Consideraciones Técnicas

- **Rentabilidad**: Evaluar coste de migración vs beneficio a corto y medio plazo; el proyecto tiene roadmap de partículas, bloques, recetas, mesh builder (Ideas, JDG-064).
- **Escalabilidad**: Ideas describen mundo persistente, múltiples frontends (18-Arquitectura-Frontend-Agnostic), estado en RAM tipo MMO (26-Personajes-Particulas-MMO), límites de jugadores (24-Rendimiento).
- **Micro-frontend**: Aclarar si es decisión de organización del frontend independiente del backend, o si Hexagonal+DDD en backend facilita APIs por contexto que encajen con micro-frontends.

### Dependencias

- Depende de: Ninguno (análisis y posible plan; la implementación dependería de este análisis).
- Relacionado con: JDG-065 (estructura por dominio ya hecha), docs/comparacion-hexagonal-ddd.md.

## Testing

### Escenarios de Prueba

1. Revisión por pares del análisis: que pros/contras y rentabilidad estén bien argumentados.
2. Validación: que la recomendación (migrar o no, y cómo) sea accionable.

### Casos Edge a Considerar

- Equipo pequeño: migración full Hexagonal+DDD puede ser sobrecarga; valorar enfoque incremental.
- Prioridad de features (partículas, mesh builder, recetas): no retrasar roadmap por refactor grande sin beneficio claro.

## Estimación

- **Complejidad:** Media (análisis y documento; sin implementación en este ticket).
- **Tiempo estimado:** 1–2 días para análisis completo y redacción.
- **Notas:** La implementación de una migración (si se aprueba) sería otro ticket o varios, estimados en el análisis.

## Referencias

- **Relacionado con:** JDG-065 (estructura por dominio), docs/comparacion-hexagonal-ddd.md.
- **Documentación relevante:** Juego de Dioses/Ideas/ (00-INDICE-GENERAL, 01-Concepto-Principal, 13-El-Mundo-del-Juego, 14-Arquitectura-Tecnica-Mundo, 18-Arquitectura-Frontend-Agnostic, 24-Rendimiento-Limites-Jugadores, 26-Personajes-Particulas-MMO, 52-Orden-Prioridad-Desarrollo).
- **Reglas:** instructions/work-ticket.mdc, instructions/architecture-analysis-rule.mdc.

## Notas Adicionales

- El análisis debe citar Ideas donde sea relevante (escala, múltiples frontends, MMO, mundo persistente).
- Micro-frontend: el análisis debe aclarar si tiene que ver con el patrón de organización del backend o es una decisión separada del frontend.
