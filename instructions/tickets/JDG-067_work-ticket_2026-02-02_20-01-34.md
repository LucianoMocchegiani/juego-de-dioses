# JDG-067 - Refactorización del frontend a la estructura elegida (Hexagonal + ECS por dominios)

## Tipo
- [ ] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [x] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento
El frontend actual no sigue la estructura documentada en `docs/frontend-estructura-elegida.md`: falta la capa Hexagonal (ports + adapters), la capa application (casos de uso), la carpeta domain, y driving (game loop, input, UI) está mezclada con core. Además, el ECS tiene carpetas mezcladas en la raíz (conditions, states, combos, models) en lugar de la estructura por dominios (ecs/core, ecs/components, ecs/domains/animation|combat|input|…, ecs/factories) con loaders fuera del ECS. Se requiere refactorizar el frontend para que coincida con la estructura elegida sin cambiar el comportamiento del juego.

### Comportamiento Actual
- `api/` con client y endpoints llamados directamente desde app.js y terrain.
- `core/` mezcla escena, cámara, luces, renderer, input, optimizaciones, geometries, performance.
- `ecs/` en raíz de src con conditions/, states/, combos/, models/ en la raíz del ECS; helpers por dominio pero systems en plano.
- `terrain/` con `terrain/api/` (bloques-client, particles-client) que llaman al API.
- `world/`, `interfaces/`, `state/`, `config/`, `utils/` en raíz; no existe `domain/`, `application/`, `ports/`, `adapters/`, `driving/`, `rendering/`, `shared/`.

### Comportamiento Esperado
- Estructura global: main.js, app.js, domain/, application/, ports/, adapters/, driving/ (game/, input/, ui/), rendering/ (loaders/, ecs/, scene/, terrain/, world/, optimizations/, geometries/, renderers/), state/, config/, shared/.
- App recibe ports inyectados; casos de uso (loadWorld, spawnPlayer, syncCelestial) orquestan ports y store; TerrainManager y ECS reciben datos o ports inyectados, no llaman al API directamente.
- ECS bajo rendering/ecs/ con: core/ (world.js, system.js), components/, domains/animation|combat|input|physics|collision|render|weapon (cada uno con systems/, helpers/, y animation con state-machine/, combat con combos/), factories/. Loaders (model-loader, model-cache, model-utils, bones-utils, vertex-groups-utils) en rendering/loaders/, fuera del ECS.
- Game loop e InputManager en driving/game/ y driving/input/; paneles (F3, F6, etc.) en driving/ui/panels/. Utilidades puras en shared/; config y state sin cambios de responsabilidad.

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- JavaScript ES6+, módulos ES6
- Three.js (escena, ECS, terrain, world)
- Sin cambios de frameworks; solo reorganización de carpetas e imports y extracción de ports/adapters/application/domain

### Archivos/Componentes Principales
- `frontend/src/main.js`, `frontend/src/app.js`
- `frontend/src/api/` → migrar a `adapters/http/` y definir `ports/`
- `frontend/src/core/` → repartir en `rendering/scene/`, `rendering/optimizations/`, `rendering/geometries/`, `rendering/renderers/`, `driving/input/`, `rendering/performance/`
- `frontend/src/ecs/` → mover a `frontend/src/rendering/ecs/` y reestructurar internamente (core/, components/, domains/, factories/); `ecs/models/` → `rendering/loaders/`
- `frontend/src/terrain/` → mover a `frontend/src/rendering/terrain/`; eliminar `terrain/api/` y usar port inyectado
- `frontend/src/world/` → `frontend/src/rendering/world/`
- `frontend/src/interfaces/` → `frontend/src/driving/ui/panels/`
- `frontend/src/utils/` → `frontend/src/shared/` (math, geometry, colors, helpers) y opcionalmente config
- Nuevos: `frontend/src/domain/` (world, particles, character), `frontend/src/application/` (load-world, spawn-player, sync-celestial), `frontend/src/ports/`, `frontend/src/driving/game/` (bootstrap, game-loop)

## Criterios de Aceptación

1. [ ] Existe la carpeta `domain/` con al menos world, particles, character (modelos/DTOs puros sin Three ni fetch).
2. [ ] Existen `ports/` (contratos: worldApi, particlesApi, charactersApi, celestialApi, etc.) e `adapters/http/` que implementan esos ports; app.js y casos de uso no importan adapters directamente, solo reciben ports inyectados.
3. [ ] Existen casos de uso en `application/` (loadWorld, spawnPlayer, syncCelestial) que orquestan ports y store; App llama a estos casos de uso y les pasa ecs/scene cuando corresponde.
4. [ ] Todo lo 3D está bajo `rendering/`: scene/, loaders/, ecs/, terrain/, world/, optimizations/, geometries/, renderers/. TerrainManager recibe un port de particles inyectado (no usa terrain/api/).
5. [ ] ECS está en `rendering/ecs/` con estructura: core/ (world/manager, system), components/, domains/ (animation, combat, input, physics, collision, render, weapon) con systems y helpers dentro de cada dominio; state-machine y conditions dentro de domains/animation/; combos dentro de domains/combat/; factories/ en la raíz de ecs. Loaders (model-loader, model-cache, model-utils, bones, vertex-groups) están en `rendering/loaders/`, no dentro de ecs.
6. [ ] Game loop y bootstrap están en `driving/game/`; InputManager en `driving/input/`; paneles (debug, test-interface, etc.) en `driving/ui/panels/` usando BaseInterface.
7. [ ] Utilidades puras (math, geometry, colors, helpers) están en `shared/`; config y state siguen en raíz con la misma responsabilidad.
8. [ ] El juego arranca, carga mundo, spawnea jugador, y el loop actualiza ECS, terrain y world sin regresiones funcionales.

## Detalles de Implementación

### Consideraciones Técnicas
- **Incrementalidad:** Hacer la refactorización por fases (primero estructura global y ports/adapters/application; luego mover rendering y ecs; luego reestructurar ECS por dominios) para poder verificar que no se rompe nada.
- **Imports:** Actualizar todos los imports en cada paso; el build o el servidor de desarrollo deben seguir funcionando.
- **Terrain:** Eliminar `terrain/api/` y que TerrainManager reciba un port `particlesApi` (y opcionalmente worldApi) inyectado por App; la obtención de datos la hace el caso de uso loadWorld o App antes de inicializar terrain, o TerrainManager llama al port inyectado cuando cambia el viewport.
- **ECS:** La reestructuración interna del ECS (domains/animation, domains/combat, etc.) es la parte más invasiva; puede hacerse en una fase final tras haber movido ecs a rendering/ecs y loaders a rendering/loaders.

### Dependencias
- Depende de: documentación ya existente (frontend-estructura-elegida.md, frontend-arquitectura-hexagonal.md)
- Bloquea: (ninguno crítico)

## Testing

### Escenarios de Prueba
1. Arranque: main.js → app.start() → carga mundo y spawnea jugador sin errores en consola.
2. Gameplay: movimiento, animaciones, combate, colisiones, cámara y cielo funcionan igual que antes.
3. Paneles F3 y F6 abren y muestran métricas e inspector de entidades.
4. Terrain carga partículas (vía port o datos inyectados) y se actualiza al mover la cámara.

### Casos Edge a Considerar
- Imports circulares al introducir ports/application/domain; mantener dependencias unidireccionales.
- Referencias a rutas antiguas (core/, api/, ecs/) en otros archivos o en documentación; actualizar en el mismo refactor.

## Estimación

- **Complejidad:** Alta
- **Tiempo estimado:** 3–5 días (según fases; la reestructuración ECS por dominios es la más laboriosa)
- **Notas:** Conviene hacer PRs por fase (Fase 1: ports, adapters, domain, application, driving; Fase 2: rendering con scene, loaders, ecs, terrain, world, optimizations, geometries, renderers; Fase 3: ECS interno por dominios) para revisión manejable.

## Referencias

- **Documentación relevante:** `docs/frontend-estructura-elegida.md`, `docs/frontend-arquitectura-hexagonal.md`
- **Estructura actual:** `frontend/src/` (api, app, config, core, debug, ecs, interfaces, state, terrain, utils, world)

## Notas Adicionales

- Terrain, world, state y config se mantienen en su forma actual (manager + systems para terrain; plano para world; store + actions + selectors para state; config plana); no hace falta repensarlos desde cero, solo ubicarlos bajo rendering/ donde corresponda (terrain, world) y dejar state y config en raíz.
- El plan de acción asociado (JDG-067-action-plan_*.md) desglosa los pasos por fases para ejecutar la refactorización de forma ordenada.
