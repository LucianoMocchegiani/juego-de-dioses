# JDG-068 - Completar Hexagonal al 100%: ports formales, domain centralizado e inyección TerrainManager

## Tipo
- [x] Feature (nueva funcionalidad)
- [ ] Bugfix (corrección de error)
- [ ] Refactor (mejora de código sin cambiar funcionalidad)
- [ ] Performance (optimización)
- [ ] Documentation (documentación)
- [ ] Chore (tareas de mantenimiento)

## Prioridad
- [ ] Alta (bloquea funcionalidad crítica)
- [x] Media (importante pero no bloqueante)
- [ ] Baja (mejora o nice-to-have)

## Descripción

### Problema/Requerimiento
Tras la refactorización del frontend a estructura hexagonal + ECS por dominios (JDG-067), quedan tres puntos para alinear al 100% con el documento de arquitectura elegida:

1. **Carpeta `ports/` con contratos formales**: Hoy `ports/` tiene solo un README que describe las APIs (worldApi, particlesApi, charactersApi, etc.). No existen interfaces/contratos codificados que los adapters implementen y que los consumidores (App, TerrainManager, casos de uso) dependan explícitamente.

2. **Carpeta `domain/` con modelos puros centralizados**: Ya existen `domain/world/`, `domain/particles/`, `domain/character/` con algunos modelos (Dimension, Viewport, ParticleType, CharacterModel). Falta confirmar que todos los modelos de dominio usados por aplicación y rendering estén centralizados aquí y no duplicados en config o en otros módulos.

3. **Confirmar que TerrainManager recibe el port de partículas inyectado**: Verificar y documentar que `TerrainManager` recibe `particlesApi` (y `bloquesApi`) por constructor desde App, que a su vez los obtiene del objeto `ports` creado en el bootstrap, sin instanciar adapters directamente.

### Comportamiento Actual
- `ports/README.md` documenta los contratos en prosa; no hay archivos de contrato (JSDoc interfaces o módulos que exporten “tipos” de port).
- `domain/` tiene modelos parciales; puede haber tipos/estructuras de dominio repartidos en config o en rendering.
- TerrainManager se instancia en `app.js` con `this.particlesApi` y `this.bloquesApi`; el flujo de inyección existe pero no está explícitamente documentado como requisito arquitectónico.

### Comportamiento Esperado
- **ports/**: Contratos formales (por ejemplo módulos que exporten interfaces JSDoc o objetos “contrato”) para cada port (particlesApi, bloquesApi, worldApi, charactersApi, celestialApi, agrupacionesApi). Los adapters en `adapters/http/` implementan esos contratos; App y TerrainManager dependen del contrato, no del adapter.
- **domain/**: Modelos de dominio puros centralizados en `domain/`; sin dependencias de Three.js, fetch ni DOM. Cualquier tipo usado como “dominio” (Dimension, Viewport, Particle, ParticleType, Character, etc.) referenciado desde application o rendering debe vivir o reexportarse desde `domain/`.
- **TerrainManager**: Documentado y verificado que recibe el port de partículas (y bloques) inyectado; no crea ni importa el adapter directamente. Opcional: añadir comprobación o comentario en constructor que deje claro el contrato esperado.

## Contexto Técnico

### Componentes Afectados
- [ ] Backend (FastAPI)
- [x] Frontend (Three.js)
- [ ] Base de Datos (PostgreSQL)
- [ ] Cache (Redis)
- [ ] Docker/Infraestructura
- [ ] API Endpoints
- [ ] WebSockets

### Tecnologías Involucradas
- JavaScript ES6+, módulos ES
- JSDoc para contratos (interfaces) si no se usa TypeScript
- Estructura de carpetas: `frontend/src/ports/`, `frontend/src/domain/`, `frontend/src/adapters/http/`, `frontend/src/application/`, `frontend/src/rendering/terrain/`

### Archivos/Componentes Principales
- `frontend/src/ports/` – nuevos o modificados: contratos (ej. `particles-port.js`, `bloques-port.js`, etc. o un único `ports.js` con todos los contratos).
- `frontend/src/domain/` – revisar y centralizar modelos (world, particles, character).
- `frontend/src/adapters/http/` – asegurar que implementan los contratos de ports (misma firma de métodos).
- `frontend/src/rendering/terrain/manager.js` – TerrainManager: documentar que recibe ports inyectados; opcional validación de interfaz.
- `frontend/src/app.js` – ya recibe `ports` y pasa `particlesApi`/`bloquesApi` a TerrainManager; solo verificar y referenciar en docs.
- `frontend/src/driving/game/game-bootstrap.js` – donde se crean los ports (adapters) y se inyectan en App.
- `instructions/` o `docs/` – documentación de la arquitectura (frontend-estructura-elegida.md u otro).

## Criterios de Aceptación

1. [ ] Existe al menos un mecanismo formal de contrato para los ports (archivos en `ports/` que definan la forma de cada API: métodos y parámetros/retornos, vía JSDoc o módulos exportables).
2. [ ] Los adapters HTTP (`adapters/http/*.js`) cumplen o documentan conformidad con los contratos de `ports/`.
3. [ ] Los modelos de dominio usados por aplicación y por terreno/rendering están definidos o reexportados desde `domain/` (world, particles, character); se ha revisado que no queden modelos “de dominio” duplicados en config o en otros módulos sin referencia a domain.
4. [ ] Está documentado (en código o en docs) que TerrainManager recibe el port de partículas (y bloques) inyectado por constructor y no instancia adapters; y se ha verificado en código que efectivamente recibe `particlesApi`/`bloquesApi` desde App.

## Detalles de Implementación

### Consideraciones Técnicas
- **Contratos en JS**: Sin TypeScript, usar JSDoc `@interface` y `@typedef` para describir la forma de cada port; los adapters pueden documentar `@implements` o referenciar el contrato en el README.
- **Domain**: Mantener domain libre de dependencias de Three.js, fetch y DOM para facilitar tests y reutilización.
- **TerrainManager**: No cambiar la firma actual del constructor; solo documentar y, si se desea, añadir un comentario o assert en desarrollo que verifique la presencia de métodos esperados del port.

### Dependencias
- Depende de: JDG-067 (Refactorización del frontend a Hexagonal + ECS por dominios).
- No bloquea otros tickets de forma crítica.

## Testing

### Escenarios de Prueba
1. Tras añadir contratos en `ports/`, el juego sigue cargando y el terreno se actualiza correctamente (partículas desde backend).
2. Tras centralizar modelos en `domain/`, no hay regresiones en carga de mundo, spawn de personaje ni renderizado de partículas.
3. TerrainManager sigue recibiendo `particlesApi` desde App; flujo bootstrap → App → TerrainManager verificado.

### Casos Edge a Considerar
- Si algún adapter tiene métodos adicionales no descritos en el contrato, documentarlos en el contrato o en el README del port.
- Modelos que hoy son “config” o constantes pero representan entidades de dominio: evaluar si moverlos a `domain/` o dejarlos documentados como excepción.

## Estimación

- **Complejidad:** Media
- **Tiempo estimado:** 4–8 horas
- **Notas:** Depende del nivel de formalidad deseado para contratos (solo JSDoc vs. módulos dedicados por port) y del alcance de la centralización en domain.

## Referencias

- **Relacionado con:** JDG-067 (Refactorización frontend Hexagonal + ECS).
- **Documentación relevante:** `docs/frontend-estructura-elegida.md`, `frontend/src/ports/README.md`, `frontend/src/domain/README.md`.
- **Discusiones previas:** Completar lo faltante para estar al 100% con el doc de arquitectura (ports formales, domain centralizado, TerrainManager con port inyectado).

## Notas Adicionales

- Los tres ítems pueden implementarse en cualquier orden; sugerencia: (1) confirmar y documentar inyección en TerrainManager, (2) contratos en ports, (3) revisar y centralizar domain.
- Si el equipo prefiere no formalizar contratos con archivos adicionales, al menos actualizar `ports/README.md` con la firma exacta de cada API (métodos, parámetros, retornos) y referenciar que TerrainManager recibe esos ports inyectados.
